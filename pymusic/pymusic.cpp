/* Generated by Cython 0.21.1 */

#define PY_SSIZE_T_CLEAN
#ifndef CYTHON_USE_PYLONG_INTERNALS
#ifdef PYLONG_BITS_IN_DIGIT
#define CYTHON_USE_PYLONG_INTERNALS 0
#else
#include "pyconfig.h"
#ifdef PYLONG_BITS_IN_DIGIT
#define CYTHON_USE_PYLONG_INTERNALS 1
#else
#define CYTHON_USE_PYLONG_INTERNALS 0
#endif
#endif
#endif
#include "Python.h"
#ifndef Py_PYTHON_H
    #error Python headers needed to compile C extensions, please install development version of Python.
#elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03020000)
    #error Cython requires Python 2.6+ or Python 3.2+.
#else
#define CYTHON_ABI "0_21_1"
#include <stddef.h>
#ifndef offsetof
#define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
#endif
#if !defined(WIN32) && !defined(MS_WINDOWS)
  #ifndef __stdcall
    #define __stdcall
  #endif
  #ifndef __cdecl
    #define __cdecl
  #endif
  #ifndef __fastcall
    #define __fastcall
  #endif
#endif
#ifndef DL_IMPORT
  #define DL_IMPORT(t) t
#endif
#ifndef DL_EXPORT
  #define DL_EXPORT(t) t
#endif
#ifndef PY_LONG_LONG
  #define PY_LONG_LONG LONG_LONG
#endif
#ifndef Py_HUGE_VAL
  #define Py_HUGE_VAL HUGE_VAL
#endif
#ifdef PYPY_VERSION
#define CYTHON_COMPILING_IN_PYPY 1
#define CYTHON_COMPILING_IN_CPYTHON 0
#else
#define CYTHON_COMPILING_IN_PYPY 0
#define CYTHON_COMPILING_IN_CPYTHON 1
#endif
#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX < 0x02070600
#define Py_OptimizeFlag 0
#endif
#define __PYX_BUILD_PY_SSIZE_T "n"
#define CYTHON_FORMAT_SSIZE_T "z"
#if PY_MAJOR_VERSION < 3
  #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos) \
          PyCode_New(a+k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
  #define __Pyx_DefaultClassType PyClass_Type
#else
  #define __Pyx_BUILTIN_MODULE_NAME "builtins"
  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos) \
          PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
  #define __Pyx_DefaultClassType PyType_Type
#endif
#if PY_MAJOR_VERSION >= 3
  #define Py_TPFLAGS_CHECKTYPES 0
  #define Py_TPFLAGS_HAVE_INDEX 0
  #define Py_TPFLAGS_HAVE_NEWBUFFER 0
#endif
#if PY_VERSION_HEX < 0x030400a1 && !defined(Py_TPFLAGS_HAVE_FINALIZE)
  #define Py_TPFLAGS_HAVE_FINALIZE 0
#endif
#if PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
  #define CYTHON_PEP393_ENABLED 1
  #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ? \
                                              0 : _PyUnicode_Ready((PyObject *)(op)))
  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_LENGTH(u)
  #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_READ_CHAR(u, i)
  #define __Pyx_PyUnicode_KIND(u)         PyUnicode_KIND(u)
  #define __Pyx_PyUnicode_DATA(u)         PyUnicode_DATA(u)
  #define __Pyx_PyUnicode_READ(k, d, i)   PyUnicode_READ(k, d, i)
#else
  #define CYTHON_PEP393_ENABLED 0
  #define __Pyx_PyUnicode_READY(op)       (0)
  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_SIZE(u)
  #define __Pyx_PyUnicode_READ_CHAR(u, i) ((Py_UCS4)(PyUnicode_AS_UNICODE(u)[i]))
  #define __Pyx_PyUnicode_KIND(u)         (sizeof(Py_UNICODE))
  #define __Pyx_PyUnicode_DATA(u)         ((void*)PyUnicode_AS_UNICODE(u))
  #define __Pyx_PyUnicode_READ(k, d, i)   ((void)(k), (Py_UCS4)(((Py_UNICODE*)d)[i]))
#endif
#if CYTHON_COMPILING_IN_PYPY
  #define __Pyx_PyUnicode_Concat(a, b)      PyNumber_Add(a, b)
  #define __Pyx_PyUnicode_ConcatSafe(a, b)  PyNumber_Add(a, b)
  #define __Pyx_PyFrozenSet_Size(s)         PyObject_Size(s)
#else
  #define __Pyx_PyUnicode_Concat(a, b)      PyUnicode_Concat(a, b)
  #define __Pyx_PyUnicode_ConcatSafe(a, b)  ((unlikely((a) == Py_None) || unlikely((b) == Py_None)) ? \
      PyNumber_Add(a, b) : __Pyx_PyUnicode_Concat(a, b))
  #define __Pyx_PyFrozenSet_Size(s)         PySet_Size(s)
#endif
#define __Pyx_PyString_FormatSafe(a, b)   ((unlikely((a) == Py_None)) ? PyNumber_Remainder(a, b) : __Pyx_PyString_Format(a, b))
#define __Pyx_PyUnicode_FormatSafe(a, b)  ((unlikely((a) == Py_None)) ? PyNumber_Remainder(a, b) : PyUnicode_Format(a, b))
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyString_Format(a, b)  PyUnicode_Format(a, b)
#else
  #define __Pyx_PyString_Format(a, b)  PyString_Format(a, b)
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyBaseString_Type            PyUnicode_Type
  #define PyStringObject               PyUnicodeObject
  #define PyString_Type                PyUnicode_Type
  #define PyString_Check               PyUnicode_Check
  #define PyString_CheckExact          PyUnicode_CheckExact
#endif
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyBaseString_Check(obj) PyUnicode_Check(obj)
  #define __Pyx_PyBaseString_CheckExact(obj) PyUnicode_CheckExact(obj)
#else
  #define __Pyx_PyBaseString_Check(obj) (PyString_Check(obj) || PyUnicode_Check(obj))
  #define __Pyx_PyBaseString_CheckExact(obj) (PyString_CheckExact(obj) || PyUnicode_CheckExact(obj))
#endif
#ifndef PySet_CheckExact
  #define PySet_CheckExact(obj)        (Py_TYPE(obj) == &PySet_Type)
#endif
#define __Pyx_TypeCheck(obj, type) PyObject_TypeCheck(obj, (PyTypeObject *)type)
#if PY_MAJOR_VERSION >= 3
  #define PyIntObject                  PyLongObject
  #define PyInt_Type                   PyLong_Type
  #define PyInt_Check(op)              PyLong_Check(op)
  #define PyInt_CheckExact(op)         PyLong_CheckExact(op)
  #define PyInt_FromString             PyLong_FromString
  #define PyInt_FromUnicode            PyLong_FromUnicode
  #define PyInt_FromLong               PyLong_FromLong
  #define PyInt_FromSize_t             PyLong_FromSize_t
  #define PyInt_FromSsize_t            PyLong_FromSsize_t
  #define PyInt_AsLong                 PyLong_AsLong
  #define PyInt_AS_LONG                PyLong_AS_LONG
  #define PyInt_AsSsize_t              PyLong_AsSsize_t
  #define PyInt_AsUnsignedLongMask     PyLong_AsUnsignedLongMask
  #define PyInt_AsUnsignedLongLongMask PyLong_AsUnsignedLongLongMask
  #define PyNumber_Int                 PyNumber_Long
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyBoolObject                 PyLongObject
#endif
#if PY_MAJOR_VERSION >= 3 && CYTHON_COMPILING_IN_PYPY
  #ifndef PyUnicode_InternFromString
    #define PyUnicode_InternFromString(s) PyUnicode_FromString(s)
  #endif
#endif
#if PY_VERSION_HEX < 0x030200A4
  typedef long Py_hash_t;
  #define __Pyx_PyInt_FromHash_t PyInt_FromLong
  #define __Pyx_PyInt_AsHash_t   PyInt_AsLong
#else
  #define __Pyx_PyInt_FromHash_t PyInt_FromSsize_t
  #define __Pyx_PyInt_AsHash_t   PyInt_AsSsize_t
#endif
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyMethod_New(func, self, klass) ((self) ? PyMethod_New(func, self) : PyInstanceMethod_New(func))
#else
  #define __Pyx_PyMethod_New(func, self, klass) PyMethod_New(func, self, klass)
#endif
#ifndef CYTHON_INLINE
  #if defined(__GNUC__)
    #define CYTHON_INLINE __inline__
  #elif defined(_MSC_VER)
    #define CYTHON_INLINE __inline
  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define CYTHON_INLINE inline
  #else
    #define CYTHON_INLINE
  #endif
#endif
#ifndef CYTHON_RESTRICT
  #if defined(__GNUC__)
    #define CYTHON_RESTRICT __restrict__
  #elif defined(_MSC_VER) && _MSC_VER >= 1400
    #define CYTHON_RESTRICT __restrict
  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define CYTHON_RESTRICT restrict
  #else
    #define CYTHON_RESTRICT
  #endif
#endif
#ifdef NAN
#define __PYX_NAN() ((float) NAN)
#else
static CYTHON_INLINE float __PYX_NAN() {
  /* Initialize NaN. The sign is irrelevant, an exponent with all bits 1 and
   a nonzero mantissa means NaN. If the first bit in the mantissa is 1, it is
   a quiet NaN. */
  float value;
  memset(&value, 0xFF, sizeof(value));
  return value;
}
#endif
#ifdef __cplusplus
template<typename T>
void __Pyx_call_destructor(T* x) {
    x->~T();
}
#endif


#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
#else
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_Divide(x,y)
  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceDivide(x,y)
#endif

#ifndef __PYX_EXTERN_C
  #ifdef __cplusplus
    #define __PYX_EXTERN_C extern "C"
  #else
    #define __PYX_EXTERN_C extern
  #endif
#endif

#if defined(WIN32) || defined(MS_WINDOWS)
#define _USE_MATH_DEFINES
#endif
#include <math.h>
#define __PYX_HAVE__pymusic
#define __PYX_HAVE_API__pymusic
#include "mpi.h"
#include "string.h"
#include <string>
#include "ios"
#include "new"
#include "stdexcept"
#include "typeinfo"
#include "music/predict_rank.hh"
#include "music/message.hh"
#include "music/music_c.h"
#include "music/event.hh"
#include "music/data_map.hh"
#include "music/index_map.hh"
#include "music/permutation_index.hh"
#include "music/linear_index.hh"
#include "music/array_data.hh"
#include "music/port.hh"
#include "music/setup.hh"
#include "music/runtime.hh"
#include "music/pymusic_c.h"
#include "stdlib.h"
#include "stdio.h"
#include "pythread.h"
#ifdef _OPENMP
#include <omp.h>
#endif /* _OPENMP */

#ifdef PYREX_WITHOUT_ASSERTIONS
#define CYTHON_WITHOUT_ASSERTIONS
#endif

#ifndef CYTHON_UNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define CYTHON_UNUSED __attribute__ ((__unused__))
#   else
#     define CYTHON_UNUSED
#   endif
# elif defined(__ICC) || (defined(__INTEL_COMPILER) && !defined(_MSC_VER))
#   define CYTHON_UNUSED __attribute__ ((__unused__))
# else
#   define CYTHON_UNUSED
# endif
#endif
typedef struct {PyObject **p; char *s; const Py_ssize_t n; const char* encoding;
                const char is_unicode; const char is_str; const char intern; } __Pyx_StringTabEntry;

#define __PYX_DEFAULT_STRING_ENCODING_IS_ASCII 0
#define __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT 1
#define __Pyx_PyObject_FromString __Pyx_PyBytes_FromString
#define __Pyx_PyObject_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
#define __Pyx_fits_Py_ssize_t(v, type, is_signed)  (    \
    (sizeof(type) < sizeof(Py_ssize_t))  ||             \
    (sizeof(type) > sizeof(Py_ssize_t) &&               \
          likely(v < (type)PY_SSIZE_T_MAX ||            \
                 v == (type)PY_SSIZE_T_MAX)  &&         \
          (!is_signed || likely(v > (type)PY_SSIZE_T_MIN ||       \
                                v == (type)PY_SSIZE_T_MIN)))  ||  \
    (sizeof(type) == sizeof(Py_ssize_t) &&              \
          (is_signed || likely(v < (type)PY_SSIZE_T_MAX ||        \
                               v == (type)PY_SSIZE_T_MAX)))  )
static CYTHON_INLINE char* __Pyx_PyObject_AsString(PyObject*);
static CYTHON_INLINE char* __Pyx_PyObject_AsStringAndSize(PyObject*, Py_ssize_t* length);
#define __Pyx_PyByteArray_FromString(s) PyByteArray_FromStringAndSize((const char*)s, strlen((const char*)s))
#define __Pyx_PyByteArray_FromStringAndSize(s, l) PyByteArray_FromStringAndSize((const char*)s, l)
#define __Pyx_PyBytes_FromString        PyBytes_FromString
#define __Pyx_PyBytes_FromStringAndSize PyBytes_FromStringAndSize
static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(const char*);
#if PY_MAJOR_VERSION < 3
    #define __Pyx_PyStr_FromString        __Pyx_PyBytes_FromString
    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
#else
    #define __Pyx_PyStr_FromString        __Pyx_PyUnicode_FromString
    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyUnicode_FromStringAndSize
#endif
#define __Pyx_PyObject_AsSString(s)    ((signed char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_AsUString(s)    ((unsigned char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_FromUString(s)  __Pyx_PyObject_FromString((const char*)s)
#define __Pyx_PyBytes_FromUString(s)   __Pyx_PyBytes_FromString((const char*)s)
#define __Pyx_PyByteArray_FromUString(s)   __Pyx_PyByteArray_FromString((const char*)s)
#define __Pyx_PyStr_FromUString(s)     __Pyx_PyStr_FromString((const char*)s)
#define __Pyx_PyUnicode_FromUString(s) __Pyx_PyUnicode_FromString((const char*)s)
#if PY_MAJOR_VERSION < 3
static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const Py_UNICODE *u)
{
    const Py_UNICODE *u_end = u;
    while (*u_end++) ;
    return (size_t)(u_end - u - 1);
}
#else
#define __Pyx_Py_UNICODE_strlen Py_UNICODE_strlen
#endif
#define __Pyx_PyUnicode_FromUnicode(u)       PyUnicode_FromUnicode(u, __Pyx_Py_UNICODE_strlen(u))
#define __Pyx_PyUnicode_FromUnicodeAndLength PyUnicode_FromUnicode
#define __Pyx_PyUnicode_AsUnicode            PyUnicode_AsUnicode
#define __Pyx_Owned_Py_None(b) (Py_INCREF(Py_None), Py_None)
#define __Pyx_PyBool_FromLong(b) ((b) ? (Py_INCREF(Py_True), Py_True) : (Py_INCREF(Py_False), Py_False))
static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x);
static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject*);
static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t);
#if CYTHON_COMPILING_IN_CPYTHON
#define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))
#else
#define __pyx_PyFloat_AsDouble(x) PyFloat_AsDouble(x)
#endif
#define __pyx_PyFloat_AsFloat(x) ((float) __pyx_PyFloat_AsDouble(x))
#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
static int __Pyx_sys_getdefaultencoding_not_ascii;
static int __Pyx_init_sys_getdefaultencoding_params(void) {
    PyObject* sys;
    PyObject* default_encoding = NULL;
    PyObject* ascii_chars_u = NULL;
    PyObject* ascii_chars_b = NULL;
    const char* default_encoding_c;
    sys = PyImport_ImportModule("sys");
    if (!sys) goto bad;
    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
    Py_DECREF(sys);
    if (!default_encoding) goto bad;
    default_encoding_c = PyBytes_AsString(default_encoding);
    if (!default_encoding_c) goto bad;
    if (strcmp(default_encoding_c, "ascii") == 0) {
        __Pyx_sys_getdefaultencoding_not_ascii = 0;
    } else {
        char ascii_chars[128];
        int c;
        for (c = 0; c < 128; c++) {
            ascii_chars[c] = c;
        }
        __Pyx_sys_getdefaultencoding_not_ascii = 1;
        ascii_chars_u = PyUnicode_DecodeASCII(ascii_chars, 128, NULL);
        if (!ascii_chars_u) goto bad;
        ascii_chars_b = PyUnicode_AsEncodedString(ascii_chars_u, default_encoding_c, NULL);
        if (!ascii_chars_b || !PyBytes_Check(ascii_chars_b) || memcmp(ascii_chars, PyBytes_AS_STRING(ascii_chars_b), 128) != 0) {
            PyErr_Format(
                PyExc_ValueError,
                "This module compiled with c_string_encoding=ascii, but default encoding '%.200s' is not a superset of ascii.",
                default_encoding_c);
            goto bad;
        }
        Py_DECREF(ascii_chars_u);
        Py_DECREF(ascii_chars_b);
    }
    Py_DECREF(default_encoding);
    return 0;
bad:
    Py_XDECREF(default_encoding);
    Py_XDECREF(ascii_chars_u);
    Py_XDECREF(ascii_chars_b);
    return -1;
}
#endif
#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT && PY_MAJOR_VERSION >= 3
#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_DecodeUTF8(c_str, size, NULL)
#else
#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_Decode(c_str, size, __PYX_DEFAULT_STRING_ENCODING, NULL)
#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
static char* __PYX_DEFAULT_STRING_ENCODING;
static int __Pyx_init_sys_getdefaultencoding_params(void) {
    PyObject* sys;
    PyObject* default_encoding = NULL;
    char* default_encoding_c;
    sys = PyImport_ImportModule("sys");
    if (!sys) goto bad;
    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
    Py_DECREF(sys);
    if (!default_encoding) goto bad;
    default_encoding_c = PyBytes_AsString(default_encoding);
    if (!default_encoding_c) goto bad;
    __PYX_DEFAULT_STRING_ENCODING = (char*) malloc(strlen(default_encoding_c));
    if (!__PYX_DEFAULT_STRING_ENCODING) goto bad;
    strcpy(__PYX_DEFAULT_STRING_ENCODING, default_encoding_c);
    Py_DECREF(default_encoding);
    return 0;
bad:
    Py_XDECREF(default_encoding);
    return -1;
}
#endif
#endif


/* Test for GCC > 2.95 */
#if defined(__GNUC__)     && (__GNUC__ > 2 || (__GNUC__ == 2 && (__GNUC_MINOR__ > 95)))
  #define likely(x)   __builtin_expect(!!(x), 1)
  #define unlikely(x) __builtin_expect(!!(x), 0)
#else /* !__GNUC__ or GCC < 2.95 */
  #define likely(x)   (x)
  #define unlikely(x) (x)
#endif /* __GNUC__ */

static PyObject *__pyx_m;
static PyObject *__pyx_d;
static PyObject *__pyx_b;
static PyObject *__pyx_empty_tuple;
static PyObject *__pyx_empty_bytes;
static int __pyx_lineno;
static int __pyx_clineno = 0;
static const char * __pyx_cfilenm= __FILE__;
static const char *__pyx_filename;


static const char *__pyx_f[] = {
  "pymusic.pyx",
  "array.pxd",
  "stringsource",
  "stringsource",
  "MPI.pxd",
  "music/pybuffer.pxd",
  "type.pxd",
  "bool.pxd",
  "complex.pxd",
};

/*--- Type declarations ---*/
#ifndef _ARRAYARRAY_H
struct arrayobject;
typedef struct arrayobject arrayobject;
#endif
struct PyMPIStatusObject;
struct PyMPIDatatypeObject;
struct PyMPIRequestObject;
struct PyMPIPrequestObject;
struct PyMPIGrequestObject;
struct PyMPIOpObject;
struct PyMPIGroupObject;
struct PyMPIInfoObject;
struct PyMPIErrhandlerObject;
struct PyMPICommObject;
struct PyMPIIntracommObject;
struct PyMPICartcommObject;
struct PyMPIGraphcommObject;
struct PyMPIDistgraphcommObject;
struct PyMPIIntercommObject;
struct PyMPIWinObject;
struct PyMPIFileObject;
struct __pyx_obj_5music_8pybuffer_Buffer;
struct __pyx_obj_7pymusic_Setup;
struct __pyx_obj_7pymusic_Runtime;
struct __pyx_obj_7pymusic_Port;
struct __pyx_obj_7pymusic_ContInputPort;
struct __pyx_obj_7pymusic_ContOutputPort;
struct __pyx_obj_7pymusic_EventInputPort;
struct __pyx_obj_7pymusic_EventOutputPort;
struct __pyx_obj_7pymusic_MessageInputPort;
struct __pyx_obj_7pymusic_MessageOutputPort;
struct __pyx_obj_7pymusic_DataMap;
struct __pyx_obj_7pymusic_IndexMap;
struct __pyx_obj_7pymusic_EventHandler;
struct __pyx_obj_7pymusic_MessageHandler;
struct __pyx_obj_7pymusic__Index;
struct __pyx_obj_7pymusic___pyx_scope_struct____iter__;
struct __pyx_t_7pymusic_Args;
typedef struct __pyx_t_7pymusic_Args __pyx_t_7pymusic_Args;

/* "pymusic.pyx":48
 * # argv = [exec, op[1], ..., op[argc-1], NULL]
 * # """
 * ctypedef struct Args:             # <<<<<<<<<<<<<<
 *     int argc
 *     char** argv
 */
struct __pyx_t_7pymusic_Args {
  int argc;
  char **argv;
};

/* "../../../../../usr/lib64/python2.7/site-packages/openmpi/mpi4py/include/mpi4py/MPI.pxd":49
 *     ctypedef MPI_Offset Offset "MPI_Offset"
 * 
 * ctypedef public api class Status [             # <<<<<<<<<<<<<<
 *     type   PyMPIStatus_Type,
 *     object PyMPIStatusObject,
 */
struct PyMPIStatusObject {
  PyObject_HEAD
  MPI_Status ob_mpi;
  int flags;
};
typedef struct PyMPIStatusObject PyMPIStatusObject;

__PYX_EXTERN_C DL_EXPORT(PyTypeObject) PyMPIStatus_Type;

/* "../../../../../usr/lib64/python2.7/site-packages/openmpi/mpi4py/include/mpi4py/MPI.pxd":56
 *     cdef int        flags
 * 
 * ctypedef public api class Datatype [             # <<<<<<<<<<<<<<
 *     type   PyMPIDatatype_Type,
 *     object PyMPIDatatypeObject,
 */
struct PyMPIDatatypeObject {
  PyObject_HEAD
  MPI_Datatype ob_mpi;
  int flags;
};
typedef struct PyMPIDatatypeObject PyMPIDatatypeObject;

__PYX_EXTERN_C DL_EXPORT(PyTypeObject) PyMPIDatatype_Type;

/* "../../../../../usr/lib64/python2.7/site-packages/openmpi/mpi4py/include/mpi4py/MPI.pxd":63
 *     cdef int          flags
 * 
 * ctypedef public api class Request [             # <<<<<<<<<<<<<<
 *     type   PyMPIRequest_Type,
 *     object PyMPIRequestObject,
 */
struct PyMPIRequestObject {
  PyObject_HEAD
  MPI_Request ob_mpi;
  int flags;
  PyObject *ob_buf;
};
typedef struct PyMPIRequestObject PyMPIRequestObject;

__PYX_EXTERN_C DL_EXPORT(PyTypeObject) PyMPIRequest_Type;

/* "../../../../../usr/lib64/python2.7/site-packages/openmpi/mpi4py/include/mpi4py/MPI.pxd":71
 *     cdef object      ob_buf
 * 
 * ctypedef public api class Prequest(Request) [             # <<<<<<<<<<<<<<
 *     type   PyMPIPrequest_Type,
 *     object PyMPIPrequestObject,
 */
struct PyMPIPrequestObject {
  struct PyMPIRequestObject __pyx_base;
};
typedef struct PyMPIPrequestObject PyMPIPrequestObject;

__PYX_EXTERN_C DL_EXPORT(PyTypeObject) PyMPIPrequest_Type;

/* "../../../../../usr/lib64/python2.7/site-packages/openmpi/mpi4py/include/mpi4py/MPI.pxd":77
 *     pass
 * 
 * ctypedef public api class Grequest(Request) [             # <<<<<<<<<<<<<<
 *     type   PyMPIGrequest_Type,
 *     object PyMPIGrequestObject,
 */
struct PyMPIGrequestObject {
  struct PyMPIRequestObject __pyx_base;
  MPI_Request ob_grequest;
};
typedef struct PyMPIGrequestObject PyMPIGrequestObject;

__PYX_EXTERN_C DL_EXPORT(PyTypeObject) PyMPIGrequest_Type;

/* "../../../../../usr/lib64/python2.7/site-packages/openmpi/mpi4py/include/mpi4py/MPI.pxd":83
 *     cdef MPI_Request ob_grequest
 * 
 * ctypedef public api class Op [             # <<<<<<<<<<<<<<
 *     type   PyMPIOp_Type,
 *     object PyMPIOpObject,
 */
struct PyMPIOpObject {
  PyObject_HEAD
  MPI_Op ob_mpi;
  int flags;
  PyObject *(*ob_func)(PyObject *, PyObject *);
  int ob_usrid;
};
typedef struct PyMPIOpObject PyMPIOpObject;

__PYX_EXTERN_C DL_EXPORT(PyTypeObject) PyMPIOp_Type;

/* "../../../../../usr/lib64/python2.7/site-packages/openmpi/mpi4py/include/mpi4py/MPI.pxd":92
 *     cdef int    ob_usrid
 * 
 * ctypedef public api class Group [             # <<<<<<<<<<<<<<
 *     type   PyMPIGroup_Type,
 *     object PyMPIGroupObject,
 */
struct PyMPIGroupObject {
  PyObject_HEAD
  MPI_Group ob_mpi;
  int flags;
};
typedef struct PyMPIGroupObject PyMPIGroupObject;

__PYX_EXTERN_C DL_EXPORT(PyTypeObject) PyMPIGroup_Type;

/* "../../../../../usr/lib64/python2.7/site-packages/openmpi/mpi4py/include/mpi4py/MPI.pxd":99
 *     cdef int       flags
 * 
 * ctypedef public api class Info [             # <<<<<<<<<<<<<<
 *     type   PyMPIInfo_Type,
 *     object PyMPIInfoObject,
 */
struct PyMPIInfoObject {
  PyObject_HEAD
  MPI_Info ob_mpi;
  int flags;
};
typedef struct PyMPIInfoObject PyMPIInfoObject;

__PYX_EXTERN_C DL_EXPORT(PyTypeObject) PyMPIInfo_Type;

/* "../../../../../usr/lib64/python2.7/site-packages/openmpi/mpi4py/include/mpi4py/MPI.pxd":106
 *     cdef int      flags
 * 
 * ctypedef public api class Errhandler [             # <<<<<<<<<<<<<<
 *     type   PyMPIErrhandler_Type,
 *     object PyMPIErrhandlerObject,
 */
struct PyMPIErrhandlerObject {
  PyObject_HEAD
  MPI_Errhandler ob_mpi;
  int flags;
};
typedef struct PyMPIErrhandlerObject PyMPIErrhandlerObject;

__PYX_EXTERN_C DL_EXPORT(PyTypeObject) PyMPIErrhandler_Type;

/* "../../../../../usr/lib64/python2.7/site-packages/openmpi/mpi4py/include/mpi4py/MPI.pxd":113
 *     cdef int            flags
 * 
 * ctypedef public api class Comm [             # <<<<<<<<<<<<<<
 *     type   PyMPIComm_Type,
 *     object PyMPICommObject,
 */
struct PyMPICommObject {
  PyObject_HEAD
  MPI_Comm ob_mpi;
  int flags;
};
typedef struct PyMPICommObject PyMPICommObject;

__PYX_EXTERN_C DL_EXPORT(PyTypeObject) PyMPIComm_Type;

/* "../../../../../usr/lib64/python2.7/site-packages/openmpi/mpi4py/include/mpi4py/MPI.pxd":120
 *     cdef int      flags
 * 
 * ctypedef public api class Intracomm(Comm) [             # <<<<<<<<<<<<<<
 *     type   PyMPIIntracomm_Type,
 *     object PyMPIIntracommObject,
 */
struct PyMPIIntracommObject {
  struct PyMPICommObject __pyx_base;
};
typedef struct PyMPIIntracommObject PyMPIIntracommObject;

__PYX_EXTERN_C DL_EXPORT(PyTypeObject) PyMPIIntracomm_Type;

/* "../../../../../usr/lib64/python2.7/site-packages/openmpi/mpi4py/include/mpi4py/MPI.pxd":126
 *     pass
 * 
 * ctypedef public api class Cartcomm(Intracomm) [             # <<<<<<<<<<<<<<
 *     type   PyMPICartcomm_Type,
 *     object PyMPICartcommObject,
 */
struct PyMPICartcommObject {
  struct PyMPIIntracommObject __pyx_base;
};
typedef struct PyMPICartcommObject PyMPICartcommObject;

__PYX_EXTERN_C DL_EXPORT(PyTypeObject) PyMPICartcomm_Type;

/* "../../../../../usr/lib64/python2.7/site-packages/openmpi/mpi4py/include/mpi4py/MPI.pxd":132
 *     pass
 * 
 * ctypedef public api class Graphcomm(Intracomm) [             # <<<<<<<<<<<<<<
 *     type   PyMPIGraphcomm_Type,
 *     object PyMPIGraphcommObject,
 */
struct PyMPIGraphcommObject {
  struct PyMPIIntracommObject __pyx_base;
};
typedef struct PyMPIGraphcommObject PyMPIGraphcommObject;

__PYX_EXTERN_C DL_EXPORT(PyTypeObject) PyMPIGraphcomm_Type;

/* "../../../../../usr/lib64/python2.7/site-packages/openmpi/mpi4py/include/mpi4py/MPI.pxd":138
 *     pass
 * 
 * ctypedef public api class Distgraphcomm(Intracomm) [             # <<<<<<<<<<<<<<
 *     type   PyMPIDistgraphcomm_Type,
 *     object PyMPIDistgraphcommObject,
 */
struct PyMPIDistgraphcommObject {
  struct PyMPIIntracommObject __pyx_base;
};
typedef struct PyMPIDistgraphcommObject PyMPIDistgraphcommObject;

__PYX_EXTERN_C DL_EXPORT(PyTypeObject) PyMPIDistgraphcomm_Type;

/* "../../../../../usr/lib64/python2.7/site-packages/openmpi/mpi4py/include/mpi4py/MPI.pxd":144
 *     pass
 * 
 * ctypedef public api class Intercomm(Comm) [             # <<<<<<<<<<<<<<
 *     type   PyMPIIntercomm_Type,
 *     object PyMPIIntercommObject,
 */
struct PyMPIIntercommObject {
  struct PyMPICommObject __pyx_base;
};
typedef struct PyMPIIntercommObject PyMPIIntercommObject;

__PYX_EXTERN_C DL_EXPORT(PyTypeObject) PyMPIIntercomm_Type;

/* "../../../../../usr/lib64/python2.7/site-packages/openmpi/mpi4py/include/mpi4py/MPI.pxd":150
 *     pass
 * 
 * ctypedef public api class Win [             # <<<<<<<<<<<<<<
 *     type   PyMPIWin_Type,
 *     object PyMPIWinObject,
 */
struct PyMPIWinObject {
  PyObject_HEAD
  MPI_Win ob_mpi;
  int flags;
};
typedef struct PyMPIWinObject PyMPIWinObject;

__PYX_EXTERN_C DL_EXPORT(PyTypeObject) PyMPIWin_Type;

/* "../../../../../usr/lib64/python2.7/site-packages/openmpi/mpi4py/include/mpi4py/MPI.pxd":157
 *     cdef int     flags
 * 
 * ctypedef public api class File [             # <<<<<<<<<<<<<<
 *     type   PyMPIFile_Type,
 *     object PyMPIFileObject,
 */
struct PyMPIFileObject {
  PyObject_HEAD
  MPI_File ob_mpi;
  int flags;
};
typedef struct PyMPIFileObject PyMPIFileObject;

__PYX_EXTERN_C DL_EXPORT(PyTypeObject) PyMPIFile_Type;

/* "music/pybuffer.pxd":40
 *     int  PyBuffer_FillInfo(Py_buffer*, object, void*, Py_ssize_t, bint, int) except -1
 * 
 * cdef class Buffer(object):             # <<<<<<<<<<<<<<
 *     cdef Py_buffer pybuf
 *     cdef MPI.Datatype dtype
 */
struct __pyx_obj_5music_8pybuffer_Buffer {
  PyObject_HEAD
  Py_buffer pybuf;
  struct PyMPIDatatypeObject *dtype;
  Py_ssize_t items;
};


/* "pymusic.pxd":164
 * ###########################################################
 * 
 * cdef class Setup(object):             # <<<<<<<<<<<<<<
 *     cdef CSetup* ptr
 *     cdef list argv
 */
struct __pyx_obj_7pymusic_Setup {
  PyObject_HEAD
  struct __pyx_vtabstruct_7pymusic_Setup *__pyx_vtab;
  MUSIC::Setup *ptr;
  PyObject *argv;
  int provided;
  struct PyMPIIntracommObject *comm;
  PyObject *ports;
};


/* "pymusic.pxd":176
 * ###########################################################
 * 
 * cdef class Runtime(object):             # <<<<<<<<<<<<<<
 *     cdef CRuntime* ptr
 *     cdef readonly MPI.Intracomm comm
 */
struct __pyx_obj_7pymusic_Runtime {
  PyObject_HEAD
  MUSIC::Runtime *ptr;
  struct PyMPIIntracommObject *comm;
  PyObject *ports;
};


/* "pymusic.pxd":183
 * ###########################################################
 * 
 * cdef class Port(object):             # <<<<<<<<<<<<<<
 *     cdef CPort* ptr
 *     cpdef object null(self)
 */
struct __pyx_obj_7pymusic_Port {
  PyObject_HEAD
  struct __pyx_vtabstruct_7pymusic_Port *__pyx_vtab;
  MUSIC::Port *ptr;
};


/* "pymusic.pxd":190
 * ## a capital crime ^^^^
 * 
 * cdef class ContInputPort(Port):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_7pymusic_ContInputPort {
  struct __pyx_obj_7pymusic_Port __pyx_base;
};


/* "pymusic.pxd":193
 *     pass
 * 
 * cdef class ContOutputPort(Port):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_7pymusic_ContOutputPort {
  struct __pyx_obj_7pymusic_Port __pyx_base;
};


/* "pymusic.pxd":196
 *     pass
 * 
 * cdef class EventInputPort(Port):             # <<<<<<<<<<<<<<
 *     cdef set events
 *     cpdef object null(self)
 */
struct __pyx_obj_7pymusic_EventInputPort {
  struct __pyx_obj_7pymusic_Port __pyx_base;
  PyObject *events;
};


/* "pymusic.pxd":200
 *     cpdef object null(self)
 * 
 * cdef class EventOutputPort(Port):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_7pymusic_EventOutputPort {
  struct __pyx_obj_7pymusic_Port __pyx_base;
};


/* "pymusic.pxd":203
 *     pass
 * 
 * cdef class MessageInputPort(Port):             # <<<<<<<<<<<<<<
 *     cdef set events
 *     cpdef object null(self)
 */
struct __pyx_obj_7pymusic_MessageInputPort {
  struct __pyx_obj_7pymusic_Port __pyx_base;
  PyObject *events;
};


/* "pymusic.pxd":207
 *     cpdef object null(self)
 * 
 * cdef class MessageOutputPort(Port):             # <<<<<<<<<<<<<<
 *     cdef bint pickled
 * 
 */
struct __pyx_obj_7pymusic_MessageOutputPort {
  struct __pyx_obj_7pymusic_Port __pyx_base;
  int pickled;
};


/* "pymusic.pxd":214
 * from music.pybuffer cimport Buffer
 * 
 * cdef class DataMap(object):             # <<<<<<<<<<<<<<
 *     cdef CDataMap* ptr
 *     cdef Buffer buf
 */
struct __pyx_obj_7pymusic_DataMap {
  PyObject_HEAD
  MUSIC::DataMap *ptr;
  struct __pyx_obj_5music_8pybuffer_Buffer *buf;
};


/* "pymusic.pxd":218
 *     cdef Buffer buf
 * 
 * cdef class IndexMap(object):             # <<<<<<<<<<<<<<
 *     cdef CIndexMap* ptr
 *     cdef Buffer buf
 */
struct __pyx_obj_7pymusic_IndexMap {
  PyObject_HEAD
  MUSIC::IndexMap *ptr;
  struct __pyx_obj_5music_8pybuffer_Buffer *buf;
};


/* "pymusic.pxd":222
 *     cdef Buffer buf
 * 
 * cdef class EventHandler:             # <<<<<<<<<<<<<<
 *     cdef CEventHandler* ptr
 *     cdef object func
 */
struct __pyx_obj_7pymusic_EventHandler {
  PyObject_HEAD
  MUSIC::EventHandler *ptr;
  PyObject *func;
};


/* "pymusic.pxd":226
 *     cdef object func
 * 
 * cdef class MessageHandler:             # <<<<<<<<<<<<<<
 *     cdef CMessageHandler* ptr
 *     cdef object func
 */
struct __pyx_obj_7pymusic_MessageHandler {
  PyObject_HEAD
  MUSIC::MessageHandler *ptr;
  PyObject *func;
};


/* "pymusic.pyx":636
 *     def __dealloc__(self): del self.ptr
 * 
 * cdef class _Index:             # <<<<<<<<<<<<<<
 *     """
 *     Internal: the type of the variable Index
 */
struct __pyx_obj_7pymusic__Index {
  PyObject_HEAD
  int GLOBAL;
  int LOCAL;
  PyObject *backmap;
};


/* "pymusic.pyx":538
 *     def tick(self): tick(self.ptr)
 * 
 *     def __iter__(self):             # <<<<<<<<<<<<<<
 *         cdef CRuntime* ptr = self.ptr
 *         while True:
 */
struct __pyx_obj_7pymusic___pyx_scope_struct____iter__ {
  PyObject_HEAD
  MUSIC::Runtime *__pyx_v_ptr;
  struct __pyx_obj_7pymusic_Runtime *__pyx_v_self;
};



/* "pymusic.pyx":348
 * 
 * import sys
 * cdef class Setup(object):             # <<<<<<<<<<<<<<
 *     """
 *     API to setup the music interface.
 */

struct __pyx_vtabstruct_7pymusic_Setup {
  PyObject *(*null)(struct __pyx_obj_7pymusic_Setup *);
  struct PyMPIIntracommObject *(*getcomm)(struct __pyx_obj_7pymusic_Setup *, int __pyx_skip_dispatch);
};
static struct __pyx_vtabstruct_7pymusic_Setup *__pyx_vtabptr_7pymusic_Setup;


/* "pymusic.pyx":90
 * ###########################################################
 * 
 * cdef class Port(object):             # <<<<<<<<<<<<<<
 *     """
 *     Base Port class.
 */

struct __pyx_vtabstruct_7pymusic_Port {
  PyObject *(*null)(struct __pyx_obj_7pymusic_Port *, int __pyx_skip_dispatch);
};
static struct __pyx_vtabstruct_7pymusic_Port *__pyx_vtabptr_7pymusic_Port;


/* "pymusic.pyx":138
 *         return self.ptr.width()
 * 
 * cdef class ContInputPort(Port):             # <<<<<<<<<<<<<<
 *     """
 *     ContInputPort maps data indices between sources and sinks. This is
 */

struct __pyx_vtabstruct_7pymusic_ContInputPort {
  struct __pyx_vtabstruct_7pymusic_Port __pyx_base;
};
static struct __pyx_vtabstruct_7pymusic_ContInputPort *__pyx_vtabptr_7pymusic_ContInputPort;


/* "pymusic.pyx":178
 *         mapImpl(ptr, d.ptr, delay, maxBuffered, interpolate)
 * 
 * cdef class ContOutputPort(Port):             # <<<<<<<<<<<<<<
 *     """
 *     ContOutputPort maps data indices between sources and sinks. This
 */

struct __pyx_vtabstruct_7pymusic_ContOutputPort {
  struct __pyx_vtabstruct_7pymusic_Port __pyx_base;
};
static struct __pyx_vtabstruct_7pymusic_ContOutputPort *__pyx_vtabptr_7pymusic_ContOutputPort;


/* "pymusic.pyx":207
 *         mapImpl(ptr, d.ptr, maxBuffered)
 * 
 * cdef class EventInputPort(Port):             # <<<<<<<<<<<<<<
 *     """
 *     Event sink. Maps 'events' to handlers. Events are spike-like
 */

struct __pyx_vtabstruct_7pymusic_EventInputPort {
  struct __pyx_vtabstruct_7pymusic_Port __pyx_base;
};
static struct __pyx_vtabstruct_7pymusic_EventInputPort *__pyx_vtabptr_7pymusic_EventInputPort;


/* "pymusic.pyx":252
 *         self.events.add(eh)
 * 
 * cdef class EventOutputPort(Port):             # <<<<<<<<<<<<<<
 *     """
 *     Map events from this sink. See EventInputPort for description of
 */

struct __pyx_vtabstruct_7pymusic_EventOutputPort {
  struct __pyx_vtabstruct_7pymusic_Port __pyx_base;
};
static struct __pyx_vtabstruct_7pymusic_EventOutputPort *__pyx_vtabptr_7pymusic_EventOutputPort;


/* "pymusic.pyx":277
 *         insertEventImpl(ptr, time, index)
 * 
 * cdef class MessageInputPort(Port):             # <<<<<<<<<<<<<<
 *     """
 *     Maps 'events' to handlers.
 */

struct __pyx_vtabstruct_7pymusic_MessageInputPort {
  struct __pyx_vtabstruct_7pymusic_Port __pyx_base;
};
static struct __pyx_vtabstruct_7pymusic_MessageInputPort *__pyx_vtabptr_7pymusic_MessageInputPort;


/* "pymusic.pyx":313
 *         self.events.add(eh)
 * 
 * cdef class MessageOutputPort(Port):             # <<<<<<<<<<<<<<
 *     """
 *     The source of "messages". A message is a python object that is
 */

struct __pyx_vtabstruct_7pymusic_MessageOutputPort {
  struct __pyx_vtabstruct_7pymusic_Port __pyx_base;
};
static struct __pyx_vtabstruct_7pymusic_MessageOutputPort *__pyx_vtabptr_7pymusic_MessageOutputPort;
#ifndef CYTHON_REFNANNY
  #define CYTHON_REFNANNY 0
#endif
#if CYTHON_REFNANNY
  typedef struct {
    void (*INCREF)(void*, PyObject*, int);
    void (*DECREF)(void*, PyObject*, int);
    void (*GOTREF)(void*, PyObject*, int);
    void (*GIVEREF)(void*, PyObject*, int);
    void* (*SetupContext)(const char*, int, const char*);
    void (*FinishContext)(void**);
  } __Pyx_RefNannyAPIStruct;
  static __Pyx_RefNannyAPIStruct *__Pyx_RefNanny = NULL;
  static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname);
  #define __Pyx_RefNannyDeclarations void *__pyx_refnanny = NULL;
#ifdef WITH_THREAD
  #define __Pyx_RefNannySetupContext(name, acquire_gil) \
          if (acquire_gil) { \
              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure(); \
              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__); \
              PyGILState_Release(__pyx_gilstate_save); \
          } else { \
              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__); \
          }
#else
  #define __Pyx_RefNannySetupContext(name, acquire_gil) \
          __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__)
#endif
  #define __Pyx_RefNannyFinishContext() \
          __Pyx_RefNanny->FinishContext(&__pyx_refnanny)
  #define __Pyx_INCREF(r)  __Pyx_RefNanny->INCREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_DECREF(r)  __Pyx_RefNanny->DECREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_GOTREF(r)  __Pyx_RefNanny->GOTREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_GIVEREF(r) __Pyx_RefNanny->GIVEREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_XINCREF(r)  do { if((r) != NULL) {__Pyx_INCREF(r); }} while(0)
  #define __Pyx_XDECREF(r)  do { if((r) != NULL) {__Pyx_DECREF(r); }} while(0)
  #define __Pyx_XGOTREF(r)  do { if((r) != NULL) {__Pyx_GOTREF(r); }} while(0)
  #define __Pyx_XGIVEREF(r) do { if((r) != NULL) {__Pyx_GIVEREF(r);}} while(0)
#else
  #define __Pyx_RefNannyDeclarations
  #define __Pyx_RefNannySetupContext(name, acquire_gil)
  #define __Pyx_RefNannyFinishContext()
  #define __Pyx_INCREF(r) Py_INCREF(r)
  #define __Pyx_DECREF(r) Py_DECREF(r)
  #define __Pyx_GOTREF(r)
  #define __Pyx_GIVEREF(r)
  #define __Pyx_XINCREF(r) Py_XINCREF(r)
  #define __Pyx_XDECREF(r) Py_XDECREF(r)
  #define __Pyx_XGOTREF(r)
  #define __Pyx_XGIVEREF(r)
#endif
#define __Pyx_XDECREF_SET(r, v) do {                            \
        PyObject *tmp = (PyObject *) r;                         \
        r = v; __Pyx_XDECREF(tmp);                              \
    } while (0)
#define __Pyx_DECREF_SET(r, v) do {                             \
        PyObject *tmp = (PyObject *) r;                         \
        r = v; __Pyx_DECREF(tmp);                               \
    } while (0)
#define __Pyx_CLEAR(r)    do { PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);} while(0)
#define __Pyx_XCLEAR(r)   do { if((r) != NULL) {PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);}} while(0)

#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name) {
    PyTypeObject* tp = Py_TYPE(obj);
    if (likely(tp->tp_getattro))
        return tp->tp_getattro(obj, attr_name);
#if PY_MAJOR_VERSION < 3
    if (likely(tp->tp_getattr))
        return tp->tp_getattr(obj, PyString_AS_STRING(attr_name));
#endif
    return PyObject_GetAttr(obj, attr_name);
}
#else
#define __Pyx_PyObject_GetAttrStr(o,n) PyObject_GetAttr(o,n)
#endif

static PyObject *__Pyx_GetBuiltinName(PyObject *name);

static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name);

#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw);
#else
#define __Pyx_PyObject_Call(func, arg, kw) PyObject_Call(func, arg, kw)
#endif

static void __Pyx_RaiseArgtupleInvalid(const char* func_name, int exact,
    Py_ssize_t num_min, Py_ssize_t num_max, Py_ssize_t num_found);

static void __Pyx_RaiseDoubleKeywordsError(const char* func_name, PyObject* kw_name);

static int __Pyx_ParseOptionalKeywords(PyObject *kwds, PyObject **argnames[], \
    PyObject *kwds2, PyObject *values[], Py_ssize_t num_pos_args, \
    const char* function_name);

#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg);
#endif

static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg);

static CYTHON_INLINE void __Pyx_ErrRestore(PyObject *type, PyObject *value, PyObject *tb);
static CYTHON_INLINE void __Pyx_ErrFetch(PyObject **type, PyObject **value, PyObject **tb);

static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause);

#define __Pyx_GetItemInt(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck) \
    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ? \
    __Pyx_GetItemInt_Fast(o, (Py_ssize_t)i, is_list, wraparound, boundscheck) : \
    (is_list ? (PyErr_SetString(PyExc_IndexError, "list index out of range"), (PyObject*)NULL) : \
               __Pyx_GetItemInt_Generic(o, to_py_func(i))))
#define __Pyx_GetItemInt_List(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck) \
    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ? \
    __Pyx_GetItemInt_List_Fast(o, (Py_ssize_t)i, wraparound, boundscheck) : \
    (PyErr_SetString(PyExc_IndexError, "list index out of range"), (PyObject*)NULL))
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
                                                              int wraparound, int boundscheck);
#define __Pyx_GetItemInt_Tuple(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck) \
    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ? \
    __Pyx_GetItemInt_Tuple_Fast(o, (Py_ssize_t)i, wraparound, boundscheck) : \
    (PyErr_SetString(PyExc_IndexError, "tuple index out of range"), (PyObject*)NULL))
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
                                                              int wraparound, int boundscheck);
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j);
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i,
                                                     int is_list, int wraparound, int boundscheck);

#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallNoArg(PyObject *func);
#else
#define __Pyx_PyObject_CallNoArg(func) __Pyx_PyObject_Call(func, __pyx_empty_tuple, NULL)
#endif

static CYTHON_INLINE void __Pyx_ExceptionSave(PyObject **type, PyObject **value, PyObject **tb);
static void __Pyx_ExceptionReset(PyObject *type, PyObject *value, PyObject *tb);

static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb);

static void __Pyx_WriteUnraisable(const char *name, int clineno,
                                  int lineno, const char *filename,
                                  int full_traceback);

static CYTHON_INLINE int __Pyx_ArgTypeTest(PyObject *obj, PyTypeObject *type, int none_allowed,
    const char *name, int exact);

static CYTHON_INLINE int __Pyx_CheckKeywordStrings(PyObject *kwdict, const char* function_name, int kw_allowed);

#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE int __Pyx_ListComp_Append(PyObject* list, PyObject* x) {
    PyListObject* L = (PyListObject*) list;
    Py_ssize_t len = Py_SIZE(list);
    if (likely(L->allocated > len)) {
        Py_INCREF(x);
        PyList_SET_ITEM(list, len, x);
        Py_SIZE(list) = len+1;
        return 0;
    }
    return PyList_Append(list, x);
}
#else
#define __Pyx_ListComp_Append(L,x) PyList_Append(L,x)
#endif

static CYTHON_INLINE void __Pyx_ExceptionSwap(PyObject **type, PyObject **value, PyObject **tb);

#if CYTHON_COMPILING_IN_CPYTHON
#define __Pyx_PyObject_DelAttrStr(o,n) __Pyx_PyObject_SetAttrStr(o,n,NULL)
static CYTHON_INLINE int __Pyx_PyObject_SetAttrStr(PyObject* obj, PyObject* attr_name, PyObject* value) {
    PyTypeObject* tp = Py_TYPE(obj);
    if (likely(tp->tp_setattro))
        return tp->tp_setattro(obj, attr_name, value);
#if PY_MAJOR_VERSION < 3
    if (likely(tp->tp_setattr))
        return tp->tp_setattr(obj, PyString_AS_STRING(attr_name), value);
#endif
    return PyObject_SetAttr(obj, attr_name, value);
}
#else
#define __Pyx_PyObject_DelAttrStr(o,n)   PyObject_DelAttr(o,n)
#define __Pyx_PyObject_SetAttrStr(o,n,v) PyObject_SetAttr(o,n,v)
#endif

static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type);

static double __Pyx__PyObject_AsDouble(PyObject* obj);
#if CYTHON_COMPILING_IN_PYPY
#define __Pyx_PyObject_AsDouble(obj) \
(likely(PyFloat_CheckExact(obj)) ? PyFloat_AS_DOUBLE(obj) : \
 likely(PyInt_CheckExact(obj)) ? \
 PyFloat_AsDouble(obj) : __Pyx__PyObject_AsDouble(obj))
#else
#define __Pyx_PyObject_AsDouble(obj) \
((likely(PyFloat_CheckExact(obj))) ? \
 PyFloat_AS_DOUBLE(obj) : __Pyx__PyObject_AsDouble(obj))
#endif

#if PY_MAJOR_VERSION >= 3
static PyObject *__Pyx_PyDict_GetItem(PyObject *d, PyObject* key) {
    PyObject *value;
    value = PyDict_GetItemWithError(d, key);
    if (unlikely(!value)) {
        if (!PyErr_Occurred()) {
            PyObject* args = PyTuple_Pack(1, key);
            if (likely(args))
                PyErr_SetObject(PyExc_KeyError, args);
            Py_XDECREF(args);
        }
        return NULL;
    }
    Py_INCREF(value);
    return value;
}
#else
    #define __Pyx_PyDict_GetItem(d, key) PyObject_GetItem(d, key)
#endif

static int __Pyx_call_next_tp_traverse(PyObject* obj, visitproc v, void *a, traverseproc current_tp_traverse);

static void __Pyx_call_next_tp_clear(PyObject* obj, inquiry current_tp_dealloc);

#include <string.h>

static int __Pyx_SetVtable(PyObject *dict, void *vtable);

static PyObject *__Pyx_CalculateMetaclass(PyTypeObject *metaclass, PyObject *bases);

static PyObject *__Pyx_Py3MetaclassPrepare(PyObject *metaclass, PyObject *bases, PyObject *name, PyObject *qualname,
                                           PyObject *mkw, PyObject *modname, PyObject *doc);
static PyObject *__Pyx_Py3ClassCreate(PyObject *metaclass, PyObject *name, PyObject *bases, PyObject *dict,
                                      PyObject *mkw, int calculate_metaclass, int allow_py2_metaclass);

static PyTypeObject* __Pyx_FetchCommonType(PyTypeObject* type);

#define __Pyx_CyFunction_USED 1
#include <structmember.h>
#define __Pyx_CYFUNCTION_STATICMETHOD  0x01
#define __Pyx_CYFUNCTION_CLASSMETHOD   0x02
#define __Pyx_CYFUNCTION_CCLASS        0x04
#define __Pyx_CyFunction_GetClosure(f) \
    (((__pyx_CyFunctionObject *) (f))->func_closure)
#define __Pyx_CyFunction_GetClassObj(f) \
    (((__pyx_CyFunctionObject *) (f))->func_classobj)
#define __Pyx_CyFunction_Defaults(type, f) \
    ((type *)(((__pyx_CyFunctionObject *) (f))->defaults))
#define __Pyx_CyFunction_SetDefaultsGetter(f, g) \
    ((__pyx_CyFunctionObject *) (f))->defaults_getter = (g)
typedef struct {
    PyCFunctionObject func;
#if PY_VERSION_HEX < 0x030500A0
    PyObject *func_weakreflist;
#endif
    PyObject *func_dict;
    PyObject *func_name;
    PyObject *func_qualname;
    PyObject *func_doc;
    PyObject *func_globals;
    PyObject *func_code;
    PyObject *func_closure;
    PyObject *func_classobj;
    void *defaults;
    int defaults_pyobjects;
    int flags;
    PyObject *defaults_tuple;
    PyObject *defaults_kwdict;
    PyObject *(*defaults_getter)(PyObject *);
    PyObject *func_annotations;
} __pyx_CyFunctionObject;
static PyTypeObject *__pyx_CyFunctionType = 0;
#define __Pyx_CyFunction_NewEx(ml, flags, qualname, self, module, globals, code) \
    __Pyx_CyFunction_New(__pyx_CyFunctionType, ml, flags, qualname, self, module, globals, code)
static PyObject *__Pyx_CyFunction_New(PyTypeObject *, PyMethodDef *ml,
                                      int flags, PyObject* qualname,
                                      PyObject *self,
                                      PyObject *module, PyObject *globals,
                                      PyObject* code);
static CYTHON_INLINE void *__Pyx_CyFunction_InitDefaults(PyObject *m,
                                                         size_t size,
                                                         int pyobjects);
static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsTuple(PyObject *m,
                                                            PyObject *tuple);
static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsKwDict(PyObject *m,
                                                             PyObject *dict);
static CYTHON_INLINE void __Pyx_CyFunction_SetAnnotationsDict(PyObject *m,
                                                              PyObject *dict);
static int __Pyx_CyFunction_init(void);

static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name);

typedef struct {
    int code_line;
    PyCodeObject* code_object;
} __Pyx_CodeObjectCacheEntry;
struct __Pyx_CodeObjectCache {
    int count;
    int max_count;
    __Pyx_CodeObjectCacheEntry* entries;
};
static struct __Pyx_CodeObjectCache __pyx_code_cache = {0,0,NULL};
static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line);
static PyCodeObject *__pyx_find_code_object(int code_line);
static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object);

static void __Pyx_AddTraceback(const char *funcname, int c_line,
                               int py_line, const char *filename);

#ifndef _ARRAYARRAY_H
#define _ARRAYARRAY_H
typedef struct arraydescr {
    int typecode;
    int itemsize;
    PyObject * (*getitem)(struct arrayobject *, Py_ssize_t);
    int (*setitem)(struct arrayobject *, Py_ssize_t, PyObject *);
#if PY_MAJOR_VERSION >= 3
    char *formats;
#endif
} arraydescr;
struct arrayobject {
    PyObject_HEAD
    Py_ssize_t ob_size;
    union {
        char *ob_item;
        float *as_floats;
        double *as_doubles;
        int *as_ints;
        unsigned int *as_uints;
        unsigned char *as_uchars;
        signed char *as_schars;
        char *as_chars;
        unsigned long *as_ulongs;
        long *as_longs;
        short *as_shorts;
        unsigned short *as_ushorts;
        Py_UNICODE *as_pyunicodes;
        void *as_voidptr;
    } data;
    Py_ssize_t allocated;
    struct arraydescr *ob_descr;
    PyObject *weakreflist;
#if PY_MAJOR_VERSION >= 3
        int ob_exports;
#endif
};
#ifndef NO_NEWARRAY_INLINE
static CYTHON_INLINE PyObject * newarrayobject(PyTypeObject *type, Py_ssize_t size,
    struct arraydescr *descr) {
    arrayobject *op;
    size_t nbytes;
    if (size < 0) {
        PyErr_BadInternalCall();
        return NULL;
    }
    nbytes = size * descr->itemsize;
    if (nbytes / descr->itemsize != (size_t)size) {
        return PyErr_NoMemory();
    }
    op = (arrayobject *) type->tp_alloc(type, 0);
    if (op == NULL) {
        return NULL;
    }
    op->ob_descr = descr;
    op->allocated = size;
    op->weakreflist = NULL;
    op->ob_size = size;
    if (size <= 0) {
        op->data.ob_item = NULL;
    }
    else {
        op->data.ob_item = PyMem_NEW(char, nbytes);
        if (op->data.ob_item == NULL) {
            Py_DECREF(op);
            return PyErr_NoMemory();
        }
    }
    return (PyObject *) op;
}
#else
PyObject* newarrayobject(PyTypeObject *type, Py_ssize_t size,
    struct arraydescr *descr);
#endif
static CYTHON_INLINE int resize(arrayobject *self, Py_ssize_t n) {
    void *items = (void*) self->data.ob_item;
    PyMem_Resize(items, char, (size_t)(n * self->ob_descr->itemsize));
    if (items == NULL) {
        PyErr_NoMemory();
        return -1;
    }
    self->data.ob_item = (char*) items;
    self->ob_size = n;
    self->allocated = n;
    return 0;
}
static CYTHON_INLINE int resize_smart(arrayobject *self, Py_ssize_t n) {
    void *items = (void*) self->data.ob_item;
    Py_ssize_t newsize;
    if (n < self->allocated) {
        if (n*4 > self->allocated) {
            self->ob_size = n;
            return 0;
        }
    }
    newsize = n  * 3 / 2 + 1;
    PyMem_Resize(items, char, (size_t)(newsize * self->ob_descr->itemsize));
    if (items == NULL) {
        PyErr_NoMemory();
        return -1;
    }
    self->data.ob_item = (char*) items;
    self->ob_size = n;
    self->allocated = newsize;
    return 0;
}
#endif

static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value);

static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level);

static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *);

static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *);

static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value);

#ifndef __Pyx_CppExn2PyErr
#include <new>
#include <typeinfo>
#include <stdexcept>
#include <ios>
static void __Pyx_CppExn2PyErr() {
  try {
    if (PyErr_Occurred())
      ; // let the latest Python exn pass through and ignore the current one
    else
      throw;
  } catch (const std::bad_alloc& exn) {
    PyErr_SetString(PyExc_MemoryError, exn.what());
  } catch (const std::bad_cast& exn) {
    PyErr_SetString(PyExc_TypeError, exn.what());
  } catch (const std::domain_error& exn) {
    PyErr_SetString(PyExc_ValueError, exn.what());
  } catch (const std::invalid_argument& exn) {
    PyErr_SetString(PyExc_ValueError, exn.what());
  } catch (const std::ios_base::failure& exn) {
    PyErr_SetString(PyExc_IOError, exn.what());
  } catch (const std::out_of_range& exn) {
    PyErr_SetString(PyExc_IndexError, exn.what());
  } catch (const std::overflow_error& exn) {
    PyErr_SetString(PyExc_OverflowError, exn.what());
  } catch (const std::range_error& exn) {
    PyErr_SetString(PyExc_ArithmeticError, exn.what());
  } catch (const std::underflow_error& exn) {
    PyErr_SetString(PyExc_ArithmeticError, exn.what());
  } catch (const std::exception& exn) {
    PyErr_SetString(PyExc_RuntimeError, exn.what());
  }
  catch (...)
  {
    PyErr_SetString(PyExc_RuntimeError, "Unknown exception");
  }
}
#endif

static PyObject* __Pyx_PyObject_CallMethod1(PyObject* obj, PyObject* method_name, PyObject* arg);

#define __Pyx_Generator_USED
#include <structmember.h>
#include <frameobject.h>
typedef PyObject *(*__pyx_generator_body_t)(PyObject *, PyObject *);
typedef struct {
    PyObject_HEAD
    __pyx_generator_body_t body;
    PyObject *closure;
    PyObject *exc_type;
    PyObject *exc_value;
    PyObject *exc_traceback;
    PyObject *gi_weakreflist;
    PyObject *classobj;
    PyObject *yieldfrom;
    PyObject *gi_name;
    PyObject *gi_qualname;
    int resume_label;
    char is_running;
} __pyx_GeneratorObject;
static __pyx_GeneratorObject *__Pyx_Generator_New(__pyx_generator_body_t body,
                                                  PyObject *closure, PyObject *name, PyObject *qualname);
static int __pyx_Generator_init(void);
static int __Pyx_Generator_clear(PyObject* self);
#if 1 || PY_VERSION_HEX < 0x030300B0
static int __Pyx_PyGen_FetchStopIterationValue(PyObject **pvalue);
#else
#define __Pyx_PyGen_FetchStopIterationValue(pvalue) PyGen_FetchStopIterationValue(pvalue)
#endif

static int __Pyx_check_binary_version(void);

static int __Pyx_ExportFunction(const char *name, void (*f)(void), const char *sig);

#if !defined(__Pyx_PyIdentifier_FromString)
#if PY_MAJOR_VERSION < 3
  #define __Pyx_PyIdentifier_FromString(s) PyString_FromString(s)
#else
  #define __Pyx_PyIdentifier_FromString(s) PyUnicode_FromString(s)
#endif
#endif

static PyObject *__Pyx_ImportModule(const char *name);

static PyTypeObject *__Pyx_ImportType(const char *module_name, const char *class_name, size_t size, int strict);

static int __Pyx_InitStrings(__Pyx_StringTabEntry *t);

static PyObject *__pyx_f_7pymusic_4Port_null(struct __pyx_obj_7pymusic_Port *__pyx_v_self, int __pyx_skip_dispatch); /* proto*/
static PyObject *__pyx_f_7pymusic_14EventInputPort_null(struct __pyx_obj_7pymusic_EventInputPort *__pyx_v_self, int __pyx_skip_dispatch); /* proto*/
static PyObject *__pyx_f_7pymusic_16MessageInputPort_null(struct __pyx_obj_7pymusic_MessageInputPort *__pyx_v_self, int __pyx_skip_dispatch); /* proto*/
static struct PyMPIIntracommObject *__pyx_f_7pymusic_5Setup_getcomm(struct __pyx_obj_7pymusic_Setup *__pyx_v_self, int __pyx_skip_dispatch); /* proto*/
static PyObject *__pyx_f_7pymusic_5Setup_null(struct __pyx_obj_7pymusic_Setup *__pyx_v_self); /* proto*/

/* Module declarations from 'mpi4py.MPI' */
static PyTypeObject *__pyx_ptype_6mpi4py_3MPI_Status = 0;
static PyTypeObject *__pyx_ptype_6mpi4py_3MPI_Datatype = 0;
static PyTypeObject *__pyx_ptype_6mpi4py_3MPI_Request = 0;
static PyTypeObject *__pyx_ptype_6mpi4py_3MPI_Prequest = 0;
static PyTypeObject *__pyx_ptype_6mpi4py_3MPI_Grequest = 0;
static PyTypeObject *__pyx_ptype_6mpi4py_3MPI_Op = 0;
static PyTypeObject *__pyx_ptype_6mpi4py_3MPI_Group = 0;
static PyTypeObject *__pyx_ptype_6mpi4py_3MPI_Info = 0;
static PyTypeObject *__pyx_ptype_6mpi4py_3MPI_Errhandler = 0;
static PyTypeObject *__pyx_ptype_6mpi4py_3MPI_Comm = 0;
static PyTypeObject *__pyx_ptype_6mpi4py_3MPI_Intracomm = 0;
static PyTypeObject *__pyx_ptype_6mpi4py_3MPI_Cartcomm = 0;
static PyTypeObject *__pyx_ptype_6mpi4py_3MPI_Graphcomm = 0;
static PyTypeObject *__pyx_ptype_6mpi4py_3MPI_Distgraphcomm = 0;
static PyTypeObject *__pyx_ptype_6mpi4py_3MPI_Intercomm = 0;
static PyTypeObject *__pyx_ptype_6mpi4py_3MPI_Win = 0;
static PyTypeObject *__pyx_ptype_6mpi4py_3MPI_File = 0;

/* Module declarations from 'mpi4py.mpi_c' */

/* Module declarations from 'libcpp' */

/* Module declarations from 'libc.string' */

/* Module declarations from 'libcpp.string' */

/* Module declarations from 'cpython.ref' */

/* Module declarations from 'music.pybuffer' */
static PyTypeObject *__pyx_ptype_5music_8pybuffer_Buffer = 0;

/* Module declarations from 'libc.stdlib' */

/* Module declarations from 'cpython.version' */

/* Module declarations from 'cpython.exc' */

/* Module declarations from 'cpython.module' */

/* Module declarations from 'cpython.mem' */

/* Module declarations from 'cpython.tuple' */

/* Module declarations from 'cpython.list' */

/* Module declarations from 'libc.stdio' */

/* Module declarations from 'cpython.object' */

/* Module declarations from 'cpython.sequence' */

/* Module declarations from 'cpython.mapping' */

/* Module declarations from 'cpython.iterator' */

/* Module declarations from '__builtin__' */

/* Module declarations from 'cpython.type' */
static PyTypeObject *__pyx_ptype_7cpython_4type_type = 0;

/* Module declarations from 'cpython.number' */

/* Module declarations from 'cpython.int' */

/* Module declarations from '__builtin__' */

/* Module declarations from 'cpython.bool' */
static PyTypeObject *__pyx_ptype_7cpython_4bool_bool = 0;

/* Module declarations from 'cpython.long' */

/* Module declarations from 'cpython.float' */

/* Module declarations from '__builtin__' */

/* Module declarations from 'cpython.complex' */
static PyTypeObject *__pyx_ptype_7cpython_7complex_complex = 0;

/* Module declarations from 'cpython.string' */

/* Module declarations from 'cpython.unicode' */

/* Module declarations from 'cpython.dict' */

/* Module declarations from 'cpython.instance' */

/* Module declarations from 'cpython.function' */

/* Module declarations from 'cpython.method' */

/* Module declarations from 'cpython.weakref' */

/* Module declarations from 'cpython.getargs' */

/* Module declarations from 'cpython.pythread' */

/* Module declarations from 'cpython.pystate' */

/* Module declarations from 'cpython.cobject' */

/* Module declarations from 'cpython.oldbuffer' */

/* Module declarations from 'cpython.set' */

/* Module declarations from 'cpython.buffer' */

/* Module declarations from 'cpython.bytes' */

/* Module declarations from 'cpython.pycapsule' */

/* Module declarations from 'cpython' */

/* Module declarations from 'array' */

/* Module declarations from 'cpython.array' */
static PyTypeObject *__pyx_ptype_7cpython_5array_array = 0;
static CYTHON_INLINE int __pyx_f_7cpython_5array_extend_buffer(arrayobject *, char *, Py_ssize_t); /*proto*/

/* Module declarations from 'pymusic' */
static PyTypeObject *__pyx_ptype_7pymusic_Setup = 0;
static PyTypeObject *__pyx_ptype_7pymusic_Runtime = 0;
static PyTypeObject *__pyx_ptype_7pymusic_Port = 0;
static PyTypeObject *__pyx_ptype_7pymusic_ContInputPort = 0;
static PyTypeObject *__pyx_ptype_7pymusic_ContOutputPort = 0;
static PyTypeObject *__pyx_ptype_7pymusic_EventInputPort = 0;
static PyTypeObject *__pyx_ptype_7pymusic_EventOutputPort = 0;
static PyTypeObject *__pyx_ptype_7pymusic_MessageInputPort = 0;
static PyTypeObject *__pyx_ptype_7pymusic_MessageOutputPort = 0;
static PyTypeObject *__pyx_ptype_7pymusic_DataMap = 0;
static PyTypeObject *__pyx_ptype_7pymusic_IndexMap = 0;
static PyTypeObject *__pyx_ptype_7pymusic_EventHandler = 0;
static PyTypeObject *__pyx_ptype_7pymusic_MessageHandler = 0;
static PyTypeObject *__pyx_ptype_7pymusic__Index = 0;
static PyTypeObject *__pyx_ptype_7pymusic___pyx_scope_struct____iter__ = 0;
static __pyx_t_7pymusic_Args __pyx_f_7pymusic_argv_toc(PyObject *); /*proto*/
static std::string __pyx_convert_string_from_py_std__string(PyObject *); /*proto*/
static CYTHON_INLINE PyObject *__pyx_convert_PyObject_string_to_py_std__string(std::string const &); /*proto*/
static CYTHON_INLINE PyObject *__pyx_convert_PyUnicode_string_to_py_std__string(std::string const &); /*proto*/
static CYTHON_INLINE PyObject *__pyx_convert_PyBytes_string_to_py_std__string(std::string const &); /*proto*/
static CYTHON_INLINE PyObject *__pyx_convert_PyByteArray_string_to_py_std__string(std::string const &); /*proto*/
#define __Pyx_MODULE_NAME "pymusic"
int __pyx_module_is_main_pymusic = 0;

/* Implementation of 'pymusic' */
static PyObject *__pyx_builtin_Exception;
static PyObject *__pyx_builtin_range;
static PyObject *__pyx_builtin_xrange;
static PyObject *__pyx_builtin_ValueError;
static PyObject *__pyx_builtin_MemoryError;
static PyObject *__pyx_pf_7pymusic_7NoWidth___init__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_7pymusic_15UndefinedConfig___init__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_var); /* proto */
static PyObject *__pyx_pf_7pymusic_predictRank(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_argv); /* proto */
static int __pyx_pf_7pymusic_4Port___cinit__(struct __pyx_obj_7pymusic_Port *__pyx_v_self); /* proto */
static Py_hash_t __pyx_pf_7pymusic_4Port_2__hash__(struct __pyx_obj_7pymusic_Port *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_7pymusic_4Port_4null(struct __pyx_obj_7pymusic_Port *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_7pymusic_4Port_6isConnected(struct __pyx_obj_7pymusic_Port *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_7pymusic_4Port_8width(struct __pyx_obj_7pymusic_Port *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_7pymusic_13ContInputPort_map(struct __pyx_obj_7pymusic_ContInputPort *__pyx_v_self, PyObject *__pyx_v_data, int __pyx_v_base, PyObject *__pyx_v_perm, double __pyx_v_delay, bool __pyx_v_interpolate, int __pyx_v_maxBuffered); /* proto */
static PyObject *__pyx_pf_7pymusic_14ContOutputPort_map(struct __pyx_obj_7pymusic_ContOutputPort *__pyx_v_self, PyObject *__pyx_v_data, int __pyx_v_base, PyObject *__pyx_v_perm, int __pyx_v_maxBuffered); /* proto */
static int __pyx_pf_7pymusic_14EventInputPort___cinit__(struct __pyx_obj_7pymusic_EventInputPort *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_7pymusic_14EventInputPort_2null(struct __pyx_obj_7pymusic_EventInputPort *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_7pymusic_14EventInputPort_4map(struct __pyx_obj_7pymusic_EventInputPort *__pyx_v_self, PyObject *__pyx_v_func, MUSIC::Index::Type __pyx_v_t, double __pyx_v_accLatency, int __pyx_v_maxBuffered, PyObject *__pyx_v_perm, int __pyx_v_base, int __pyx_v_size); /* proto */
static PyObject *__pyx_pf_7pymusic_15EventOutputPort_map(struct __pyx_obj_7pymusic_EventOutputPort *__pyx_v_self, MUSIC::Index::Type __pyx_v_t, int __pyx_v_maxBuffered, PyObject *__pyx_v_perm, int __pyx_v_base, int __pyx_v_size); /* proto */
static PyObject *__pyx_pf_7pymusic_15EventOutputPort_2insertEvent(struct __pyx_obj_7pymusic_EventOutputPort *__pyx_v_self, double __pyx_v_time, int __pyx_v_index, CYTHON_UNUSED MUSIC::Index::Type __pyx_v_t); /* proto */
static int __pyx_pf_7pymusic_16MessageInputPort___cinit__(struct __pyx_obj_7pymusic_MessageInputPort *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_7pymusic_16MessageInputPort_2null(struct __pyx_obj_7pymusic_MessageInputPort *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_7pymusic_16MessageInputPort_4map(struct __pyx_obj_7pymusic_MessageInputPort *__pyx_v_self, PyObject *__pyx_v_func, double __pyx_v_accLatency, int __pyx_v_maxBuffered, int __pyx_v_pickled); /* proto */
static PyObject *__pyx_pf_7pymusic_17MessageOutputPort_map(struct __pyx_obj_7pymusic_MessageOutputPort *__pyx_v_self, int __pyx_v_maxBuffered, int __pyx_v_pickled); /* proto */
static PyObject *__pyx_pf_7pymusic_17MessageOutputPort_2insertMessage(struct __pyx_obj_7pymusic_MessageOutputPort *__pyx_v_self, double __pyx_v_time, PyObject *__pyx_v_msg); /* proto */
static int __pyx_pf_7pymusic_5Setup___cinit__(struct __pyx_obj_7pymusic_Setup *__pyx_v_self, PyObject *__pyx_v_argv, PyObject *__pyx_v_required); /* proto */
static void __pyx_pf_7pymusic_5Setup_2__dealloc__(struct __pyx_obj_7pymusic_Setup *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_7pymusic_5Setup_4getcomm(struct __pyx_obj_7pymusic_Setup *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_7pymusic_5Setup_6config(struct __pyx_obj_7pymusic_Setup *__pyx_v_self, std::string __pyx_v_var); /* proto */
static PyObject *__pyx_pf_7pymusic_5Setup_8publishContInput(struct __pyx_obj_7pymusic_Setup *__pyx_v_self, std::string __pyx_v_s); /* proto */
static PyObject *__pyx_pf_7pymusic_5Setup_10publishContOutput(struct __pyx_obj_7pymusic_Setup *__pyx_v_self, std::string __pyx_v_s); /* proto */
static PyObject *__pyx_pf_7pymusic_5Setup_12publishEventOutput(struct __pyx_obj_7pymusic_Setup *__pyx_v_self, std::string __pyx_v_s); /* proto */
static PyObject *__pyx_pf_7pymusic_5Setup_14publishEventInput(struct __pyx_obj_7pymusic_Setup *__pyx_v_self, std::string __pyx_v_s); /* proto */
static PyObject *__pyx_pf_7pymusic_5Setup_16publishMessageOutput(struct __pyx_obj_7pymusic_Setup *__pyx_v_self, std::string __pyx_v_s); /* proto */
static PyObject *__pyx_pf_7pymusic_5Setup_18publishMessageInput(struct __pyx_obj_7pymusic_Setup *__pyx_v_self, std::string __pyx_v_s); /* proto */
static PyObject *__pyx_pf_7pymusic_5Setup_20runtime(struct __pyx_obj_7pymusic_Setup *__pyx_v_self, double __pyx_v_timestep); /* proto */
static PyObject *__pyx_pf_7pymusic_5Setup_4comm___get__(struct __pyx_obj_7pymusic_Setup *__pyx_v_self); /* proto */
static int __pyx_pf_7pymusic_7Runtime___cinit__(struct __pyx_obj_7pymusic_Runtime *__pyx_v_self, struct __pyx_obj_7pymusic_Setup *__pyx_v_setup, double __pyx_v_h); /* proto */
static void __pyx_pf_7pymusic_7Runtime_2__dealloc__(struct __pyx_obj_7pymusic_Runtime *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_7pymusic_7Runtime_4time(struct __pyx_obj_7pymusic_Runtime *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_7pymusic_7Runtime_6tick(struct __pyx_obj_7pymusic_Runtime *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_7pymusic_7Runtime_8__iter__(struct __pyx_obj_7pymusic_Runtime *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_7pymusic_7Runtime_4comm___get__(struct __pyx_obj_7pymusic_Runtime *__pyx_v_self); /* proto */
static int __pyx_pf_7pymusic_8IndexMap___cinit__(struct __pyx_obj_7pymusic_IndexMap *__pyx_v_self, PyObject *__pyx_v_perm, int __pyx_v_base, int __pyx_v_size); /* proto */
static void __pyx_pf_7pymusic_8IndexMap_2__dealloc__(struct __pyx_obj_7pymusic_IndexMap *__pyx_v_self); /* proto */
static int __pyx_pf_7pymusic_7DataMap___cinit__(struct __pyx_obj_7pymusic_DataMap *__pyx_v_self, struct __pyx_obj_5music_8pybuffer_Buffer *__pyx_v_buf, struct __pyx_obj_7pymusic_IndexMap *__pyx_v_index_map, int __pyx_v_index); /* proto */
static void __pyx_pf_7pymusic_7DataMap_2__dealloc__(struct __pyx_obj_7pymusic_DataMap *__pyx_v_self); /* proto */
static int __pyx_pf_7pymusic_12EventHandler___cinit__(struct __pyx_obj_7pymusic_EventHandler *__pyx_v_self, PyObject *__pyx_v_func, MUSIC::Index::Type __pyx_v_t); /* proto */
static void __pyx_pf_7pymusic_12EventHandler_2__dealloc__(struct __pyx_obj_7pymusic_EventHandler *__pyx_v_self); /* proto */
static int __pyx_pf_7pymusic_6_Index___cinit__(struct __pyx_obj_7pymusic__Index *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_7pymusic_6_Index_2tostr(struct __pyx_obj_7pymusic__Index *__pyx_v_self, int __pyx_v_index); /* proto */
static PyObject *__pyx_pf_7pymusic_6_Index_6GLOBAL___get__(struct __pyx_obj_7pymusic__Index *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_7pymusic_6_Index_5LOCAL___get__(struct __pyx_obj_7pymusic__Index *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_7pymusic_6_Index_7backmap___get__(struct __pyx_obj_7pymusic__Index *__pyx_v_self); /* proto */
static int __pyx_pf_7pymusic_14MessageHandler___cinit__(struct __pyx_obj_7pymusic_MessageHandler *__pyx_v_self, PyObject *__pyx_v_func, int __pyx_v_pickled); /* proto */
static void __pyx_pf_7pymusic_14MessageHandler_2__dealloc__(struct __pyx_obj_7pymusic_MessageHandler *__pyx_v_self); /* proto */
static int __pyx_pf_7cpython_5array_5array___getbuffer__(arrayobject *__pyx_v_self, Py_buffer *__pyx_v_info, CYTHON_UNUSED int __pyx_v_flags); /* proto */
static void __pyx_pf_7cpython_5array_5array_2__releasebuffer__(CYTHON_UNUSED arrayobject *__pyx_v_self, Py_buffer *__pyx_v_info); /* proto */
static PyObject *__pyx_tp_new_7pymusic_Setup(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_7pymusic_Runtime(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_7pymusic_Port(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_7pymusic_ContInputPort(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_7pymusic_ContOutputPort(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_7pymusic_EventInputPort(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_7pymusic_EventOutputPort(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_7pymusic_MessageInputPort(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_7pymusic_MessageOutputPort(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_7pymusic_DataMap(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_7pymusic_IndexMap(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_7pymusic_EventHandler(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_7pymusic_MessageHandler(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_7pymusic__Index(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_7pymusic___pyx_scope_struct____iter__(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static char __pyx_k_h[] = "h";
static char __pyx_k_i[] = "i";
static char __pyx_k_r[] = "r";
static char __pyx_k_t[] = "t";
static char __pyx_k__3[] = "*";
static char __pyx_k_MPI[] = "MPI";
static char __pyx_k_buf[] = "buf";
static char __pyx_k_doc[] = "__doc__";
static char __pyx_k_msg[] = "msg";
static char __pyx_k_ptr[] = "ptr";
static char __pyx_k_sys[] = "sys";
static char __pyx_k_var[] = "var";
static char __pyx_k_args[] = "args";
static char __pyx_k_argv[] = "argv";
static char __pyx_k_base[] = "base";
static char __pyx_k_data[] = "data";
static char __pyx_k_func[] = "func";
static char __pyx_k_init[] = "__init__";
static char __pyx_k_iter[] = "__iter__";
static char __pyx_k_main[] = "__main__";
static char __pyx_k_null[] = "null";
static char __pyx_k_perm[] = "perm";
static char __pyx_k_self[] = "self";
static char __pyx_k_send[] = "send";
static char __pyx_k_size[] = "size";
static char __pyx_k_test[] = "__test__";
static char __pyx_k_time[] = "time";
static char __pyx_k_Index[] = "Index";
static char __pyx_k_LOCAL[] = "LOCAL";
static char __pyx_k_array[] = "array";
static char __pyx_k_close[] = "close";
static char __pyx_k_delay[] = "delay";
static char __pyx_k_dumps[] = "dumps";
static char __pyx_k_index[] = "index";
static char __pyx_k_loads[] = "loads";
static char __pyx_k_range[] = "range";
static char __pyx_k_setup[] = "setup";
static char __pyx_k_throw[] = "throw";
static char __pyx_k_Buffer[] = "Buffer";
static char __pyx_k_GLOBAL[] = "GLOBAL";
static char __pyx_k_encode[] = "encode";
static char __pyx_k_format[] = "format";
static char __pyx_k_import[] = "__import__";
static char __pyx_k_module[] = "__module__";
static char __pyx_k_pickle[] = "pickle";
static char __pyx_k_xrange[] = "xrange";
static char __pyx_k_NoWidth[] = "NoWidth";
static char __pyx_k_cPickle[] = "cPickle";
static char __pyx_k_getcomm[] = "getcomm";
static char __pyx_k_pickled[] = "pickled";
static char __pyx_k_prepare[] = "__prepare__";
static char __pyx_k_pymusic[] = "pymusic";
static char __pyx_k_qualname[] = "__qualname__";
static char __pyx_k_required[] = "required";
static char __pyx_k_COMM_NULL[] = "COMM_NULL";
static char __pyx_k_Exception[] = "Exception";
static char __pyx_k_index_map[] = "index_map";
static char __pyx_k_metaclass[] = "__metaclass__";
static char __pyx_k_MUSICError[] = "MUSICError";
static char __pyx_k_ValueError[] = "ValueError";
static char __pyx_k_accLatency[] = "accLatency";
static char __pyx_k_mpi4py_MPI[] = "mpi4py.MPI";
static char __pyx_k_pyx_vtable[] = "__pyx_vtable__";
static char __pyx_k_MemoryError[] = "MemoryError";
static char __pyx_k_interpolate[] = "interpolate";
static char __pyx_k_maxBuffered[] = "maxBuffered";
static char __pyx_k_predictRank[] = "predictRank";
static char __pyx_k_NoWidth___init[] = "NoWidth.__init__";
static char __pyx_k_Runtime___iter[] = "Runtime.__iter__";
static char __pyx_k_music_pybuffer[] = "music.pybuffer";
static char __pyx_k_UndefinedConfig[] = "UndefinedConfig";
static char __pyx_k_HIGHEST_PROTOCOL[] = "HIGHEST_PROTOCOL";
static char __pyx_k_No_width_defined[] = "No width defined";
static char __pyx_k_argv_can_t_be_empty[] = "argv can't be empty";
static char __pyx_k_UndefinedConfig___init[] = "UndefinedConfig.__init__";
static char __pyx_k_couldn_t_allocate_argv[] = "couldn't allocate argv";
static char __pyx_k_Config_variable_is_not_defined[] = "Config variable {} is not defined";
static char __pyx_k_Thrown_if_Port_width_is_called[] = "\n    Thrown if Port.width() is called, and port doesn't\n    have a width defined.\n    ";
static char __pyx_k_All_exceptions_in_pymusic_are_M[] = "\n    All exceptions in pymusic are MUSICError's\n    ";
static char __pyx_k_Thrown_if_a_configuration_value[] = "\n    Thrown if a configuration value is requested\n    via Setup.config(varname) for a variable name\n    that has not been defined within the configuration.\n    ";
static char __pyx_k_home_apeyser_Code_music_pymusic[] = "/home/apeyser/Code/music/pymusic/pymusic.pyx";
static PyObject *__pyx_kp_s_All_exceptions_in_pymusic_are_M;
static PyObject *__pyx_n_s_Buffer;
static PyObject *__pyx_n_s_COMM_NULL;
static PyObject *__pyx_kp_s_Config_variable_is_not_defined;
static PyObject *__pyx_n_s_Exception;
static PyObject *__pyx_n_s_GLOBAL;
static PyObject *__pyx_n_s_HIGHEST_PROTOCOL;
static PyObject *__pyx_n_s_Index;
static PyObject *__pyx_n_s_LOCAL;
static PyObject *__pyx_n_s_MPI;
static PyObject *__pyx_n_s_MUSICError;
static PyObject *__pyx_n_s_MemoryError;
static PyObject *__pyx_n_s_NoWidth;
static PyObject *__pyx_n_s_NoWidth___init;
static PyObject *__pyx_kp_s_No_width_defined;
static PyObject *__pyx_n_s_Runtime___iter;
static PyObject *__pyx_kp_s_Thrown_if_Port_width_is_called;
static PyObject *__pyx_kp_s_Thrown_if_a_configuration_value;
static PyObject *__pyx_n_s_UndefinedConfig;
static PyObject *__pyx_n_s_UndefinedConfig___init;
static PyObject *__pyx_n_s_ValueError;
static PyObject *__pyx_n_s__3;
static PyObject *__pyx_n_s_accLatency;
static PyObject *__pyx_n_s_args;
static PyObject *__pyx_n_s_argv;
static PyObject *__pyx_kp_s_argv_can_t_be_empty;
static PyObject *__pyx_n_s_array;
static PyObject *__pyx_n_s_base;
static PyObject *__pyx_n_s_buf;
static PyObject *__pyx_n_s_cPickle;
static PyObject *__pyx_n_s_close;
static PyObject *__pyx_kp_s_couldn_t_allocate_argv;
static PyObject *__pyx_n_s_data;
static PyObject *__pyx_n_s_delay;
static PyObject *__pyx_n_s_doc;
static PyObject *__pyx_n_s_dumps;
static PyObject *__pyx_n_s_encode;
static PyObject *__pyx_n_s_format;
static PyObject *__pyx_n_s_func;
static PyObject *__pyx_n_s_getcomm;
static PyObject *__pyx_n_s_h;
static PyObject *__pyx_kp_s_home_apeyser_Code_music_pymusic;
static PyObject *__pyx_n_s_i;
static PyObject *__pyx_n_s_import;
static PyObject *__pyx_n_s_index;
static PyObject *__pyx_n_s_index_map;
static PyObject *__pyx_n_s_init;
static PyObject *__pyx_n_s_interpolate;
static PyObject *__pyx_n_s_iter;
static PyObject *__pyx_n_s_loads;
static PyObject *__pyx_n_s_main;
static PyObject *__pyx_n_s_maxBuffered;
static PyObject *__pyx_n_s_metaclass;
static PyObject *__pyx_n_s_module;
static PyObject *__pyx_n_s_mpi4py_MPI;
static PyObject *__pyx_n_s_msg;
static PyObject *__pyx_n_s_music_pybuffer;
static PyObject *__pyx_n_s_null;
static PyObject *__pyx_n_s_perm;
static PyObject *__pyx_n_s_pickle;
static PyObject *__pyx_n_s_pickled;
static PyObject *__pyx_n_s_predictRank;
static PyObject *__pyx_n_s_prepare;
static PyObject *__pyx_n_s_ptr;
static PyObject *__pyx_n_s_pymusic;
static PyObject *__pyx_n_s_pyx_vtable;
static PyObject *__pyx_n_s_qualname;
static PyObject *__pyx_n_s_r;
static PyObject *__pyx_n_s_range;
static PyObject *__pyx_n_s_required;
static PyObject *__pyx_n_s_self;
static PyObject *__pyx_n_s_send;
static PyObject *__pyx_n_s_setup;
static PyObject *__pyx_n_s_size;
static PyObject *__pyx_n_s_sys;
static PyObject *__pyx_n_s_t;
static PyObject *__pyx_n_s_test;
static PyObject *__pyx_n_s_throw;
static PyObject *__pyx_n_s_time;
static PyObject *__pyx_n_s_var;
static PyObject *__pyx_n_s_xrange;
static PyObject *__pyx_tuple_;
static PyObject *__pyx_tuple__2;
static PyObject *__pyx_tuple__4;
static PyObject *__pyx_tuple__6;
static PyObject *__pyx_tuple__8;
static PyObject *__pyx_codeobj__5;
static PyObject *__pyx_codeobj__7;
static PyObject *__pyx_codeobj__9;

/* "pymusic.pyx":23
 *     have a width defined.
 *     """
 *     def __init__(self):             # <<<<<<<<<<<<<<
 *         MUSICError.__init__(self, "No width defined")
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pymusic_7NoWidth_1__init__(PyObject *__pyx_self, PyObject *__pyx_v_self); /*proto*/
static PyMethodDef __pyx_mdef_7pymusic_7NoWidth_1__init__ = {"__init__", (PyCFunction)__pyx_pw_7pymusic_7NoWidth_1__init__, METH_O, 0};
static PyObject *__pyx_pw_7pymusic_7NoWidth_1__init__(PyObject *__pyx_self, PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pymusic_7NoWidth___init__(__pyx_self, ((PyObject *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pymusic_7NoWidth___init__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  Py_ssize_t __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__init__", 0);

  /* "pymusic.pyx":24
 *     """
 *     def __init__(self):
 *         MUSICError.__init__(self, "No width defined")             # <<<<<<<<<<<<<<
 * 
 * class UndefinedConfig(MUSICError):
 */
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_MUSICError); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 24; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_init); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 24; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = NULL;
  __pyx_t_4 = 0;
  if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
      __pyx_t_4 = 1;
    }
  }
  __pyx_t_5 = PyTuple_New(2+__pyx_t_4); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 24; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_5);
  if (__pyx_t_2) {
    PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_2); __Pyx_GIVEREF(__pyx_t_2); __pyx_t_2 = NULL;
  }
  __Pyx_INCREF(__pyx_v_self);
  PyTuple_SET_ITEM(__pyx_t_5, 0+__pyx_t_4, __pyx_v_self);
  __Pyx_GIVEREF(__pyx_v_self);
  __Pyx_INCREF(__pyx_kp_s_No_width_defined);
  PyTuple_SET_ITEM(__pyx_t_5, 1+__pyx_t_4, __pyx_kp_s_No_width_defined);
  __Pyx_GIVEREF(__pyx_kp_s_No_width_defined);
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 24; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pymusic.pyx":23
 *     have a width defined.
 *     """
 *     def __init__(self):             # <<<<<<<<<<<<<<
 *         MUSICError.__init__(self, "No width defined")
 * 
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("pymusic.NoWidth.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":32
 *     that has not been defined within the configuration.
 *     """
 *     def __init__(self, var):             # <<<<<<<<<<<<<<
 *         MUSICError.__init__(
 *             self,
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pymusic_15UndefinedConfig_1__init__(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static PyMethodDef __pyx_mdef_7pymusic_15UndefinedConfig_1__init__ = {"__init__", (PyCFunction)__pyx_pw_7pymusic_15UndefinedConfig_1__init__, METH_VARARGS|METH_KEYWORDS, 0};
static PyObject *__pyx_pw_7pymusic_15UndefinedConfig_1__init__(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_self = 0;
  PyObject *__pyx_v_var = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_self,&__pyx_n_s_var,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_self)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_var)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__init__", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 32; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 32; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_self = values[0];
    __pyx_v_var = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__init__", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 32; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("pymusic.UndefinedConfig.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_7pymusic_15UndefinedConfig___init__(__pyx_self, __pyx_v_self, __pyx_v_var);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pymusic_15UndefinedConfig___init__(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_self, PyObject *__pyx_v_var) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  Py_ssize_t __pyx_t_7;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__init__", 0);

  /* "pymusic.pyx":33
 *     """
 *     def __init__(self, var):
 *         MUSICError.__init__(             # <<<<<<<<<<<<<<
 *             self,
 *             "Config variable {} is not defined".
 */
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_MUSICError); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 33; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_init); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 33; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "pymusic.pyx":35
 *         MUSICError.__init__(
 *             self,
 *             "Config variable {} is not defined".             # <<<<<<<<<<<<<<
 *             format(var)
 *         )
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_kp_s_Config_variable_is_not_defined, __pyx_n_s_format); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 35; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);

  /* "pymusic.pyx":36
 *             self,
 *             "Config variable {} is not defined".
 *             format(var)             # <<<<<<<<<<<<<<
 *         )
 * 
 */
  __pyx_t_5 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_4))) {
    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
    if (likely(__pyx_t_5)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
      __Pyx_INCREF(__pyx_t_5);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_4, function);
    }
  }
  if (!__pyx_t_5) {
    __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_var); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 36; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
  } else {
    __pyx_t_6 = PyTuple_New(1+1); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 36; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_6);
    PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_5); __Pyx_GIVEREF(__pyx_t_5); __pyx_t_5 = NULL;
    __Pyx_INCREF(__pyx_v_var);
    PyTuple_SET_ITEM(__pyx_t_6, 0+1, __pyx_v_var);
    __Pyx_GIVEREF(__pyx_v_var);
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_6, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 36; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  }
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_4 = NULL;
  __pyx_t_7 = 0;
  if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
      __pyx_t_7 = 1;
    }
  }
  __pyx_t_6 = PyTuple_New(2+__pyx_t_7); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 33; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_6);
  if (__pyx_t_4) {
    PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_4); __Pyx_GIVEREF(__pyx_t_4); __pyx_t_4 = NULL;
  }
  __Pyx_INCREF(__pyx_v_self);
  PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_7, __pyx_v_self);
  __Pyx_GIVEREF(__pyx_v_self);
  PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_7, __pyx_t_2);
  __Pyx_GIVEREF(__pyx_t_2);
  __pyx_t_2 = 0;
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_6, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 33; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pymusic.pyx":32
 *     that has not been defined within the configuration.
 *     """
 *     def __init__(self, var):             # <<<<<<<<<<<<<<
 *         MUSICError.__init__(
 *             self,
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("pymusic.UndefinedConfig.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":52
 *     char** argv
 * 
 * cdef Args argv_toc(list argv):             # <<<<<<<<<<<<<<
 *     """
 *     Convert an argv python list to a correct C argv & argc
 */

static __pyx_t_7pymusic_Args __pyx_f_7pymusic_argv_toc(PyObject *__pyx_v_argv) {
  __pyx_t_7pymusic_Args __pyx_v_r;
  long __pyx_v_i;
  PyObject *__pyx_v_s = NULL;
  __pyx_t_7pymusic_Args __pyx_r;
  __Pyx_RefNannyDeclarations
  Py_ssize_t __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  int __pyx_t_8;
  long __pyx_t_9;
  PyObject *__pyx_t_10 = NULL;
  char *__pyx_t_11;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("argv_toc", 0);

  /* "pymusic.pyx":58
 *     """
 *     cdef Args r
 *     r.argc = len(argv)             # <<<<<<<<<<<<<<
 *     if r.argc <= 0:
 *         raise MUSICError("argv can't be empty")
 */
  if (unlikely(__pyx_v_argv == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "object of type 'NoneType' has no len()");
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 58; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_t_1 = PyList_GET_SIZE(__pyx_v_argv); if (unlikely(__pyx_t_1 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 58; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_r.argc = __pyx_t_1;

  /* "pymusic.pyx":59
 *     cdef Args r
 *     r.argc = len(argv)
 *     if r.argc <= 0:             # <<<<<<<<<<<<<<
 *         raise MUSICError("argv can't be empty")
 * 
 */
  __pyx_t_2 = ((__pyx_v_r.argc <= 0) != 0);
  if (__pyx_t_2) {

    /* "pymusic.pyx":60
 *     r.argc = len(argv)
 *     if r.argc <= 0:
 *         raise MUSICError("argv can't be empty")             # <<<<<<<<<<<<<<
 * 
 *     r.argv = <char**> malloc((r.argc+1) * sizeof(char*))
 */
    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_MUSICError); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple_, NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }

  /* "pymusic.pyx":62
 *         raise MUSICError("argv can't be empty")
 * 
 *     r.argv = <char**> malloc((r.argc+1) * sizeof(char*))             # <<<<<<<<<<<<<<
 *     if r.argv is NULL:
 *         raise MUSICError("couldn't allocate argv")
 */
  __pyx_v_r.argv = ((char **)malloc(((__pyx_v_r.argc + 1) * (sizeof(char *)))));

  /* "pymusic.pyx":63
 * 
 *     r.argv = <char**> malloc((r.argc+1) * sizeof(char*))
 *     if r.argv is NULL:             # <<<<<<<<<<<<<<
 *         raise MUSICError("couldn't allocate argv")
 * 
 */
  __pyx_t_2 = ((__pyx_v_r.argv == NULL) != 0);
  if (__pyx_t_2) {

    /* "pymusic.pyx":64
 *     r.argv = <char**> malloc((r.argc+1) * sizeof(char*))
 *     if r.argv is NULL:
 *         raise MUSICError("couldn't allocate argv")             # <<<<<<<<<<<<<<
 * 
 *     cdef string
 */
    __pyx_t_4 = __Pyx_GetModuleGlobalName(__pyx_n_s_MUSICError); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 64; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 64; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 64; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }

  /* "pymusic.pyx":67
 * 
 *     cdef string
 *     try:             # <<<<<<<<<<<<<<
 *         r.argv[r.argc] = NULL
 *         for i in range(0, r.argc):
 */
  {
    __Pyx_ExceptionSave(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7);
    __Pyx_XGOTREF(__pyx_t_5);
    __Pyx_XGOTREF(__pyx_t_6);
    __Pyx_XGOTREF(__pyx_t_7);
    /*try:*/ {

      /* "pymusic.pyx":68
 *     cdef string
 *     try:
 *         r.argv[r.argc] = NULL             # <<<<<<<<<<<<<<
 *         for i in range(0, r.argc):
 *             s = argv[i].encode()
 */
      (__pyx_v_r.argv[__pyx_v_r.argc]) = NULL;

      /* "pymusic.pyx":69
 *     try:
 *         r.argv[r.argc] = NULL
 *         for i in range(0, r.argc):             # <<<<<<<<<<<<<<
 *             s = argv[i].encode()
 *             r.argv[i] = s
 */
      __pyx_t_8 = __pyx_v_r.argc;
      for (__pyx_t_9 = 0; __pyx_t_9 < __pyx_t_8; __pyx_t_9+=1) {
        __pyx_v_i = __pyx_t_9;

        /* "pymusic.pyx":70
 *         r.argv[r.argc] = NULL
 *         for i in range(0, r.argc):
 *             s = argv[i].encode()             # <<<<<<<<<<<<<<
 *             r.argv[i] = s
 *         return r
 */
        if (unlikely(__pyx_v_argv == Py_None)) {
          PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
          {__pyx_filename = __pyx_f[0]; __pyx_lineno = 70; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
        }
        __pyx_t_4 = __Pyx_GetItemInt_List(__pyx_v_argv, __pyx_v_i, long, 1, __Pyx_PyInt_From_long, 1, 1, 1); if (unlikely(__pyx_t_4 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 70; __pyx_clineno = __LINE__; goto __pyx_L5_error;};
        __Pyx_GOTREF(__pyx_t_4);
        __pyx_t_10 = __Pyx_PyObject_GetAttrStr(__pyx_t_4, __pyx_n_s_encode); if (unlikely(!__pyx_t_10)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 70; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
        __Pyx_GOTREF(__pyx_t_10);
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        __pyx_t_4 = NULL;
        if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_10))) {
          __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_10);
          if (likely(__pyx_t_4)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_10);
            __Pyx_INCREF(__pyx_t_4);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_10, function);
          }
        }
        if (__pyx_t_4) {
          __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_t_10, __pyx_t_4); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 70; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
          __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        } else {
          __pyx_t_3 = __Pyx_PyObject_CallNoArg(__pyx_t_10); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 70; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
        }
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
        __Pyx_XDECREF_SET(__pyx_v_s, __pyx_t_3);
        __pyx_t_3 = 0;

        /* "pymusic.pyx":71
 *         for i in range(0, r.argc):
 *             s = argv[i].encode()
 *             r.argv[i] = s             # <<<<<<<<<<<<<<
 *         return r
 *     except:
 */
        __pyx_t_11 = __Pyx_PyObject_AsString(__pyx_v_s); if (unlikely((!__pyx_t_11) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 71; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
        (__pyx_v_r.argv[__pyx_v_i]) = __pyx_t_11;
      }

      /* "pymusic.pyx":72
 *             s = argv[i].encode()
 *             r.argv[i] = s
 *         return r             # <<<<<<<<<<<<<<
 *     except:
 *         free(r.argv)
 */
      __pyx_r = __pyx_v_r;
      goto __pyx_L9_try_return;
    }
    __pyx_L5_error:;
    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;

    /* "pymusic.pyx":73
 *             r.argv[i] = s
 *         return r
 *     except:             # <<<<<<<<<<<<<<
 *         free(r.argv)
 *         raise
 */
    /*except:*/ {
      __Pyx_AddTraceback("pymusic.argv_toc", __pyx_clineno, __pyx_lineno, __pyx_filename);
      if (__Pyx_GetException(&__pyx_t_3, &__pyx_t_10, &__pyx_t_4) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 73; __pyx_clineno = __LINE__; goto __pyx_L7_except_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_GOTREF(__pyx_t_10);
      __Pyx_GOTREF(__pyx_t_4);

      /* "pymusic.pyx":74
 *         return r
 *     except:
 *         free(r.argv)             # <<<<<<<<<<<<<<
 *         raise
 * 
 */
      free(__pyx_v_r.argv);

      /* "pymusic.pyx":75
 *     except:
 *         free(r.argv)
 *         raise             # <<<<<<<<<<<<<<
 * 
 * ###########################################################
 */
      __Pyx_GIVEREF(__pyx_t_3);
      __Pyx_GIVEREF(__pyx_t_10);
      __Pyx_XGIVEREF(__pyx_t_4);
      __Pyx_ErrRestore(__pyx_t_3, __pyx_t_10, __pyx_t_4);
      __pyx_t_3 = 0; __pyx_t_10 = 0; __pyx_t_4 = 0; 
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 75; __pyx_clineno = __LINE__; goto __pyx_L7_except_error;}
    }
    __pyx_L7_except_error:;
    __Pyx_XGIVEREF(__pyx_t_5);
    __Pyx_XGIVEREF(__pyx_t_6);
    __Pyx_XGIVEREF(__pyx_t_7);
    __Pyx_ExceptionReset(__pyx_t_5, __pyx_t_6, __pyx_t_7);
    goto __pyx_L1_error;
    __pyx_L9_try_return:;
    __Pyx_XGIVEREF(__pyx_t_5);
    __Pyx_XGIVEREF(__pyx_t_6);
    __Pyx_XGIVEREF(__pyx_t_7);
    __Pyx_ExceptionReset(__pyx_t_5, __pyx_t_6, __pyx_t_7);
    goto __pyx_L0;
  }

  /* "pymusic.pyx":52
 *     char** argv
 * 
 * cdef Args argv_toc(list argv):             # <<<<<<<<<<<<<<
 *     """
 *     Convert an argv python list to a correct C argv & argc
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_10);
  __Pyx_WriteUnraisable("pymusic.argv_toc", __pyx_clineno, __pyx_lineno, __pyx_filename, 0);
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_s);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":79
 * ###########################################################
 * 
 * def predictRank(list argv=None):             # <<<<<<<<<<<<<<
 *     """
 *     Map into mpidep/predict_rank for config methods.
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pymusic_1predictRank(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_7pymusic_predictRank[] = "\n    Map into mpidep/predict_rank for config methods.\n    AP: What is this really used for?\n    ";
static PyMethodDef __pyx_mdef_7pymusic_1predictRank = {"predictRank", (PyCFunction)__pyx_pw_7pymusic_1predictRank, METH_VARARGS|METH_KEYWORDS, __pyx_doc_7pymusic_predictRank};
static PyObject *__pyx_pw_7pymusic_1predictRank(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_argv = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("predictRank (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_argv,0};
    PyObject* values[1] = {0};
    values[0] = ((PyObject*)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_argv);
          if (value) { values[0] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "predictRank") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 79; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_argv = ((PyObject*)values[0]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("predictRank", 0, 0, 1, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 79; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("pymusic.predictRank", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_argv), (&PyList_Type), 1, "argv", 1))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 79; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_7pymusic_predictRank(__pyx_self, __pyx_v_argv);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pymusic_predictRank(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_argv) {
  __pyx_t_7pymusic_Args __pyx_v_r;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("predictRank", 0);

  /* "pymusic.pyx":84
 *     AP: What is this really used for?
 *     """
 *     cdef Args r = argv_toc(argv if argv is not None else             # <<<<<<<<<<<<<<
 *                            sys.argv)
 *     return CPredictRank(r.argc, r.argv)
 */
  __pyx_t_2 = (__pyx_v_argv != ((PyObject*)Py_None));
  if ((__pyx_t_2 != 0)) {
    __Pyx_INCREF(__pyx_v_argv);
    __pyx_t_1 = __pyx_v_argv;
  } else {

    /* "pymusic.pyx":85
 *     """
 *     cdef Args r = argv_toc(argv if argv is not None else
 *                            sys.argv)             # <<<<<<<<<<<<<<
 *     return CPredictRank(r.argc, r.argv)
 * 
 */
    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_sys); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 85; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_argv); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 85; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    if (!(likely(PyList_CheckExact(__pyx_t_4))||((__pyx_t_4) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "list", Py_TYPE(__pyx_t_4)->tp_name), 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 85; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __pyx_t_1 = __pyx_t_4;
    __pyx_t_4 = 0;
  }

  /* "pymusic.pyx":84
 *     AP: What is this really used for?
 *     """
 *     cdef Args r = argv_toc(argv if argv is not None else             # <<<<<<<<<<<<<<
 *                            sys.argv)
 *     return CPredictRank(r.argc, r.argv)
 */
  __pyx_v_r = __pyx_f_7pymusic_argv_toc(((PyObject*)__pyx_t_1));
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pymusic.pyx":86
 *     cdef Args r = argv_toc(argv if argv is not None else
 *                            sys.argv)
 *     return CPredictRank(r.argc, r.argv)             # <<<<<<<<<<<<<<
 * 
 * ###########################################################
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_int(MUSIC::predictRank(__pyx_v_r.argc, __pyx_v_r.argv)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 86; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pymusic.pyx":79
 * ###########################################################
 * 
 * def predictRank(list argv=None):             # <<<<<<<<<<<<<<
 *     """
 *     Map into mpidep/predict_rank for config methods.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("pymusic.predictRank", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":99
 *     container.
 *     """
 *     def __cinit__(self):             # <<<<<<<<<<<<<<
 *         """
 *         When a Port object is created, it needs to have an underlying
 */

/* Python wrapper */
static int __pyx_pw_7pymusic_4Port_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_7pymusic_4Port_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
  if (unlikely(PyTuple_GET_SIZE(__pyx_args) > 0)) {
    __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 0, 0, PyTuple_GET_SIZE(__pyx_args)); return -1;}
  if (unlikely(__pyx_kwds) && unlikely(PyDict_Size(__pyx_kwds) > 0) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "__cinit__", 0))) return -1;
  __pyx_r = __pyx_pf_7pymusic_4Port___cinit__(((struct __pyx_obj_7pymusic_Port *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_7pymusic_4Port___cinit__(struct __pyx_obj_7pymusic_Port *__pyx_v_self) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__", 0);

  /* "pymusic.pyx":104
 *         C++ class assigned to ptr from a Setup.publish* method.
 *         """
 *         self.ptr = NULL             # <<<<<<<<<<<<<<
 * 
 *     def __hash__(self):
 */
  __pyx_v_self->ptr = NULL;

  /* "pymusic.pyx":99
 *     container.
 *     """
 *     def __cinit__(self):             # <<<<<<<<<<<<<<
 *         """
 *         When a Port object is created, it needs to have an underlying
 */

  /* function exit code */
  __pyx_r = 0;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":106
 *         self.ptr = NULL
 * 
 *     def __hash__(self):             # <<<<<<<<<<<<<<
 *         """
 *         Hash function: pointer value % to an int.
 */

/* Python wrapper */
static Py_hash_t __pyx_pw_7pymusic_4Port_3__hash__(PyObject *__pyx_v_self); /*proto*/
static char __pyx_doc_7pymusic_4Port_2__hash__[] = "\n        Hash function: pointer value % to an int.\n        ";
#if CYTHON_COMPILING_IN_CPYTHON
struct wrapperbase __pyx_wrapperbase_7pymusic_4Port_2__hash__;
#endif
static Py_hash_t __pyx_pw_7pymusic_4Port_3__hash__(PyObject *__pyx_v_self) {
  Py_hash_t __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__hash__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pymusic_4Port_2__hash__(((struct __pyx_obj_7pymusic_Port *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static Py_hash_t __pyx_pf_7pymusic_4Port_2__hash__(struct __pyx_obj_7pymusic_Port *__pyx_v_self) {
  Py_hash_t __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__hash__", 0);

  /* "pymusic.pyx":110
 *         Hash function: pointer value % to an int.
 *         """
 *         return <int><size_t> self.ptr             # <<<<<<<<<<<<<<
 * 
 *     cpdef null(self):
 */
  __pyx_r = ((int)((size_t)__pyx_v_self->ptr));
  goto __pyx_L0;

  /* "pymusic.pyx":106
 *         self.ptr = NULL
 * 
 *     def __hash__(self):             # <<<<<<<<<<<<<<
 *         """
 *         Hash function: pointer value % to an int.
 */

  /* function exit code */
  __pyx_L0:;
  if (unlikely(__pyx_r == -1) && !PyErr_Occurred()) __pyx_r = -2;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":112
 *         return <int><size_t> self.ptr
 * 
 *     cpdef null(self):             # <<<<<<<<<<<<<<
 *         """
 *         When Setup or Runtime no longer needs ports and so may deallocate
 */

static PyObject *__pyx_pw_7pymusic_4Port_5null(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyObject *__pyx_f_7pymusic_4Port_null(struct __pyx_obj_7pymusic_Port *__pyx_v_self, int __pyx_skip_dispatch) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("null", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely(Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0)) {
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_null); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 112; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)__pyx_pw_7pymusic_4Port_5null)) {
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(__pyx_t_1);
      __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
      if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_3))) {
        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
        if (likely(__pyx_t_4)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
          __Pyx_INCREF(__pyx_t_4);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_3, function);
        }
      }
      if (__pyx_t_4) {
        __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 112; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      } else {
        __pyx_t_2 = __Pyx_PyObject_CallNoArg(__pyx_t_3); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 112; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      }
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_r = __pyx_t_2;
      __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      goto __pyx_L0;
    }
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  }

  /* "pymusic.pyx":119
 *         the descendants
 *         """
 *         self.ptr = NULL             # <<<<<<<<<<<<<<
 * 
 *     def isConnected(self):
 */
  __pyx_v_self->ptr = NULL;

  /* "pymusic.pyx":112
 *         return <int><size_t> self.ptr
 * 
 *     cpdef null(self):             # <<<<<<<<<<<<<<
 *         """
 *         When Setup or Runtime no longer needs ports and so may deallocate
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("pymusic.Port.null", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_7pymusic_4Port_5null(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_7pymusic_4Port_4null[] = "\n        When Setup or Runtime no longer needs ports and so may deallocate\n        them, we first must clear the references to them here. This\n        may be overridden to give up references to other members by\n        the descendants\n        ";
static PyObject *__pyx_pw_7pymusic_4Port_5null(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("null (wrapper)", 0);
  __pyx_r = __pyx_pf_7pymusic_4Port_4null(((struct __pyx_obj_7pymusic_Port *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pymusic_4Port_4null(struct __pyx_obj_7pymusic_Port *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("null", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_f_7pymusic_4Port_null(__pyx_v_self, 1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 112; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pymusic.Port.null", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":121
 *         self.ptr = NULL
 * 
 *     def isConnected(self):             # <<<<<<<<<<<<<<
 *         """
 *         return True iff the port is actually connected via the config
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pymusic_4Port_7isConnected(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_7pymusic_4Port_6isConnected[] = "\n        return True iff the port is actually connected via the config\n        file.\n        ";
static PyObject *__pyx_pw_7pymusic_4Port_7isConnected(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("isConnected (wrapper)", 0);
  __pyx_r = __pyx_pf_7pymusic_4Port_6isConnected(((struct __pyx_obj_7pymusic_Port *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pymusic_4Port_6isConnected(struct __pyx_obj_7pymusic_Port *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("isConnected", 0);

  /* "pymusic.pyx":126
 *         file.
 *         """
 *         return self.ptr.isConnected()             # <<<<<<<<<<<<<<
 * 
 *     def width(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->ptr->isConnected()); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 126; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pymusic.pyx":121
 *         self.ptr = NULL
 * 
 *     def isConnected(self):             # <<<<<<<<<<<<<<
 *         """
 *         return True iff the port is actually connected via the config
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pymusic.Port.isConnected", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":128
 *         return self.ptr.isConnected()
 * 
 *     def width(self):             # <<<<<<<<<<<<<<
 *         """
 *         Returns the width set in the MUSIC config file
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pymusic_4Port_9width(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_7pymusic_4Port_8width[] = "\n        Returns the width set in the MUSIC config file\n        which defines the number of indices transferred\n        along this port. If no width is defined, raise a NoWidth\n        exception.\n        ";
static PyObject *__pyx_pw_7pymusic_4Port_9width(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("width (wrapper)", 0);
  __pyx_r = __pyx_pf_7pymusic_4Port_8width(((struct __pyx_obj_7pymusic_Port *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pymusic_4Port_8width(struct __pyx_obj_7pymusic_Port *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("width", 0);

  /* "pymusic.pyx":135
 *         exception.
 *         """
 *         if not self.ptr.hasWidth(): raise NoWidth()             # <<<<<<<<<<<<<<
 *         return self.ptr.width()
 * 
 */
  __pyx_t_1 = ((!(__pyx_v_self->ptr->hasWidth() != 0)) != 0);
  if (__pyx_t_1) {
    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_NoWidth); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 135; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = NULL;
    if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_4)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_4);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
      }
    }
    if (__pyx_t_4) {
      __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 135; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    } else {
      __pyx_t_2 = __Pyx_PyObject_CallNoArg(__pyx_t_3); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 135; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    }
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 135; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }

  /* "pymusic.pyx":136
 *         """
 *         if not self.ptr.hasWidth(): raise NoWidth()
 *         return self.ptr.width()             # <<<<<<<<<<<<<<
 * 
 * cdef class ContInputPort(Port):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_self->ptr->width()); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 136; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "pymusic.pyx":128
 *         return self.ptr.isConnected()
 * 
 *     def width(self):             # <<<<<<<<<<<<<<
 *         """
 *         Returns the width set in the MUSIC config file
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("pymusic.Port.width", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":144
 *     Setup.publishContInputPort(portname).
 *     """
 *     def map(self,             # <<<<<<<<<<<<<<
 *             object data,
 *             int base=0,
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pymusic_13ContInputPort_1map(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_7pymusic_13ContInputPort_map[] = "\n        map data as source for this port. (Can you do a multiple mapping?)\n\n        object data: object to be shared that has a buffer interface.\n                     That interface needs to be contiguous formed of\n                     simple items that can be mapped to simple MPI\n                     data types.\n        int base (=0), object perm (=None): used to construct an\n                     IndexMap (with number of items in data). See that\n                     class for more information. Defines mapping for data\n                     between this input source and the output sinks.\n        double delay (=0): this is the delay of measurement relative\n                           to \"something\" which I haven't been able to\n                           figure out yet --- needs to be explained.\n        interpolate (=True): whether to do a linear interpolation of\n                             the values that are being delayed. Once\n                             again, needs to be better explained.\n        maxBuffered (=-1): buffer up to maxBuffered ticks. If -1, use\n                           a \"reasonable value\" (\077\077?).  What does this\n                           mean on the input side?\n        ";
static PyObject *__pyx_pw_7pymusic_13ContInputPort_1map(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_data = 0;
  int __pyx_v_base;
  PyObject *__pyx_v_perm = 0;
  double __pyx_v_delay;
  bool __pyx_v_interpolate;
  int __pyx_v_maxBuffered;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("map (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_data,&__pyx_n_s_base,&__pyx_n_s_perm,&__pyx_n_s_delay,&__pyx_n_s_interpolate,&__pyx_n_s_maxBuffered,0};
    PyObject* values[6] = {0,0,0,0,0,0};

    /* "pymusic.pyx":147
 *             object data,
 *             int base=0,
 *             object perm=None,             # <<<<<<<<<<<<<<
 *             double delay=0,
 *             cbool interpolate=True,
 */
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_base);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_perm);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_delay);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_interpolate);
          if (value) { values[4] = value; kw_args--; }
        }
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_maxBuffered);
          if (value) { values[5] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "map") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 144; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_data = values[0];
    if (values[1]) {
      __pyx_v_base = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_base == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 146; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_base = ((int)0);
    }
    __pyx_v_perm = values[2];
    if (values[3]) {
      __pyx_v_delay = __pyx_PyFloat_AsDouble(values[3]); if (unlikely((__pyx_v_delay == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 148; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_delay = ((double)0.0);
    }
    if (values[4]) {
      __pyx_v_interpolate = __Pyx_PyObject_IsTrue(values[4]); if (unlikely((__pyx_v_interpolate == (bool)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 149; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {

      /* "pymusic.pyx":149
 *             object perm=None,
 *             double delay=0,
 *             cbool interpolate=True,             # <<<<<<<<<<<<<<
 *             int maxBuffered=-1):
 *         """
 */
      __pyx_v_interpolate = ((bool)1);
    }
    if (values[5]) {
      __pyx_v_maxBuffered = __Pyx_PyInt_As_int(values[5]); if (unlikely((__pyx_v_maxBuffered == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 150; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_maxBuffered = ((int)-1);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("map", 0, 1, 6, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 144; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("pymusic.ContInputPort.map", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_7pymusic_13ContInputPort_map(((struct __pyx_obj_7pymusic_ContInputPort *)__pyx_v_self), __pyx_v_data, __pyx_v_base, __pyx_v_perm, __pyx_v_delay, __pyx_v_interpolate, __pyx_v_maxBuffered);

  /* "pymusic.pyx":144
 *     Setup.publishContInputPort(portname).
 *     """
 *     def map(self,             # <<<<<<<<<<<<<<
 *             object data,
 *             int base=0,
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pymusic_13ContInputPort_map(struct __pyx_obj_7pymusic_ContInputPort *__pyx_v_self, PyObject *__pyx_v_data, int __pyx_v_base, PyObject *__pyx_v_perm, double __pyx_v_delay, bool __pyx_v_interpolate, int __pyx_v_maxBuffered) {
  struct __pyx_obj_5music_8pybuffer_Buffer *__pyx_v_buf = 0;
  struct __pyx_obj_7pymusic_IndexMap *__pyx_v_imap = 0;
  struct __pyx_obj_7pymusic_DataMap *__pyx_v_d = 0;
  MUSIC::ContInputPort *__pyx_v_ptr;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("map", 0);

  /* "pymusic.pyx":172
 *                            mean on the input side?
 *         """
 *         cdef Buffer buf = Buffer(data)             # <<<<<<<<<<<<<<
 *         cdef IndexMap imap = IndexMap(perm, base, buf.items)
 *         cdef DataMap d = DataMap(buf, imap)
 */
  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 172; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_v_data);
  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_data);
  __Pyx_GIVEREF(__pyx_v_data);
  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_5music_8pybuffer_Buffer)), __pyx_t_1, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 172; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_buf = ((struct __pyx_obj_5music_8pybuffer_Buffer *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "pymusic.pyx":173
 *         """
 *         cdef Buffer buf = Buffer(data)
 *         cdef IndexMap imap = IndexMap(perm, base, buf.items)             # <<<<<<<<<<<<<<
 *         cdef DataMap d = DataMap(buf, imap)
 *         cdef CContInputPort* ptr = dc_CContInputPort(self.ptr)
 */
  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_base); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 173; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_1 = PyInt_FromSsize_t(__pyx_v_buf->items); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 173; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 173; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_INCREF(__pyx_v_perm);
  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_perm);
  __Pyx_GIVEREF(__pyx_v_perm);
  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_2);
  __Pyx_GIVEREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_2 = 0;
  __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_7pymusic_IndexMap)), __pyx_t_3, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 173; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_v_imap = ((struct __pyx_obj_7pymusic_IndexMap *)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "pymusic.pyx":174
 *         cdef Buffer buf = Buffer(data)
 *         cdef IndexMap imap = IndexMap(perm, base, buf.items)
 *         cdef DataMap d = DataMap(buf, imap)             # <<<<<<<<<<<<<<
 *         cdef CContInputPort* ptr = dc_CContInputPort(self.ptr)
 *         mapImpl(ptr, d.ptr, delay, maxBuffered, interpolate)
 */
  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 174; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(((PyObject *)__pyx_v_buf));
  PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)__pyx_v_buf));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_buf));
  __Pyx_INCREF(((PyObject *)__pyx_v_imap));
  PyTuple_SET_ITEM(__pyx_t_1, 1, ((PyObject *)__pyx_v_imap));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_imap));
  __pyx_t_3 = __Pyx_PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_7pymusic_DataMap)), __pyx_t_1, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 174; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_d = ((struct __pyx_obj_7pymusic_DataMap *)__pyx_t_3);
  __pyx_t_3 = 0;

  /* "pymusic.pyx":175
 *         cdef IndexMap imap = IndexMap(perm, base, buf.items)
 *         cdef DataMap d = DataMap(buf, imap)
 *         cdef CContInputPort* ptr = dc_CContInputPort(self.ptr)             # <<<<<<<<<<<<<<
 *         mapImpl(ptr, d.ptr, delay, maxBuffered, interpolate)
 * 
 */
  __pyx_v_ptr = dynamic_cast<MUSIC::ContInputPort*>(__pyx_v_self->__pyx_base.ptr);

  /* "pymusic.pyx":176
 *         cdef DataMap d = DataMap(buf, imap)
 *         cdef CContInputPort* ptr = dc_CContInputPort(self.ptr)
 *         mapImpl(ptr, d.ptr, delay, maxBuffered, interpolate)             # <<<<<<<<<<<<<<
 * 
 * cdef class ContOutputPort(Port):
 */
  MUSIC::Implementer::mapImpl(__pyx_v_ptr, __pyx_v_d->ptr, __pyx_v_delay, __pyx_v_maxBuffered, __pyx_v_interpolate);

  /* "pymusic.pyx":144
 *     Setup.publishContInputPort(portname).
 *     """
 *     def map(self,             # <<<<<<<<<<<<<<
 *             object data,
 *             int base=0,
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("pymusic.ContInputPort.map", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_buf);
  __Pyx_XDECREF((PyObject *)__pyx_v_imap);
  __Pyx_XDECREF((PyObject *)__pyx_v_d);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":184
 *     Setup.publishContOutputPort(portname).
 *     """
 *     def map(self, object data,             # <<<<<<<<<<<<<<
 *             int base=0, object perm=None,
 *             int maxBuffered=-1):
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pymusic_14ContOutputPort_1map(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_7pymusic_14ContOutputPort_map[] = "\n        map data as sink for this port. (Can you do a multiple mapping?)\n\n        object data: object to be shared that has a buffer interface.\n                     That interface needs to be contiguous formed of\n                     simple items that can be mapped to simple MPI\n                     data types.\n        int base (=0), object perm (=None): used to construct an\n                     IndexMap (with number of items in data). See that\n                     class for more information. Defines mapping for data\n                     between this input source and the output sinks.\n        maxBuffered (=-1): buffer up to maxBuffered ticks. If -1, use\n                     a \"reasonable value\" (\077\077?).\n        ";
static PyObject *__pyx_pw_7pymusic_14ContOutputPort_1map(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_data = 0;
  int __pyx_v_base;
  PyObject *__pyx_v_perm = 0;
  int __pyx_v_maxBuffered;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("map (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_data,&__pyx_n_s_base,&__pyx_n_s_perm,&__pyx_n_s_maxBuffered,0};
    PyObject* values[4] = {0,0,0,0};

    /* "pymusic.pyx":185
 *     """
 *     def map(self, object data,
 *             int base=0, object perm=None,             # <<<<<<<<<<<<<<
 *             int maxBuffered=-1):
 *         """
 */
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_data)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_base);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_perm);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_maxBuffered);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "map") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 184; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_data = values[0];
    if (values[1]) {
      __pyx_v_base = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_base == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 185; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_base = ((int)0);
    }
    __pyx_v_perm = values[2];
    if (values[3]) {
      __pyx_v_maxBuffered = __Pyx_PyInt_As_int(values[3]); if (unlikely((__pyx_v_maxBuffered == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 186; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_maxBuffered = ((int)-1);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("map", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 184; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("pymusic.ContOutputPort.map", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_7pymusic_14ContOutputPort_map(((struct __pyx_obj_7pymusic_ContOutputPort *)__pyx_v_self), __pyx_v_data, __pyx_v_base, __pyx_v_perm, __pyx_v_maxBuffered);

  /* "pymusic.pyx":184
 *     Setup.publishContOutputPort(portname).
 *     """
 *     def map(self, object data,             # <<<<<<<<<<<<<<
 *             int base=0, object perm=None,
 *             int maxBuffered=-1):
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pymusic_14ContOutputPort_map(struct __pyx_obj_7pymusic_ContOutputPort *__pyx_v_self, PyObject *__pyx_v_data, int __pyx_v_base, PyObject *__pyx_v_perm, int __pyx_v_maxBuffered) {
  struct __pyx_obj_5music_8pybuffer_Buffer *__pyx_v_buf = 0;
  struct __pyx_obj_7pymusic_IndexMap *__pyx_v_imap = 0;
  struct __pyx_obj_7pymusic_DataMap *__pyx_v_d = 0;
  MUSIC::ContOutputPort *__pyx_v_ptr;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("map", 0);

  /* "pymusic.pyx":201
 *                      a "reasonable value" (???).
 *         """
 *         cdef Buffer buf = Buffer(data)             # <<<<<<<<<<<<<<
 *         cdef IndexMap imap = IndexMap(perm, base, buf.items)
 *         cdef DataMap d = DataMap(buf, imap)
 */
  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 201; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_v_data);
  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_data);
  __Pyx_GIVEREF(__pyx_v_data);
  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_5music_8pybuffer_Buffer)), __pyx_t_1, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 201; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_buf = ((struct __pyx_obj_5music_8pybuffer_Buffer *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "pymusic.pyx":202
 *         """
 *         cdef Buffer buf = Buffer(data)
 *         cdef IndexMap imap = IndexMap(perm, base, buf.items)             # <<<<<<<<<<<<<<
 *         cdef DataMap d = DataMap(buf, imap)
 *         cdef CContOutputPort* ptr = dc_CContOutputPort(self.ptr)
 */
  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_base); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 202; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_1 = PyInt_FromSsize_t(__pyx_v_buf->items); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 202; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 202; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_INCREF(__pyx_v_perm);
  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_perm);
  __Pyx_GIVEREF(__pyx_v_perm);
  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_2);
  __Pyx_GIVEREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_2 = 0;
  __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_7pymusic_IndexMap)), __pyx_t_3, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 202; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_v_imap = ((struct __pyx_obj_7pymusic_IndexMap *)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "pymusic.pyx":203
 *         cdef Buffer buf = Buffer(data)
 *         cdef IndexMap imap = IndexMap(perm, base, buf.items)
 *         cdef DataMap d = DataMap(buf, imap)             # <<<<<<<<<<<<<<
 *         cdef CContOutputPort* ptr = dc_CContOutputPort(self.ptr)
 *         mapImpl(ptr, d.ptr, maxBuffered)
 */
  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 203; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(((PyObject *)__pyx_v_buf));
  PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)__pyx_v_buf));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_buf));
  __Pyx_INCREF(((PyObject *)__pyx_v_imap));
  PyTuple_SET_ITEM(__pyx_t_1, 1, ((PyObject *)__pyx_v_imap));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_imap));
  __pyx_t_3 = __Pyx_PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_7pymusic_DataMap)), __pyx_t_1, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 203; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_d = ((struct __pyx_obj_7pymusic_DataMap *)__pyx_t_3);
  __pyx_t_3 = 0;

  /* "pymusic.pyx":204
 *         cdef IndexMap imap = IndexMap(perm, base, buf.items)
 *         cdef DataMap d = DataMap(buf, imap)
 *         cdef CContOutputPort* ptr = dc_CContOutputPort(self.ptr)             # <<<<<<<<<<<<<<
 *         mapImpl(ptr, d.ptr, maxBuffered)
 * 
 */
  __pyx_v_ptr = dynamic_cast<MUSIC::ContOutputPort*>(__pyx_v_self->__pyx_base.ptr);

  /* "pymusic.pyx":205
 *         cdef DataMap d = DataMap(buf, imap)
 *         cdef CContOutputPort* ptr = dc_CContOutputPort(self.ptr)
 *         mapImpl(ptr, d.ptr, maxBuffered)             # <<<<<<<<<<<<<<
 * 
 * cdef class EventInputPort(Port):
 */
  MUSIC::Implementer::mapImpl(__pyx_v_ptr, __pyx_v_d->ptr, __pyx_v_maxBuffered);

  /* "pymusic.pyx":184
 *     Setup.publishContOutputPort(portname).
 *     """
 *     def map(self, object data,             # <<<<<<<<<<<<<<
 *             int base=0, object perm=None,
 *             int maxBuffered=-1):
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("pymusic.ContOutputPort.map", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_buf);
  __Pyx_XDECREF((PyObject *)__pyx_v_imap);
  __Pyx_XDECREF((PyObject *)__pyx_v_d);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":217
 *     here and drop the reference when this object is null'd (events member).
 *     """
 *     def __cinit__(self):             # <<<<<<<<<<<<<<
 *         """
 *         Store a set of references to the event handlers
 */

/* Python wrapper */
static int __pyx_pw_7pymusic_14EventInputPort_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_7pymusic_14EventInputPort_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
  if (unlikely(PyTuple_GET_SIZE(__pyx_args) > 0)) {
    __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 0, 0, PyTuple_GET_SIZE(__pyx_args)); return -1;}
  if (unlikely(__pyx_kwds) && unlikely(PyDict_Size(__pyx_kwds) > 0) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "__cinit__", 0))) return -1;
  __pyx_r = __pyx_pf_7pymusic_14EventInputPort___cinit__(((struct __pyx_obj_7pymusic_EventInputPort *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_7pymusic_14EventInputPort___cinit__(struct __pyx_obj_7pymusic_EventInputPort *__pyx_v_self) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__cinit__", 0);

  /* "pymusic.pyx":221
 *         Store a set of references to the event handlers
 *         """
 *         self.events = set()             # <<<<<<<<<<<<<<
 * 
 *     cpdef null(self):
 */
  __pyx_t_1 = PySet_New(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 221; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_1);
  __Pyx_GOTREF(__pyx_v_self->events);
  __Pyx_DECREF(__pyx_v_self->events);
  __pyx_v_self->events = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "pymusic.pyx":217
 *     here and drop the reference when this object is null'd (events member).
 *     """
 *     def __cinit__(self):             # <<<<<<<<<<<<<<
 *         """
 *         Store a set of references to the event handlers
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pymusic.EventInputPort.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":223
 *         self.events = set()
 * 
 *     cpdef null(self):             # <<<<<<<<<<<<<<
 *         """
 *         Not just null pointer, but give up the associated event
 */

static PyObject *__pyx_pw_7pymusic_14EventInputPort_3null(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyObject *__pyx_f_7pymusic_14EventInputPort_null(struct __pyx_obj_7pymusic_EventInputPort *__pyx_v_self, int __pyx_skip_dispatch) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("null", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely(Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0)) {
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_null); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 223; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)__pyx_pw_7pymusic_14EventInputPort_3null)) {
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(__pyx_t_1);
      __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
      if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_3))) {
        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
        if (likely(__pyx_t_4)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
          __Pyx_INCREF(__pyx_t_4);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_3, function);
        }
      }
      if (__pyx_t_4) {
        __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 223; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      } else {
        __pyx_t_2 = __Pyx_PyObject_CallNoArg(__pyx_t_3); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 223; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      }
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_r = __pyx_t_2;
      __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      goto __pyx_L0;
    }
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  }

  /* "pymusic.pyx":228
 *         handlers.
 *         """
 *         Port.null(self)             # <<<<<<<<<<<<<<
 *         self.events = None
 * 
 */
  __pyx_t_1 = __pyx_f_7pymusic_4Port_null(((struct __pyx_obj_7pymusic_Port *)__pyx_v_self), 1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 228; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pymusic.pyx":229
 *         """
 *         Port.null(self)
 *         self.events = None             # <<<<<<<<<<<<<<
 * 
 *     def map(self, func, IndexType t,
 */
  __Pyx_INCREF(Py_None);
  __Pyx_GIVEREF(Py_None);
  __Pyx_GOTREF(__pyx_v_self->events);
  __Pyx_DECREF(__pyx_v_self->events);
  __pyx_v_self->events = ((PyObject*)Py_None);

  /* "pymusic.pyx":223
 *         self.events = set()
 * 
 *     cpdef null(self):             # <<<<<<<<<<<<<<
 *         """
 *         Not just null pointer, but give up the associated event
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("pymusic.EventInputPort.null", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_7pymusic_14EventInputPort_3null(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_7pymusic_14EventInputPort_2null[] = "\n        Not just null pointer, but give up the associated event\n        handlers.\n        ";
static PyObject *__pyx_pw_7pymusic_14EventInputPort_3null(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("null (wrapper)", 0);
  __pyx_r = __pyx_pf_7pymusic_14EventInputPort_2null(((struct __pyx_obj_7pymusic_EventInputPort *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pymusic_14EventInputPort_2null(struct __pyx_obj_7pymusic_EventInputPort *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("null", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_f_7pymusic_14EventInputPort_null(__pyx_v_self, 1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 223; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pymusic.EventInputPort.null", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":231
 *         self.events = None
 * 
 *     def map(self, func, IndexType t,             # <<<<<<<<<<<<<<
 *             double accLatency=0, int maxBuffered=-1,
 *             object perm=None, int base=-1, int size=-1):
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pymusic_14EventInputPort_5map(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_7pymusic_14EventInputPort_4map[] = "\n        Map events to this sink.\n        func is:\n          void func(double value, IndexType GLOBAL|LOCAL, int index)\n        IndexType is (?) the index type to map the incoming sources\n            passed to the func (why, if we already know this?)\n        accLatency is the delivery delay relative to calculation time\n            (? is it ? What formula are we using here?)\n        maxBuffered is ticks to buffer\n        perm, base & size are passed to IndexMap\n        ";
static PyObject *__pyx_pw_7pymusic_14EventInputPort_5map(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_func = 0;
  MUSIC::Index::Type __pyx_v_t;
  double __pyx_v_accLatency;
  int __pyx_v_maxBuffered;
  PyObject *__pyx_v_perm = 0;
  int __pyx_v_base;
  int __pyx_v_size;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("map (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_func,&__pyx_n_s_t,&__pyx_n_s_accLatency,&__pyx_n_s_maxBuffered,&__pyx_n_s_perm,&__pyx_n_s_base,&__pyx_n_s_size,0};
    PyObject* values[7] = {0,0,0,0,0,0,0};

    /* "pymusic.pyx":233
 *     def map(self, func, IndexType t,
 *             double accLatency=0, int maxBuffered=-1,
 *             object perm=None, int base=-1, int size=-1):             # <<<<<<<<<<<<<<
 *         """
 *         Map events to this sink.
 */
    values[4] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_func)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_t)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("map", 0, 2, 7, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 231; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_accLatency);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_maxBuffered);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_perm);
          if (value) { values[4] = value; kw_args--; }
        }
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_base);
          if (value) { values[5] = value; kw_args--; }
        }
        case  6:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_size);
          if (value) { values[6] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "map") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 231; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_func = values[0];
    __pyx_v_t = ((MUSIC::Index::Type)PyInt_AsLong(values[1])); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 231; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    if (values[2]) {
      __pyx_v_accLatency = __pyx_PyFloat_AsDouble(values[2]); if (unlikely((__pyx_v_accLatency == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 232; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_accLatency = ((double)0.0);
    }
    if (values[3]) {
      __pyx_v_maxBuffered = __Pyx_PyInt_As_int(values[3]); if (unlikely((__pyx_v_maxBuffered == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 232; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_maxBuffered = ((int)-1);
    }
    __pyx_v_perm = values[4];
    if (values[5]) {
      __pyx_v_base = __Pyx_PyInt_As_int(values[5]); if (unlikely((__pyx_v_base == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 233; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_base = ((int)-1);
    }
    if (values[6]) {
      __pyx_v_size = __Pyx_PyInt_As_int(values[6]); if (unlikely((__pyx_v_size == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 233; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_size = ((int)-1);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("map", 0, 2, 7, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 231; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("pymusic.EventInputPort.map", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_7pymusic_14EventInputPort_4map(((struct __pyx_obj_7pymusic_EventInputPort *)__pyx_v_self), __pyx_v_func, __pyx_v_t, __pyx_v_accLatency, __pyx_v_maxBuffered, __pyx_v_perm, __pyx_v_base, __pyx_v_size);

  /* "pymusic.pyx":231
 *         self.events = None
 * 
 *     def map(self, func, IndexType t,             # <<<<<<<<<<<<<<
 *             double accLatency=0, int maxBuffered=-1,
 *             object perm=None, int base=-1, int size=-1):
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pymusic_14EventInputPort_4map(struct __pyx_obj_7pymusic_EventInputPort *__pyx_v_self, PyObject *__pyx_v_func, MUSIC::Index::Type __pyx_v_t, double __pyx_v_accLatency, int __pyx_v_maxBuffered, PyObject *__pyx_v_perm, int __pyx_v_base, int __pyx_v_size) {
  struct __pyx_obj_7pymusic_IndexMap *__pyx_v_imap = 0;
  struct __pyx_obj_7pymusic_EventHandler *__pyx_v_eh = 0;
  MUSIC::EventInputPort *__pyx_v_ptr;
  MUSIC::EventHandlerPtr __pyx_v_hndl;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("map", 0);

  /* "pymusic.pyx":245
 *         perm, base & size are passed to IndexMap
 *         """
 *         cdef IndexMap imap = IndexMap(perm, base, size)             # <<<<<<<<<<<<<<
 *         cdef EventHandler eh = EventHandler(func, t)
 *         cdef CEventInputPort* ptr = dc_CEventInputPort(self.ptr)
 */
  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_base); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 245; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_size); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 245; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 245; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_INCREF(__pyx_v_perm);
  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_perm);
  __Pyx_GIVEREF(__pyx_v_perm);
  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_1);
  PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_t_2);
  __Pyx_GIVEREF(__pyx_t_2);
  __pyx_t_1 = 0;
  __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_7pymusic_IndexMap)), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 245; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_v_imap = ((struct __pyx_obj_7pymusic_IndexMap *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "pymusic.pyx":246
 *         """
 *         cdef IndexMap imap = IndexMap(perm, base, size)
 *         cdef EventHandler eh = EventHandler(func, t)             # <<<<<<<<<<<<<<
 *         cdef CEventInputPort* ptr = dc_CEventInputPort(self.ptr)
 *         cdef CEventHandlerPtr hndl = getEventHandlerPtr(t, eh.ptr)
 */
  __pyx_t_2 = PyInt_FromLong(__pyx_v_t); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 246; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 246; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_INCREF(__pyx_v_func);
  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_func);
  __Pyx_GIVEREF(__pyx_v_func);
  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_2);
  __Pyx_GIVEREF(__pyx_t_2);
  __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_7pymusic_EventHandler)), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 246; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_v_eh = ((struct __pyx_obj_7pymusic_EventHandler *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "pymusic.pyx":247
 *         cdef IndexMap imap = IndexMap(perm, base, size)
 *         cdef EventHandler eh = EventHandler(func, t)
 *         cdef CEventInputPort* ptr = dc_CEventInputPort(self.ptr)             # <<<<<<<<<<<<<<
 *         cdef CEventHandlerPtr hndl = getEventHandlerPtr(t, eh.ptr)
 *         mapImpl(ptr, imap.ptr, t, hndl, accLatency, maxBuffered)
 */
  __pyx_v_ptr = dynamic_cast<MUSIC::EventInputPort*>(__pyx_v_self->__pyx_base.ptr);

  /* "pymusic.pyx":248
 *         cdef EventHandler eh = EventHandler(func, t)
 *         cdef CEventInputPort* ptr = dc_CEventInputPort(self.ptr)
 *         cdef CEventHandlerPtr hndl = getEventHandlerPtr(t, eh.ptr)             # <<<<<<<<<<<<<<
 *         mapImpl(ptr, imap.ptr, t, hndl, accLatency, maxBuffered)
 *         self.events.add(eh)
 */
  __pyx_v_hndl = MUSIC::getEventHandlerPtr(__pyx_v_t, __pyx_v_eh->ptr);

  /* "pymusic.pyx":249
 *         cdef CEventInputPort* ptr = dc_CEventInputPort(self.ptr)
 *         cdef CEventHandlerPtr hndl = getEventHandlerPtr(t, eh.ptr)
 *         mapImpl(ptr, imap.ptr, t, hndl, accLatency, maxBuffered)             # <<<<<<<<<<<<<<
 *         self.events.add(eh)
 * 
 */
  MUSIC::Implementer::mapImpl(__pyx_v_ptr, __pyx_v_imap->ptr, __pyx_v_t, __pyx_v_hndl, __pyx_v_accLatency, __pyx_v_maxBuffered);

  /* "pymusic.pyx":250
 *         cdef CEventHandlerPtr hndl = getEventHandlerPtr(t, eh.ptr)
 *         mapImpl(ptr, imap.ptr, t, hndl, accLatency, maxBuffered)
 *         self.events.add(eh)             # <<<<<<<<<<<<<<
 * 
 * cdef class EventOutputPort(Port):
 */
  if (unlikely(__pyx_v_self->events == Py_None)) {
    PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%s'", "add");
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 250; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_t_4 = PySet_Add(__pyx_v_self->events, ((PyObject *)__pyx_v_eh)); if (unlikely(__pyx_t_4 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 250; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "pymusic.pyx":231
 *         self.events = None
 * 
 *     def map(self, func, IndexType t,             # <<<<<<<<<<<<<<
 *             double accLatency=0, int maxBuffered=-1,
 *             object perm=None, int base=-1, int size=-1):
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("pymusic.EventInputPort.map", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_imap);
  __Pyx_XDECREF((PyObject *)__pyx_v_eh);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":257
 *     events.
 *     """
 *     def map(self, IndexType t, int maxBuffered=-1,             # <<<<<<<<<<<<<<
 *             object perm=None, int base=-1, int size=-1):
 *         """
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pymusic_15EventOutputPort_1map(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_7pymusic_15EventOutputPort_map[] = "\n        IndexType: LOCAL/GLOBAL\n        maxBuffered: tick to buffer (why on both sides?)\n        perm, base, size: define IndexMap (see that class)\n        ";
static PyObject *__pyx_pw_7pymusic_15EventOutputPort_1map(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  MUSIC::Index::Type __pyx_v_t;
  int __pyx_v_maxBuffered;
  PyObject *__pyx_v_perm = 0;
  int __pyx_v_base;
  int __pyx_v_size;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("map (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_t,&__pyx_n_s_maxBuffered,&__pyx_n_s_perm,&__pyx_n_s_base,&__pyx_n_s_size,0};
    PyObject* values[5] = {0,0,0,0,0};

    /* "pymusic.pyx":258
 *     """
 *     def map(self, IndexType t, int maxBuffered=-1,
 *             object perm=None, int base=-1, int size=-1):             # <<<<<<<<<<<<<<
 *         """
 *         IndexType: LOCAL/GLOBAL
 */
    values[2] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_t)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_maxBuffered);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_perm);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_base);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_size);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "map") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 257; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_t = ((MUSIC::Index::Type)PyInt_AsLong(values[0])); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 257; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    if (values[1]) {
      __pyx_v_maxBuffered = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_maxBuffered == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 257; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_maxBuffered = ((int)-1);
    }
    __pyx_v_perm = values[2];
    if (values[3]) {
      __pyx_v_base = __Pyx_PyInt_As_int(values[3]); if (unlikely((__pyx_v_base == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 258; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_base = ((int)-1);
    }
    if (values[4]) {
      __pyx_v_size = __Pyx_PyInt_As_int(values[4]); if (unlikely((__pyx_v_size == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 258; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_size = ((int)-1);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("map", 0, 1, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 257; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("pymusic.EventOutputPort.map", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_7pymusic_15EventOutputPort_map(((struct __pyx_obj_7pymusic_EventOutputPort *)__pyx_v_self), __pyx_v_t, __pyx_v_maxBuffered, __pyx_v_perm, __pyx_v_base, __pyx_v_size);

  /* "pymusic.pyx":257
 *     events.
 *     """
 *     def map(self, IndexType t, int maxBuffered=-1,             # <<<<<<<<<<<<<<
 *             object perm=None, int base=-1, int size=-1):
 *         """
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pymusic_15EventOutputPort_map(struct __pyx_obj_7pymusic_EventOutputPort *__pyx_v_self, MUSIC::Index::Type __pyx_v_t, int __pyx_v_maxBuffered, PyObject *__pyx_v_perm, int __pyx_v_base, int __pyx_v_size) {
  struct __pyx_obj_7pymusic_IndexMap *__pyx_v_m = 0;
  MUSIC::EventOutputPort *__pyx_v_ptr;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("map", 0);

  /* "pymusic.pyx":264
 *         perm, base, size: define IndexMap (see that class)
 *         """
 *         cdef IndexMap m = IndexMap(perm, base, size)             # <<<<<<<<<<<<<<
 *         cdef CEventOutputPort* ptr = dc_CEventOutputPort(self.ptr)
 *         mapImpl(ptr, m.ptr, t, maxBuffered)
 */
  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_base); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 264; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_size); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 264; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = PyTuple_New(3); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 264; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_INCREF(__pyx_v_perm);
  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_perm);
  __Pyx_GIVEREF(__pyx_v_perm);
  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_1);
  PyTuple_SET_ITEM(__pyx_t_3, 2, __pyx_t_2);
  __Pyx_GIVEREF(__pyx_t_2);
  __pyx_t_1 = 0;
  __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_7pymusic_IndexMap)), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 264; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_v_m = ((struct __pyx_obj_7pymusic_IndexMap *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "pymusic.pyx":265
 *         """
 *         cdef IndexMap m = IndexMap(perm, base, size)
 *         cdef CEventOutputPort* ptr = dc_CEventOutputPort(self.ptr)             # <<<<<<<<<<<<<<
 *         mapImpl(ptr, m.ptr, t, maxBuffered)
 * 
 */
  __pyx_v_ptr = dynamic_cast<MUSIC::EventOutputPort*>(__pyx_v_self->__pyx_base.ptr);

  /* "pymusic.pyx":266
 *         cdef IndexMap m = IndexMap(perm, base, size)
 *         cdef CEventOutputPort* ptr = dc_CEventOutputPort(self.ptr)
 *         mapImpl(ptr, m.ptr, t, maxBuffered)             # <<<<<<<<<<<<<<
 * 
 *     def insertEvent(self, double time, int index, IndexType t):
 */
  MUSIC::Implementer::mapImpl(__pyx_v_ptr, __pyx_v_m->ptr, __pyx_v_t, __pyx_v_maxBuffered);

  /* "pymusic.pyx":257
 *     events.
 *     """
 *     def map(self, IndexType t, int maxBuffered=-1,             # <<<<<<<<<<<<<<
 *             object perm=None, int base=-1, int size=-1):
 *         """
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("pymusic.EventOutputPort.map", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_m);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":268
 *         mapImpl(ptr, m.ptr, t, maxBuffered)
 * 
 *     def insertEvent(self, double time, int index, IndexType t):             # <<<<<<<<<<<<<<
 *         """
 *         double time: time of event (must be during current tick)
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pymusic_15EventOutputPort_3insertEvent(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_7pymusic_15EventOutputPort_2insertEvent[] = "\n        double time: time of event (must be during current tick)\n        int index: local or global index of event\n        IndexType t: LOCAL|GLOBAL\n        ";
static PyObject *__pyx_pw_7pymusic_15EventOutputPort_3insertEvent(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  double __pyx_v_time;
  int __pyx_v_index;
  CYTHON_UNUSED MUSIC::Index::Type __pyx_v_t;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("insertEvent (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_time,&__pyx_n_s_index,&__pyx_n_s_t,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_time)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_index)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("insertEvent", 1, 3, 3, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 268; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_t)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("insertEvent", 1, 3, 3, 2); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 268; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "insertEvent") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 268; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_time = __pyx_PyFloat_AsDouble(values[0]); if (unlikely((__pyx_v_time == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 268; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_index = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_index == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 268; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_t = ((MUSIC::Index::Type)PyInt_AsLong(values[2])); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 268; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("insertEvent", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 268; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("pymusic.EventOutputPort.insertEvent", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_7pymusic_15EventOutputPort_2insertEvent(((struct __pyx_obj_7pymusic_EventOutputPort *)__pyx_v_self), __pyx_v_time, __pyx_v_index, __pyx_v_t);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pymusic_15EventOutputPort_2insertEvent(struct __pyx_obj_7pymusic_EventOutputPort *__pyx_v_self, double __pyx_v_time, int __pyx_v_index, CYTHON_UNUSED MUSIC::Index::Type __pyx_v_t) {
  MUSIC::EventOutputPort *__pyx_v_ptr;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("insertEvent", 0);

  /* "pymusic.pyx":274
 *         IndexType t: LOCAL|GLOBAL
 *         """
 *         cdef CEventOutputPort* ptr = dc_CEventOutputPort(self.ptr)             # <<<<<<<<<<<<<<
 *         insertEventImpl(ptr, time, index)
 * 
 */
  __pyx_v_ptr = dynamic_cast<MUSIC::EventOutputPort*>(__pyx_v_self->__pyx_base.ptr);

  /* "pymusic.pyx":275
 *         """
 *         cdef CEventOutputPort* ptr = dc_CEventOutputPort(self.ptr)
 *         insertEventImpl(ptr, time, index)             # <<<<<<<<<<<<<<
 * 
 * cdef class MessageInputPort(Port):
 */
  MUSIC::Implementer::insertEventImpl(__pyx_v_ptr, __pyx_v_time, __pyx_v_index);

  /* "pymusic.pyx":268
 *         mapImpl(ptr, m.ptr, t, maxBuffered)
 * 
 *     def insertEvent(self, double time, int index, IndexType t):             # <<<<<<<<<<<<<<
 *         """
 *         double time: time of event (must be during current tick)
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":285
 *     here and drop the reference when this object is null'd.
 *     """
 *     def __cinit__(self):             # <<<<<<<<<<<<<<
 *         self.events = set()
 * 
 */

/* Python wrapper */
static int __pyx_pw_7pymusic_16MessageInputPort_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_7pymusic_16MessageInputPort_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
  if (unlikely(PyTuple_GET_SIZE(__pyx_args) > 0)) {
    __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 0, 0, PyTuple_GET_SIZE(__pyx_args)); return -1;}
  if (unlikely(__pyx_kwds) && unlikely(PyDict_Size(__pyx_kwds) > 0) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "__cinit__", 0))) return -1;
  __pyx_r = __pyx_pf_7pymusic_16MessageInputPort___cinit__(((struct __pyx_obj_7pymusic_MessageInputPort *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_7pymusic_16MessageInputPort___cinit__(struct __pyx_obj_7pymusic_MessageInputPort *__pyx_v_self) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__cinit__", 0);

  /* "pymusic.pyx":286
 *     """
 *     def __cinit__(self):
 *         self.events = set()             # <<<<<<<<<<<<<<
 * 
 *     cpdef null(self):
 */
  __pyx_t_1 = PySet_New(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 286; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_1);
  __Pyx_GOTREF(__pyx_v_self->events);
  __Pyx_DECREF(__pyx_v_self->events);
  __pyx_v_self->events = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "pymusic.pyx":285
 *     here and drop the reference when this object is null'd.
 *     """
 *     def __cinit__(self):             # <<<<<<<<<<<<<<
 *         self.events = set()
 * 
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pymusic.MessageInputPort.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":288
 *         self.events = set()
 * 
 *     cpdef null(self):             # <<<<<<<<<<<<<<
 *         """
 *         Remember to remove the references to events...
 */

static PyObject *__pyx_pw_7pymusic_16MessageInputPort_3null(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyObject *__pyx_f_7pymusic_16MessageInputPort_null(struct __pyx_obj_7pymusic_MessageInputPort *__pyx_v_self, int __pyx_skip_dispatch) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("null", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely(Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0)) {
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_null); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 288; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)__pyx_pw_7pymusic_16MessageInputPort_3null)) {
      __Pyx_XDECREF(__pyx_r);
      __Pyx_INCREF(__pyx_t_1);
      __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
      if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_3))) {
        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
        if (likely(__pyx_t_4)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
          __Pyx_INCREF(__pyx_t_4);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_3, function);
        }
      }
      if (__pyx_t_4) {
        __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 288; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      } else {
        __pyx_t_2 = __Pyx_PyObject_CallNoArg(__pyx_t_3); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 288; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      }
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_r = __pyx_t_2;
      __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      goto __pyx_L0;
    }
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  }

  /* "pymusic.pyx":292
 *         Remember to remove the references to events...
 *         """
 *         Port.null(self)             # <<<<<<<<<<<<<<
 *         self.events = None
 * 
 */
  __pyx_t_1 = __pyx_f_7pymusic_4Port_null(((struct __pyx_obj_7pymusic_Port *)__pyx_v_self), 1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 292; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pymusic.pyx":293
 *         """
 *         Port.null(self)
 *         self.events = None             # <<<<<<<<<<<<<<
 * 
 *     def map(self, func, double accLatency=0, int maxBuffered=-1, bint pickled=True):
 */
  __Pyx_INCREF(Py_None);
  __Pyx_GIVEREF(Py_None);
  __Pyx_GOTREF(__pyx_v_self->events);
  __Pyx_DECREF(__pyx_v_self->events);
  __pyx_v_self->events = ((PyObject*)Py_None);

  /* "pymusic.pyx":288
 *         self.events = set()
 * 
 *     cpdef null(self):             # <<<<<<<<<<<<<<
 *         """
 *         Remember to remove the references to events...
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("pymusic.MessageInputPort.null", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_7pymusic_16MessageInputPort_3null(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_7pymusic_16MessageInputPort_2null[] = "\n        Remember to remove the references to events...\n        ";
static PyObject *__pyx_pw_7pymusic_16MessageInputPort_3null(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("null (wrapper)", 0);
  __pyx_r = __pyx_pf_7pymusic_16MessageInputPort_2null(((struct __pyx_obj_7pymusic_MessageInputPort *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pymusic_16MessageInputPort_2null(struct __pyx_obj_7pymusic_MessageInputPort *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("null", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_f_7pymusic_16MessageInputPort_null(__pyx_v_self, 1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 288; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pymusic.MessageInputPort.null", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":295
 *         self.events = None
 * 
 *     def map(self, func, double accLatency=0, int maxBuffered=-1, bint pickled=True):             # <<<<<<<<<<<<<<
 *         """
 *         The message handling function.
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pymusic_16MessageInputPort_5map(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_7pymusic_16MessageInputPort_4map[] = "\n        The message handling function.\n        func: callable object as follows\n           void func(double time, object msg):\n             time: the set insertion time of the message\n             msg: an object which may have been pickled and fed through music\n        accLatency(0): \"acceptable latency\" (\077\077?)\n        maxBuffered(-1): ticks that can be buffered (-1 means unknown\n           amount (\077\077?))\n        pickled(True): pickle objects on both ends; else, the object should be\n                       a buffer object and we'll receive a bytearray\n        ";
static PyObject *__pyx_pw_7pymusic_16MessageInputPort_5map(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_func = 0;
  double __pyx_v_accLatency;
  int __pyx_v_maxBuffered;
  int __pyx_v_pickled;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("map (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_func,&__pyx_n_s_accLatency,&__pyx_n_s_maxBuffered,&__pyx_n_s_pickled,0};
    PyObject* values[4] = {0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_func)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_accLatency);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_maxBuffered);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_pickled);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "map") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 295; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_func = values[0];
    if (values[1]) {
      __pyx_v_accLatency = __pyx_PyFloat_AsDouble(values[1]); if (unlikely((__pyx_v_accLatency == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 295; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_accLatency = ((double)0.0);
    }
    if (values[2]) {
      __pyx_v_maxBuffered = __Pyx_PyInt_As_int(values[2]); if (unlikely((__pyx_v_maxBuffered == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 295; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_maxBuffered = ((int)-1);
    }
    if (values[3]) {
      __pyx_v_pickled = __Pyx_PyObject_IsTrue(values[3]); if (unlikely((__pyx_v_pickled == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 295; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_pickled = ((int)1);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("map", 0, 1, 4, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 295; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("pymusic.MessageInputPort.map", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_7pymusic_16MessageInputPort_4map(((struct __pyx_obj_7pymusic_MessageInputPort *)__pyx_v_self), __pyx_v_func, __pyx_v_accLatency, __pyx_v_maxBuffered, __pyx_v_pickled);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pymusic_16MessageInputPort_4map(struct __pyx_obj_7pymusic_MessageInputPort *__pyx_v_self, PyObject *__pyx_v_func, double __pyx_v_accLatency, int __pyx_v_maxBuffered, int __pyx_v_pickled) {
  struct __pyx_obj_7pymusic_MessageHandler *__pyx_v_eh = 0;
  MUSIC::MessageInputPort *__pyx_v_ptr;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_t_3;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("map", 0);

  /* "pymusic.pyx":308
 *                        a buffer object and we'll receive a bytearray
 *         """
 *         cdef MessageHandler eh = MessageHandler(func, pickled)             # <<<<<<<<<<<<<<
 *         cdef CMessageInputPort* ptr = dc_CMessageInputPort(self.ptr)
 *         mapImpl(ptr, eh.ptr, accLatency, maxBuffered)
 */
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_pickled); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 308; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 308; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_func);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_func);
  __Pyx_GIVEREF(__pyx_v_func);
  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_7pymusic_MessageHandler)), __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 308; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_eh = ((struct __pyx_obj_7pymusic_MessageHandler *)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "pymusic.pyx":309
 *         """
 *         cdef MessageHandler eh = MessageHandler(func, pickled)
 *         cdef CMessageInputPort* ptr = dc_CMessageInputPort(self.ptr)             # <<<<<<<<<<<<<<
 *         mapImpl(ptr, eh.ptr, accLatency, maxBuffered)
 *         self.events.add(eh)
 */
  __pyx_v_ptr = dynamic_cast<MUSIC::MessageInputPort*>(__pyx_v_self->__pyx_base.ptr);

  /* "pymusic.pyx":310
 *         cdef MessageHandler eh = MessageHandler(func, pickled)
 *         cdef CMessageInputPort* ptr = dc_CMessageInputPort(self.ptr)
 *         mapImpl(ptr, eh.ptr, accLatency, maxBuffered)             # <<<<<<<<<<<<<<
 *         self.events.add(eh)
 * 
 */
  MUSIC::Implementer::mapImpl(__pyx_v_ptr, __pyx_v_eh->ptr, __pyx_v_accLatency, __pyx_v_maxBuffered);

  /* "pymusic.pyx":311
 *         cdef CMessageInputPort* ptr = dc_CMessageInputPort(self.ptr)
 *         mapImpl(ptr, eh.ptr, accLatency, maxBuffered)
 *         self.events.add(eh)             # <<<<<<<<<<<<<<
 * 
 * cdef class MessageOutputPort(Port):
 */
  if (unlikely(__pyx_v_self->events == Py_None)) {
    PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%s'", "add");
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 311; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_t_3 = PySet_Add(__pyx_v_self->events, ((PyObject *)__pyx_v_eh)); if (unlikely(__pyx_t_3 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 311; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "pymusic.pyx":295
 *         self.events = None
 * 
 *     def map(self, func, double accLatency=0, int maxBuffered=-1, bint pickled=True):             # <<<<<<<<<<<<<<
 *         """
 *         The message handling function.
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("pymusic.MessageInputPort.map", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_eh);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":318
 *     pickled and fed to the other end, associated with a time.
 *     """
 *     def map(self, int maxBuffered=-1, bint pickled=True):             # <<<<<<<<<<<<<<
 *         """
 *         map only sets the buffering ticks.
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pymusic_17MessageOutputPort_1map(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_7pymusic_17MessageOutputPort_map[] = "\n        map only sets the buffering ticks.\n        maxBuffered (-1): ticks to buffer (-1 means \"reasonable\" \077\077?)\n        pickled (True): whether messages objects inserted her are automatically\n                        pickled, else the object should be a buffer-type and\n                        the other end will get a bytearray.\n        ";
static PyObject *__pyx_pw_7pymusic_17MessageOutputPort_1map(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  int __pyx_v_maxBuffered;
  int __pyx_v_pickled;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("map (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_maxBuffered,&__pyx_n_s_pickled,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_maxBuffered);
          if (value) { values[0] = value; kw_args--; }
        }
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_pickled);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "map") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 318; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    if (values[0]) {
      __pyx_v_maxBuffered = __Pyx_PyInt_As_int(values[0]); if (unlikely((__pyx_v_maxBuffered == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 318; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_maxBuffered = ((int)-1);
    }
    if (values[1]) {
      __pyx_v_pickled = __Pyx_PyObject_IsTrue(values[1]); if (unlikely((__pyx_v_pickled == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 318; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_pickled = ((int)1);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("map", 0, 0, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 318; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("pymusic.MessageOutputPort.map", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_7pymusic_17MessageOutputPort_map(((struct __pyx_obj_7pymusic_MessageOutputPort *)__pyx_v_self), __pyx_v_maxBuffered, __pyx_v_pickled);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pymusic_17MessageOutputPort_map(struct __pyx_obj_7pymusic_MessageOutputPort *__pyx_v_self, int __pyx_v_maxBuffered, int __pyx_v_pickled) {
  MUSIC::MessageOutputPort *__pyx_v_ptr;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("map", 0);

  /* "pymusic.pyx":326
 *                         the other end will get a bytearray.
 *         """
 *         self.pickled = pickled             # <<<<<<<<<<<<<<
 *         cdef CMessageOutputPort* ptr = dc_CMessageOutputPort(self.ptr)
 *         mapImpl(ptr, maxBuffered)
 */
  __pyx_v_self->pickled = __pyx_v_pickled;

  /* "pymusic.pyx":327
 *         """
 *         self.pickled = pickled
 *         cdef CMessageOutputPort* ptr = dc_CMessageOutputPort(self.ptr)             # <<<<<<<<<<<<<<
 *         mapImpl(ptr, maxBuffered)
 * 
 */
  __pyx_v_ptr = dynamic_cast<MUSIC::MessageOutputPort*>(__pyx_v_self->__pyx_base.ptr);

  /* "pymusic.pyx":328
 *         self.pickled = pickled
 *         cdef CMessageOutputPort* ptr = dc_CMessageOutputPort(self.ptr)
 *         mapImpl(ptr, maxBuffered)             # <<<<<<<<<<<<<<
 * 
 *     def insertMessage(self, double time, object msg):
 */
  MUSIC::Implementer::mapImpl(__pyx_v_ptr, __pyx_v_maxBuffered);

  /* "pymusic.pyx":318
 *     pickled and fed to the other end, associated with a time.
 *     """
 *     def map(self, int maxBuffered=-1, bint pickled=True):             # <<<<<<<<<<<<<<
 *         """
 *         map only sets the buffering ticks.
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":330
 *         mapImpl(ptr, maxBuffered)
 * 
 *     def insertMessage(self, double time, object msg):             # <<<<<<<<<<<<<<
 *         """
 *         insert a python object as a message at a time during the
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pymusic_17MessageOutputPort_3insertMessage(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_7pymusic_17MessageOutputPort_2insertMessage[] = "\n        insert a python object as a message at a time during the\n        current tick.\n        time: ms times (\077\077)\n        msg: a python object that can be cPickled if self.pickled == True\n             else something that has a buffer interface.\n        ";
static PyObject *__pyx_pw_7pymusic_17MessageOutputPort_3insertMessage(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  double __pyx_v_time;
  PyObject *__pyx_v_msg = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("insertMessage (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_time,&__pyx_n_s_msg,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_time)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_msg)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("insertMessage", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 330; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "insertMessage") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 330; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_time = __pyx_PyFloat_AsDouble(values[0]); if (unlikely((__pyx_v_time == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 330; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_msg = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("insertMessage", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 330; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("pymusic.MessageOutputPort.insertMessage", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_7pymusic_17MessageOutputPort_2insertMessage(((struct __pyx_obj_7pymusic_MessageOutputPort *)__pyx_v_self), __pyx_v_time, __pyx_v_msg);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pymusic_17MessageOutputPort_2insertMessage(struct __pyx_obj_7pymusic_MessageOutputPort *__pyx_v_self, double __pyx_v_time, PyObject *__pyx_v_msg) {
  MUSIC::MessageOutputPort *__pyx_v_ptr;
  PyObject *__pyx_v_pmsg = 0;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  Py_ssize_t __pyx_t_6;
  PyObject *__pyx_t_7 = NULL;
  char *__pyx_t_8;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("insertMessage", 0);

  /* "pymusic.pyx":338
 *              else something that has a buffer interface.
 *         """
 *         cdef CMessageOutputPort* ptr = dc_CMessageOutputPort(self.ptr)             # <<<<<<<<<<<<<<
 *         cdef bytearray pmsg =                                           \
 *                 <bytearray> pickle.dumps(msg, pickle.HIGHEST_PROTOCOL)  \
 */
  __pyx_v_ptr = dynamic_cast<MUSIC::MessageOutputPort*>(__pyx_v_self->__pyx_base.ptr);

  /* "pymusic.pyx":341
 *         cdef bytearray pmsg =                                           \
 *                 <bytearray> pickle.dumps(msg, pickle.HIGHEST_PROTOCOL)  \
 *                 if self.pickled                                         \             # <<<<<<<<<<<<<<
 *                 else <bytearray> msg
 *         ptr.insertMessage(time, <char*> pmsg, len(pmsg))
 */
  if ((__pyx_v_self->pickled != 0)) {

    /* "pymusic.pyx":340
 *         cdef CMessageOutputPort* ptr = dc_CMessageOutputPort(self.ptr)
 *         cdef bytearray pmsg =                                           \
 *                 <bytearray> pickle.dumps(msg, pickle.HIGHEST_PROTOCOL)  \             # <<<<<<<<<<<<<<
 *                 if self.pickled                                         \
 *                 else <bytearray> msg
 */
    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_pickle); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 340; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_dumps); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 340; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_pickle); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 340; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_HIGHEST_PROTOCOL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 340; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_3 = NULL;
    __pyx_t_6 = 0;
    if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_3)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_3);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
        __pyx_t_6 = 1;
      }
    }
    __pyx_t_7 = PyTuple_New(2+__pyx_t_6); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 340; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_7);
    if (__pyx_t_3) {
      PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_3); __Pyx_GIVEREF(__pyx_t_3); __pyx_t_3 = NULL;
    }
    __Pyx_INCREF(__pyx_v_msg);
    PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_6, __pyx_v_msg);
    __Pyx_GIVEREF(__pyx_v_msg);
    PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_6, __pyx_t_5);
    __Pyx_GIVEREF(__pyx_t_5);
    __pyx_t_5 = 0;
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_7, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 340; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_INCREF(((PyObject*)__pyx_t_2));
    __pyx_t_1 = __pyx_t_2;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  } else {

    /* "pymusic.pyx":342
 *                 <bytearray> pickle.dumps(msg, pickle.HIGHEST_PROTOCOL)  \
 *                 if self.pickled                                         \
 *                 else <bytearray> msg             # <<<<<<<<<<<<<<
 *         ptr.insertMessage(time, <char*> pmsg, len(pmsg))
 * 
 */
    __Pyx_INCREF(((PyObject*)__pyx_v_msg));
    __pyx_t_1 = __pyx_v_msg;
  }
  __pyx_v_pmsg = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "pymusic.pyx":343
 *                 if self.pickled                                         \
 *                 else <bytearray> msg
 *         ptr.insertMessage(time, <char*> pmsg, len(pmsg))             # <<<<<<<<<<<<<<
 * 
 * ###########################################################
 */
  __pyx_t_8 = __Pyx_PyObject_AsString(__pyx_v_pmsg); if (unlikely((!__pyx_t_8) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 343; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_6 = PyObject_Length(__pyx_v_pmsg); if (unlikely(__pyx_t_6 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 343; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_ptr->insertMessage(__pyx_v_time, ((char *)__pyx_t_8), __pyx_t_6);

  /* "pymusic.pyx":330
 *         mapImpl(ptr, maxBuffered)
 * 
 *     def insertMessage(self, double time, object msg):             # <<<<<<<<<<<<<<
 *         """
 *         insert a python object as a message at a time during the
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("pymusic.MessageOutputPort.insertMessage", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_pmsg);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":357
 *     """
 * 
 *     def __cinit__(self, list argv=None, required=None):             # <<<<<<<<<<<<<<
 *         """
 *         Takes the command line arguments and the required threading
 */

/* Python wrapper */
static int __pyx_pw_7pymusic_5Setup_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_7pymusic_5Setup_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_argv = 0;
  PyObject *__pyx_v_required = 0;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_argv,&__pyx_n_s_required,0};
    PyObject* values[2] = {0,0};
    values[0] = ((PyObject*)Py_None);
    values[1] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_argv);
          if (value) { values[0] = value; kw_args--; }
        }
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_required);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 357; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_argv = ((PyObject*)values[0]);
    __pyx_v_required = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 0, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 357; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("pymusic.Setup.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_argv), (&PyList_Type), 1, "argv", 1))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 357; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_7pymusic_5Setup___cinit__(((struct __pyx_obj_7pymusic_Setup *)__pyx_v_self), __pyx_v_argv, __pyx_v_required);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_7pymusic_5Setup___cinit__(struct __pyx_obj_7pymusic_Setup *__pyx_v_self, PyObject *__pyx_v_argv, PyObject *__pyx_v_required) {
  int __pyx_v_provided;
  __pyx_t_7pymusic_Args __pyx_v_r;
  struct PyMPIIntracommObject *__pyx_v_comm = 0;
  int __pyx_v_i;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  MUSIC::Setup *__pyx_t_6;
  int __pyx_t_7;
  int __pyx_t_8;
  char const *__pyx_t_9;
  PyObject *__pyx_t_10 = NULL;
  PyObject *__pyx_t_11 = NULL;
  PyObject *__pyx_t_12 = NULL;
  PyObject *__pyx_t_13 = NULL;
  PyObject *__pyx_t_14 = NULL;
  PyObject *__pyx_t_15 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__cinit__", 0);

  /* "pymusic.pyx":372
 *         cdef int provided
 * 
 *         cdef Args r = argv_toc(argv if argv is not None             # <<<<<<<<<<<<<<
 *                                else sys.argv)
 *         try:
 */
  __pyx_t_2 = (__pyx_v_argv != ((PyObject*)Py_None));
  if ((__pyx_t_2 != 0)) {
    __Pyx_INCREF(__pyx_v_argv);
    __pyx_t_1 = __pyx_v_argv;
  } else {

    /* "pymusic.pyx":373
 * 
 *         cdef Args r = argv_toc(argv if argv is not None
 *                                else sys.argv)             # <<<<<<<<<<<<<<
 *         try:
 *             if required is None:
 */
    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_sys); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 373; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_argv); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 373; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    if (!(likely(PyList_CheckExact(__pyx_t_4))||((__pyx_t_4) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "list", Py_TYPE(__pyx_t_4)->tp_name), 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 373; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __pyx_t_1 = __pyx_t_4;
    __pyx_t_4 = 0;
  }

  /* "pymusic.pyx":372
 *         cdef int provided
 * 
 *         cdef Args r = argv_toc(argv if argv is not None             # <<<<<<<<<<<<<<
 *                                else sys.argv)
 *         try:
 */
  __pyx_v_r = __pyx_f_7pymusic_argv_toc(((PyObject*)__pyx_t_1));
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pymusic.pyx":374
 *         cdef Args r = argv_toc(argv if argv is not None
 *                                else sys.argv)
 *         try:             # <<<<<<<<<<<<<<
 *             if required is None:
 *                 self.ptr = new CSetup(r.argc, r.argv)
 */
  /*try:*/ {

    /* "pymusic.pyx":375
 *                                else sys.argv)
 *         try:
 *             if required is None:             # <<<<<<<<<<<<<<
 *                 self.ptr = new CSetup(r.argc, r.argv)
 *                 self.provided = MPI_THREAD_SINGLE
 */
    __pyx_t_2 = (__pyx_v_required == Py_None);
    __pyx_t_5 = (__pyx_t_2 != 0);
    if (__pyx_t_5) {

      /* "pymusic.pyx":376
 *         try:
 *             if required is None:
 *                 self.ptr = new CSetup(r.argc, r.argv)             # <<<<<<<<<<<<<<
 *                 self.provided = MPI_THREAD_SINGLE
 *             else:
 */
      try {
        __pyx_t_6 = new MUSIC::Setup(__pyx_v_r.argc, __pyx_v_r.argv);
      } catch(...) {
        __Pyx_CppExn2PyErr();
        {__pyx_filename = __pyx_f[0]; __pyx_lineno = 376; __pyx_clineno = __LINE__; goto __pyx_L4_error;}
      }
      __pyx_v_self->ptr = __pyx_t_6;

      /* "pymusic.pyx":377
 *             if required is None:
 *                 self.ptr = new CSetup(r.argc, r.argv)
 *                 self.provided = MPI_THREAD_SINGLE             # <<<<<<<<<<<<<<
 *             else:
 *                 self.ptr = new CSetup(r.argc, r.argv, required, &provided)
 */
      __pyx_v_self->provided = MPI_THREAD_SINGLE;
      goto __pyx_L6;
    }
    /*else*/ {

      /* "pymusic.pyx":379
 *                 self.provided = MPI_THREAD_SINGLE
 *             else:
 *                 self.ptr = new CSetup(r.argc, r.argv, required, &provided)             # <<<<<<<<<<<<<<
 *                 self.provided = provided
 *             self.argv = [r.argv[i] for i in xrange(r.argc)]
 */
      __pyx_t_7 = __Pyx_PyInt_As_int(__pyx_v_required); if (unlikely((__pyx_t_7 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 379; __pyx_clineno = __LINE__; goto __pyx_L4_error;}
      try {
        __pyx_t_6 = new MUSIC::Setup(__pyx_v_r.argc, __pyx_v_r.argv, __pyx_t_7, (&__pyx_v_provided));
      } catch(...) {
        __Pyx_CppExn2PyErr();
        {__pyx_filename = __pyx_f[0]; __pyx_lineno = 379; __pyx_clineno = __LINE__; goto __pyx_L4_error;}
      }
      __pyx_v_self->ptr = __pyx_t_6;

      /* "pymusic.pyx":380
 *             else:
 *                 self.ptr = new CSetup(r.argc, r.argv, required, &provided)
 *                 self.provided = provided             # <<<<<<<<<<<<<<
 *             self.argv = [r.argv[i] for i in xrange(r.argc)]
 *         finally:
 */
      __pyx_v_self->provided = __pyx_v_provided;
    }
    __pyx_L6:;

    /* "pymusic.pyx":381
 *                 self.ptr = new CSetup(r.argc, r.argv, required, &provided)
 *                 self.provided = provided
 *             self.argv = [r.argv[i] for i in xrange(r.argc)]             # <<<<<<<<<<<<<<
 *         finally:
 *             free(r.argv)
 */
    __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 381; __pyx_clineno = __LINE__; goto __pyx_L4_error;}
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_7 = __pyx_v_r.argc;
    for (__pyx_t_8 = 0; __pyx_t_8 < __pyx_t_7; __pyx_t_8+=1) {
      __pyx_v_i = __pyx_t_8;
      __pyx_t_4 = __Pyx_PyBytes_FromString((__pyx_v_r.argv[__pyx_v_i])); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 381; __pyx_clineno = __LINE__; goto __pyx_L4_error;}
      __Pyx_GOTREF(__pyx_t_4);
      if (unlikely(__Pyx_ListComp_Append(__pyx_t_1, (PyObject*)__pyx_t_4))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 381; __pyx_clineno = __LINE__; goto __pyx_L4_error;}
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    }
    __Pyx_GIVEREF(__pyx_t_1);
    __Pyx_GOTREF(__pyx_v_self->argv);
    __Pyx_DECREF(__pyx_v_self->argv);
    __pyx_v_self->argv = ((PyObject*)__pyx_t_1);
    __pyx_t_1 = 0;
  }

  /* "pymusic.pyx":383
 *             self.argv = [r.argv[i] for i in xrange(r.argc)]
 *         finally:
 *             free(r.argv)             # <<<<<<<<<<<<<<
 * 
 *         cdef MPI.Intracomm comm = MPI.Intracomm()
 */
  /*finally:*/ {
    /*normal exit:*/{
      free(__pyx_v_r.argv);
      goto __pyx_L5;
    }
    /*exception exit:*/{
      __pyx_L4_error:;
      __pyx_t_10 = 0; __pyx_t_11 = 0; __pyx_t_12 = 0; __pyx_t_13 = 0; __pyx_t_14 = 0; __pyx_t_15 = 0;
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
      if (PY_MAJOR_VERSION >= 3) __Pyx_ExceptionSwap(&__pyx_t_13, &__pyx_t_14, &__pyx_t_15);
      if ((PY_MAJOR_VERSION < 3) || unlikely(__Pyx_GetException(&__pyx_t_10, &__pyx_t_11, &__pyx_t_12) < 0)) __Pyx_ErrFetch(&__pyx_t_10, &__pyx_t_11, &__pyx_t_12);
      __Pyx_XGOTREF(__pyx_t_10);
      __Pyx_XGOTREF(__pyx_t_11);
      __Pyx_XGOTREF(__pyx_t_12);
      __Pyx_XGOTREF(__pyx_t_13);
      __Pyx_XGOTREF(__pyx_t_14);
      __Pyx_XGOTREF(__pyx_t_15);
      __pyx_t_7 = __pyx_lineno; __pyx_t_8 = __pyx_clineno; __pyx_t_9 = __pyx_filename;
      {
        free(__pyx_v_r.argv);
      }
      if (PY_MAJOR_VERSION >= 3) {
        __Pyx_XGIVEREF(__pyx_t_13);
        __Pyx_XGIVEREF(__pyx_t_14);
        __Pyx_XGIVEREF(__pyx_t_15);
        __Pyx_ExceptionReset(__pyx_t_13, __pyx_t_14, __pyx_t_15);
      }
      __Pyx_XGIVEREF(__pyx_t_10);
      __Pyx_XGIVEREF(__pyx_t_11);
      __Pyx_XGIVEREF(__pyx_t_12);
      __Pyx_ErrRestore(__pyx_t_10, __pyx_t_11, __pyx_t_12);
      __pyx_t_10 = 0; __pyx_t_11 = 0; __pyx_t_12 = 0; __pyx_t_13 = 0; __pyx_t_14 = 0; __pyx_t_15 = 0;
      __pyx_lineno = __pyx_t_7; __pyx_clineno = __pyx_t_8; __pyx_filename = __pyx_t_9;
      goto __pyx_L1_error;
    }
    __pyx_L5:;
  }

  /* "pymusic.pyx":385
 *             free(r.argv)
 * 
 *         cdef MPI.Intracomm comm = MPI.Intracomm()             # <<<<<<<<<<<<<<
 *         comm.ob_mpi = communicator(self.ptr)
 *         self.comm = comm
 */
  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_6mpi4py_3MPI_Intracomm)), __pyx_empty_tuple, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 385; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_comm = ((struct PyMPIIntracommObject *)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "pymusic.pyx":386
 * 
 *         cdef MPI.Intracomm comm = MPI.Intracomm()
 *         comm.ob_mpi = communicator(self.ptr)             # <<<<<<<<<<<<<<
 *         self.comm = comm
 * 
 */
  __pyx_v_comm->__pyx_base.ob_mpi = MUSIC::communicator(__pyx_v_self->ptr);

  /* "pymusic.pyx":387
 *         cdef MPI.Intracomm comm = MPI.Intracomm()
 *         comm.ob_mpi = communicator(self.ptr)
 *         self.comm = comm             # <<<<<<<<<<<<<<
 * 
 *         self.ports = set()
 */
  __Pyx_INCREF(((PyObject *)__pyx_v_comm));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_comm));
  __Pyx_GOTREF(__pyx_v_self->comm);
  __Pyx_DECREF(((PyObject *)__pyx_v_self->comm));
  __pyx_v_self->comm = __pyx_v_comm;

  /* "pymusic.pyx":389
 *         self.comm = comm
 * 
 *         self.ports = set()             # <<<<<<<<<<<<<<
 * 
 *     def __dealloc__(self):
 */
  __pyx_t_1 = PySet_New(0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 389; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_1);
  __Pyx_GOTREF(__pyx_v_self->ports);
  __Pyx_DECREF(__pyx_v_self->ports);
  __pyx_v_self->ports = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "pymusic.pyx":357
 *     """
 * 
 *     def __cinit__(self, list argv=None, required=None):             # <<<<<<<<<<<<<<
 *         """
 *         Takes the command line arguments and the required threading
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("pymusic.Setup.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_comm);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":391
 *         self.ports = set()
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         """
 *         If runtime has been made and setup is invalid, do nothing.
 */

/* Python wrapper */
static void __pyx_pw_7pymusic_5Setup_3__dealloc__(PyObject *__pyx_v_self); /*proto*/
static void __pyx_pw_7pymusic_5Setup_3__dealloc__(PyObject *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
  __pyx_pf_7pymusic_5Setup_2__dealloc__(((struct __pyx_obj_7pymusic_Setup *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

static void __pyx_pf_7pymusic_5Setup_2__dealloc__(struct __pyx_obj_7pymusic_Setup *__pyx_v_self) {
  PyObject *__pyx_v_p = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *(*__pyx_t_3)(PyObject *);
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__dealloc__", 0);

  /* "pymusic.pyx":397
 *         """
 * 
 *         if self.ptr is NULL:             # <<<<<<<<<<<<<<
 *             return
 * 
 */
  __pyx_t_1 = ((__pyx_v_self->ptr == NULL) != 0);
  if (__pyx_t_1) {

    /* "pymusic.pyx":398
 * 
 *         if self.ptr is NULL:
 *             return             # <<<<<<<<<<<<<<
 * 
 *         del self.ptr
 */
    goto __pyx_L0;
  }

  /* "pymusic.pyx":400
 *             return
 * 
 *         del self.ptr             # <<<<<<<<<<<<<<
 *         for p in self.ports:
 *             del p.ptr
 */
  delete __pyx_v_self->ptr;

  /* "pymusic.pyx":401
 * 
 *         del self.ptr
 *         for p in self.ports:             # <<<<<<<<<<<<<<
 *             del p.ptr
 *             p.null()
 */
  __pyx_t_2 = PyObject_GetIter(__pyx_v_self->ports); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 401; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = Py_TYPE(__pyx_t_2)->tp_iternext; if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 401; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  for (;;) {
    {
      __pyx_t_4 = __pyx_t_3(__pyx_t_2);
      if (unlikely(!__pyx_t_4)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else {__pyx_filename = __pyx_f[0]; __pyx_lineno = 401; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_4);
    }
    __Pyx_XDECREF_SET(__pyx_v_p, __pyx_t_4);
    __pyx_t_4 = 0;

    /* "pymusic.pyx":402
 *         del self.ptr
 *         for p in self.ports:
 *             del p.ptr             # <<<<<<<<<<<<<<
 *             p.null()
 *         self.null()
 */
    if (__Pyx_PyObject_DelAttrStr(__pyx_v_p, __pyx_n_s_ptr) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 402; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

    /* "pymusic.pyx":403
 *         for p in self.ports:
 *             del p.ptr
 *             p.null()             # <<<<<<<<<<<<<<
 *         self.null()
 * 
 */
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_p, __pyx_n_s_null); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 403; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_6 = NULL;
    if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_5))) {
      __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
      if (likely(__pyx_t_6)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
        __Pyx_INCREF(__pyx_t_6);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_5, function);
      }
    }
    if (__pyx_t_6) {
      __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_6); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 403; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    } else {
      __pyx_t_4 = __Pyx_PyObject_CallNoArg(__pyx_t_5); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 403; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    }
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

    /* "pymusic.pyx":401
 * 
 *         del self.ptr
 *         for p in self.ports:             # <<<<<<<<<<<<<<
 *             del p.ptr
 *             p.null()
 */
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "pymusic.pyx":404
 *             del p.ptr
 *             p.null()
 *         self.null()             # <<<<<<<<<<<<<<
 * 
 *     cpdef MPI.Intracomm getcomm(self):
 */
  __pyx_t_2 = ((struct __pyx_vtabstruct_7pymusic_Setup *)__pyx_v_self->__pyx_vtab)->null(__pyx_v_self); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 404; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "pymusic.pyx":391
 *         self.ports = set()
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         """
 *         If runtime has been made and setup is invalid, do nothing.
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_WriteUnraisable("pymusic.Setup.__dealloc__", __pyx_clineno, __pyx_lineno, __pyx_filename, 0);
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_p);
  __Pyx_RefNannyFinishContext();
}

/* "pymusic.pyx":406
 *         self.null()
 * 
 *     cpdef MPI.Intracomm getcomm(self):             # <<<<<<<<<<<<<<
 *         """
 *         Get an MPI communicator between the processes on this current
 */

static PyObject *__pyx_pw_7pymusic_5Setup_5getcomm(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static struct PyMPIIntracommObject *__pyx_f_7pymusic_5Setup_getcomm(struct __pyx_obj_7pymusic_Setup *__pyx_v_self, int __pyx_skip_dispatch) {
  struct PyMPIIntracommObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("getcomm", 0);
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely(Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0)) {
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_getcomm); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 406; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_1);
    if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)__pyx_pw_7pymusic_5Setup_5getcomm)) {
      __Pyx_XDECREF(((PyObject *)__pyx_r));
      __Pyx_INCREF(__pyx_t_1);
      __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
      if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_3))) {
        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
        if (likely(__pyx_t_4)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
          __Pyx_INCREF(__pyx_t_4);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_3, function);
        }
      }
      if (__pyx_t_4) {
        __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 406; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      } else {
        __pyx_t_2 = __Pyx_PyObject_CallNoArg(__pyx_t_3); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 406; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      }
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_6mpi4py_3MPI_Intracomm))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 406; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __pyx_r = ((struct PyMPIIntracommObject *)__pyx_t_2);
      __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      goto __pyx_L0;
    }
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  }

  /* "pymusic.pyx":411
 *         side of music
 *         """
 *         return self.comm             # <<<<<<<<<<<<<<
 * 
 *     cdef null(self):
 */
  __Pyx_XDECREF(((PyObject *)__pyx_r));
  __Pyx_INCREF(((PyObject *)__pyx_v_self->comm));
  __pyx_r = __pyx_v_self->comm;
  goto __pyx_L0;

  /* "pymusic.pyx":406
 *         self.null()
 * 
 *     cpdef MPI.Intracomm getcomm(self):             # <<<<<<<<<<<<<<
 *         """
 *         Get an MPI communicator between the processes on this current
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("pymusic.Setup.getcomm", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF((PyObject *)__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_7pymusic_5Setup_5getcomm(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_7pymusic_5Setup_4getcomm[] = "\n        Get an MPI communicator between the processes on this current\n        side of music\n        ";
static PyObject *__pyx_pw_7pymusic_5Setup_5getcomm(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getcomm (wrapper)", 0);
  __pyx_r = __pyx_pf_7pymusic_5Setup_4getcomm(((struct __pyx_obj_7pymusic_Setup *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pymusic_5Setup_4getcomm(struct __pyx_obj_7pymusic_Setup *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("getcomm", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = ((PyObject *)__pyx_f_7pymusic_5Setup_getcomm(__pyx_v_self, 1)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 406; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pymusic.Setup.getcomm", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":413
 *         return self.comm
 * 
 *     cdef null(self):             # <<<<<<<<<<<<<<
 *         """
 *         Invalidate this object --- called when runtime is
 */

static PyObject *__pyx_f_7pymusic_5Setup_null(struct __pyx_obj_7pymusic_Setup *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("null", 0);

  /* "pymusic.pyx":419
 *         objects and clearing references to them.
 *         """
 *         self.ptr = NULL             # <<<<<<<<<<<<<<
 *         self.comm = <MPI.Intracomm> MPI.COMM_NULL
 *         self.ports = None
 */
  __pyx_v_self->ptr = NULL;

  /* "pymusic.pyx":420
 *         """
 *         self.ptr = NULL
 *         self.comm = <MPI.Intracomm> MPI.COMM_NULL             # <<<<<<<<<<<<<<
 *         self.ports = None
 * 
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_MPI); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 420; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_COMM_NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 420; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __pyx_t_2;
  __Pyx_INCREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_GIVEREF(__pyx_t_1);
  __Pyx_GOTREF(__pyx_v_self->comm);
  __Pyx_DECREF(((PyObject *)__pyx_v_self->comm));
  __pyx_v_self->comm = ((struct PyMPIIntracommObject *)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "pymusic.pyx":421
 *         self.ptr = NULL
 *         self.comm = <MPI.Intracomm> MPI.COMM_NULL
 *         self.ports = None             # <<<<<<<<<<<<<<
 * 
 *     ####
 */
  __Pyx_INCREF(Py_None);
  __Pyx_GIVEREF(Py_None);
  __Pyx_GOTREF(__pyx_v_self->ports);
  __Pyx_DECREF(__pyx_v_self->ports);
  __pyx_v_self->ports = ((PyObject*)Py_None);

  /* "pymusic.pyx":413
 *         return self.comm
 * 
 *     cdef null(self):             # <<<<<<<<<<<<<<
 *         """
 *         Invalidate this object --- called when runtime is
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("pymusic.Setup.null", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":424
 * 
 *     ####
 *     def config(self, string var):             # <<<<<<<<<<<<<<
 *         """
 *         Get the value for var in config file.
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pymusic_5Setup_7config(PyObject *__pyx_v_self, PyObject *__pyx_arg_var); /*proto*/
static char __pyx_doc_7pymusic_5Setup_6config[] = "\n        Get the value for var in config file.\n        string var: configuration variable for current group of\n        processes, including default and inherited settings.\n        The value is returned as an int if it matches the patter,\n        otherwise a float, otherwise a string.\n        Throws UndefinedConfig error if no such variable is defined.\n        ";
static PyObject *__pyx_pw_7pymusic_5Setup_7config(PyObject *__pyx_v_self, PyObject *__pyx_arg_var) {
  std::string __pyx_v_var;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("config (wrapper)", 0);
  assert(__pyx_arg_var); {
    __pyx_v_var = __pyx_convert_string_from_py_std__string(__pyx_arg_var); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 424; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("pymusic.Setup.config", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_7pymusic_5Setup_6config(((struct __pyx_obj_7pymusic_Setup *)__pyx_v_self), ((std::string)__pyx_v_var));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pymusic_5Setup_6config(struct __pyx_obj_7pymusic_Setup *__pyx_v_self, std::string __pyx_v_var) {
  std::string __pyx_v_vs;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  int __pyx_t_10;
  double __pyx_t_11;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("config", 0);

  /* "pymusic.pyx":435
 *         cdef string vs
 * 
 *         if not self.ptr.config(var, &vs):             # <<<<<<<<<<<<<<
 *             raise UndefinedConfig(var)
 * 
 */
  __pyx_t_1 = ((!(__pyx_v_self->ptr->config(__pyx_v_var, (&__pyx_v_vs)) != 0)) != 0);
  if (__pyx_t_1) {

    /* "pymusic.pyx":436
 * 
 *         if not self.ptr.config(var, &vs):
 *             raise UndefinedConfig(var)             # <<<<<<<<<<<<<<
 * 
 *         try: return int(vs)
 */
    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_UndefinedConfig); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 436; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = __pyx_convert_PyBytes_string_to_py_std__string(__pyx_v_var); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 436; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = NULL;
    if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
      }
    }
    if (!__pyx_t_5) {
      __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_4); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 436; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_GOTREF(__pyx_t_2);
    } else {
      __pyx_t_6 = PyTuple_New(1+1); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 436; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_6);
      PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_5); __Pyx_GIVEREF(__pyx_t_5); __pyx_t_5 = NULL;
      PyTuple_SET_ITEM(__pyx_t_6, 0+1, __pyx_t_4);
      __Pyx_GIVEREF(__pyx_t_4);
      __pyx_t_4 = 0;
      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_6, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 436; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    }
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 436; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }

  /* "pymusic.pyx":438
 *             raise UndefinedConfig(var)
 * 
 *         try: return int(vs)             # <<<<<<<<<<<<<<
 *         except ValueError: pass
 * 
 */
  {
    __Pyx_ExceptionSave(&__pyx_t_7, &__pyx_t_8, &__pyx_t_9);
    __Pyx_XGOTREF(__pyx_t_7);
    __Pyx_XGOTREF(__pyx_t_8);
    __Pyx_XGOTREF(__pyx_t_9);
    /*try:*/ {
      __Pyx_XDECREF(__pyx_r);
      __pyx_t_2 = __pyx_convert_PyBytes_string_to_py_std__string(__pyx_v_vs); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 438; __pyx_clineno = __LINE__; goto __pyx_L4_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 438; __pyx_clineno = __LINE__; goto __pyx_L4_error;}
      __Pyx_GOTREF(__pyx_t_3);
      PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2);
      __Pyx_GIVEREF(__pyx_t_2);
      __pyx_t_2 = 0;
      __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)((PyObject*)(&PyInt_Type))), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 438; __pyx_clineno = __LINE__; goto __pyx_L4_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_r = __pyx_t_2;
      __pyx_t_2 = 0;
      goto __pyx_L8_try_return;
    }
    __pyx_L4_error:;
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;

    /* "pymusic.pyx":439
 * 
 *         try: return int(vs)
 *         except ValueError: pass             # <<<<<<<<<<<<<<
 * 
 *         try: return float(vs)
 */
    __pyx_t_10 = PyErr_ExceptionMatches(__pyx_builtin_ValueError);
    if (__pyx_t_10) {
      PyErr_Restore(0,0,0);
      goto __pyx_L5_exception_handled;
    }
    goto __pyx_L6_except_error;
    __pyx_L6_except_error:;
    __Pyx_XGIVEREF(__pyx_t_7);
    __Pyx_XGIVEREF(__pyx_t_8);
    __Pyx_XGIVEREF(__pyx_t_9);
    __Pyx_ExceptionReset(__pyx_t_7, __pyx_t_8, __pyx_t_9);
    goto __pyx_L1_error;
    __pyx_L8_try_return:;
    __Pyx_XGIVEREF(__pyx_t_7);
    __Pyx_XGIVEREF(__pyx_t_8);
    __Pyx_XGIVEREF(__pyx_t_9);
    __Pyx_ExceptionReset(__pyx_t_7, __pyx_t_8, __pyx_t_9);
    goto __pyx_L0;
    __pyx_L5_exception_handled:;
    __Pyx_XGIVEREF(__pyx_t_7);
    __Pyx_XGIVEREF(__pyx_t_8);
    __Pyx_XGIVEREF(__pyx_t_9);
    __Pyx_ExceptionReset(__pyx_t_7, __pyx_t_8, __pyx_t_9);
  }

  /* "pymusic.pyx":441
 *         except ValueError: pass
 * 
 *         try: return float(vs)             # <<<<<<<<<<<<<<
 *         except ValueError: pass
 * 
 */
  {
    __Pyx_ExceptionSave(&__pyx_t_9, &__pyx_t_8, &__pyx_t_7);
    __Pyx_XGOTREF(__pyx_t_9);
    __Pyx_XGOTREF(__pyx_t_8);
    __Pyx_XGOTREF(__pyx_t_7);
    /*try:*/ {
      __Pyx_XDECREF(__pyx_r);
      __pyx_t_2 = __pyx_convert_PyBytes_string_to_py_std__string(__pyx_v_vs); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 441; __pyx_clineno = __LINE__; goto __pyx_L12_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_11 = __Pyx_PyObject_AsDouble(__pyx_t_2); if (unlikely(__pyx_t_11 == ((double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 441; __pyx_clineno = __LINE__; goto __pyx_L12_error;}
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __pyx_t_2 = PyFloat_FromDouble(__pyx_t_11); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 441; __pyx_clineno = __LINE__; goto __pyx_L12_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_r = __pyx_t_2;
      __pyx_t_2 = 0;
      goto __pyx_L16_try_return;
    }
    __pyx_L12_error:;
    __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;

    /* "pymusic.pyx":442
 * 
 *         try: return float(vs)
 *         except ValueError: pass             # <<<<<<<<<<<<<<
 * 
 *         return vs
 */
    __pyx_t_10 = PyErr_ExceptionMatches(__pyx_builtin_ValueError);
    if (__pyx_t_10) {
      PyErr_Restore(0,0,0);
      goto __pyx_L13_exception_handled;
    }
    goto __pyx_L14_except_error;
    __pyx_L14_except_error:;
    __Pyx_XGIVEREF(__pyx_t_9);
    __Pyx_XGIVEREF(__pyx_t_8);
    __Pyx_XGIVEREF(__pyx_t_7);
    __Pyx_ExceptionReset(__pyx_t_9, __pyx_t_8, __pyx_t_7);
    goto __pyx_L1_error;
    __pyx_L16_try_return:;
    __Pyx_XGIVEREF(__pyx_t_9);
    __Pyx_XGIVEREF(__pyx_t_8);
    __Pyx_XGIVEREF(__pyx_t_7);
    __Pyx_ExceptionReset(__pyx_t_9, __pyx_t_8, __pyx_t_7);
    goto __pyx_L0;
    __pyx_L13_exception_handled:;
    __Pyx_XGIVEREF(__pyx_t_9);
    __Pyx_XGIVEREF(__pyx_t_8);
    __Pyx_XGIVEREF(__pyx_t_7);
    __Pyx_ExceptionReset(__pyx_t_9, __pyx_t_8, __pyx_t_7);
  }

  /* "pymusic.pyx":444
 *         except ValueError: pass
 * 
 *         return vs             # <<<<<<<<<<<<<<
 *     ####
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __pyx_convert_PyBytes_string_to_py_std__string(__pyx_v_vs); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 444; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "pymusic.pyx":424
 * 
 *     ####
 *     def config(self, string var):             # <<<<<<<<<<<<<<
 *         """
 *         Get the value for var in config file.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("pymusic.Setup.config", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":447
 *     ####
 * 
 *     def publishContInput(self, string s):             # <<<<<<<<<<<<<<
 *         """
 *         Continuous Floating point value sink
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pymusic_5Setup_9publishContInput(PyObject *__pyx_v_self, PyObject *__pyx_arg_s); /*proto*/
static char __pyx_doc_7pymusic_5Setup_8publishContInput[] = "\n        Continuous Floating point value sink\n        string s: port name for music config\n        ";
static PyObject *__pyx_pw_7pymusic_5Setup_9publishContInput(PyObject *__pyx_v_self, PyObject *__pyx_arg_s) {
  std::string __pyx_v_s;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("publishContInput (wrapper)", 0);
  assert(__pyx_arg_s); {
    __pyx_v_s = __pyx_convert_string_from_py_std__string(__pyx_arg_s); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 447; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("pymusic.Setup.publishContInput", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_7pymusic_5Setup_8publishContInput(((struct __pyx_obj_7pymusic_Setup *)__pyx_v_self), ((std::string)__pyx_v_s));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pymusic_5Setup_8publishContInput(struct __pyx_obj_7pymusic_Setup *__pyx_v_self, std::string __pyx_v_s) {
  struct __pyx_obj_7pymusic_ContInputPort *__pyx_v_p = 0;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("publishContInput", 0);

  /* "pymusic.pyx":452
 *         string s: port name for music config
 *         """
 *         cdef ContInputPort p = ContInputPort()             # <<<<<<<<<<<<<<
 *         p.ptr = self.ptr.publishContInput(s) # can't pass pointers directly to init
 *         self.ports.add(p)
 */
  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_7pymusic_ContInputPort)), __pyx_empty_tuple, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 452; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_p = ((struct __pyx_obj_7pymusic_ContInputPort *)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "pymusic.pyx":453
 *         """
 *         cdef ContInputPort p = ContInputPort()
 *         p.ptr = self.ptr.publishContInput(s) # can't pass pointers directly to init             # <<<<<<<<<<<<<<
 *         self.ports.add(p)
 *         return p
 */
  __pyx_v_p->__pyx_base.ptr = __pyx_v_self->ptr->publishContInput(__pyx_v_s);

  /* "pymusic.pyx":454
 *         cdef ContInputPort p = ContInputPort()
 *         p.ptr = self.ptr.publishContInput(s) # can't pass pointers directly to init
 *         self.ports.add(p)             # <<<<<<<<<<<<<<
 *         return p
 * 
 */
  if (unlikely(__pyx_v_self->ports == Py_None)) {
    PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%s'", "add");
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 454; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_t_2 = PySet_Add(__pyx_v_self->ports, ((PyObject *)__pyx_v_p)); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 454; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "pymusic.pyx":455
 *         p.ptr = self.ptr.publishContInput(s) # can't pass pointers directly to init
 *         self.ports.add(p)
 *         return p             # <<<<<<<<<<<<<<
 * 
 *     def publishContOutput(self, string s):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_p));
  __pyx_r = ((PyObject *)__pyx_v_p);
  goto __pyx_L0;

  /* "pymusic.pyx":447
 *     ####
 * 
 *     def publishContInput(self, string s):             # <<<<<<<<<<<<<<
 *         """
 *         Continuous Floating point value sink
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pymusic.Setup.publishContInput", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_p);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":457
 *         return p
 * 
 *     def publishContOutput(self, string s):             # <<<<<<<<<<<<<<
 *         """
 *         Continuous Floating point value source
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pymusic_5Setup_11publishContOutput(PyObject *__pyx_v_self, PyObject *__pyx_arg_s); /*proto*/
static char __pyx_doc_7pymusic_5Setup_10publishContOutput[] = "\n        Continuous Floating point value source\n        string s: port name for music config\n        ";
static PyObject *__pyx_pw_7pymusic_5Setup_11publishContOutput(PyObject *__pyx_v_self, PyObject *__pyx_arg_s) {
  std::string __pyx_v_s;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("publishContOutput (wrapper)", 0);
  assert(__pyx_arg_s); {
    __pyx_v_s = __pyx_convert_string_from_py_std__string(__pyx_arg_s); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 457; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("pymusic.Setup.publishContOutput", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_7pymusic_5Setup_10publishContOutput(((struct __pyx_obj_7pymusic_Setup *)__pyx_v_self), ((std::string)__pyx_v_s));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pymusic_5Setup_10publishContOutput(struct __pyx_obj_7pymusic_Setup *__pyx_v_self, std::string __pyx_v_s) {
  struct __pyx_obj_7pymusic_ContOutputPort *__pyx_v_p = 0;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("publishContOutput", 0);

  /* "pymusic.pyx":462
 *         string s: port name for music config
 *         """
 *         cdef ContOutputPort p = ContOutputPort()             # <<<<<<<<<<<<<<
 *         p.ptr = self.ptr.publishContOutput(s)
 *         self.ports.add(p)
 */
  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_7pymusic_ContOutputPort)), __pyx_empty_tuple, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 462; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_p = ((struct __pyx_obj_7pymusic_ContOutputPort *)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "pymusic.pyx":463
 *         """
 *         cdef ContOutputPort p = ContOutputPort()
 *         p.ptr = self.ptr.publishContOutput(s)             # <<<<<<<<<<<<<<
 *         self.ports.add(p)
 *         return p
 */
  __pyx_v_p->__pyx_base.ptr = __pyx_v_self->ptr->publishContOutput(__pyx_v_s);

  /* "pymusic.pyx":464
 *         cdef ContOutputPort p = ContOutputPort()
 *         p.ptr = self.ptr.publishContOutput(s)
 *         self.ports.add(p)             # <<<<<<<<<<<<<<
 *         return p
 * 
 */
  if (unlikely(__pyx_v_self->ports == Py_None)) {
    PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%s'", "add");
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 464; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_t_2 = PySet_Add(__pyx_v_self->ports, ((PyObject *)__pyx_v_p)); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 464; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "pymusic.pyx":465
 *         p.ptr = self.ptr.publishContOutput(s)
 *         self.ports.add(p)
 *         return p             # <<<<<<<<<<<<<<
 * 
 *     def publishEventOutput(self, string s):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_p));
  __pyx_r = ((PyObject *)__pyx_v_p);
  goto __pyx_L0;

  /* "pymusic.pyx":457
 *         return p
 * 
 *     def publishContOutput(self, string s):             # <<<<<<<<<<<<<<
 *         """
 *         Continuous Floating point value source
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pymusic.Setup.publishContOutput", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_p);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":467
 *         return p
 * 
 *     def publishEventOutput(self, string s):             # <<<<<<<<<<<<<<
 *         """
 *         Discrete boolean source
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pymusic_5Setup_13publishEventOutput(PyObject *__pyx_v_self, PyObject *__pyx_arg_s); /*proto*/
static char __pyx_doc_7pymusic_5Setup_12publishEventOutput[] = "\n        Discrete boolean source\n        string s: port name for music config\n        ";
static PyObject *__pyx_pw_7pymusic_5Setup_13publishEventOutput(PyObject *__pyx_v_self, PyObject *__pyx_arg_s) {
  std::string __pyx_v_s;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("publishEventOutput (wrapper)", 0);
  assert(__pyx_arg_s); {
    __pyx_v_s = __pyx_convert_string_from_py_std__string(__pyx_arg_s); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 467; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("pymusic.Setup.publishEventOutput", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_7pymusic_5Setup_12publishEventOutput(((struct __pyx_obj_7pymusic_Setup *)__pyx_v_self), ((std::string)__pyx_v_s));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pymusic_5Setup_12publishEventOutput(struct __pyx_obj_7pymusic_Setup *__pyx_v_self, std::string __pyx_v_s) {
  struct __pyx_obj_7pymusic_EventOutputPort *__pyx_v_p = 0;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("publishEventOutput", 0);

  /* "pymusic.pyx":472
 *         string s: port name for music config
 *         """
 *         cdef EventOutputPort p = EventOutputPort()             # <<<<<<<<<<<<<<
 *         p.ptr = self.ptr.publishEventOutput(s)
 *         self.ports.add(p)
 */
  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_7pymusic_EventOutputPort)), __pyx_empty_tuple, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 472; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_p = ((struct __pyx_obj_7pymusic_EventOutputPort *)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "pymusic.pyx":473
 *         """
 *         cdef EventOutputPort p = EventOutputPort()
 *         p.ptr = self.ptr.publishEventOutput(s)             # <<<<<<<<<<<<<<
 *         self.ports.add(p)
 *         return p
 */
  __pyx_v_p->__pyx_base.ptr = __pyx_v_self->ptr->publishEventOutput(__pyx_v_s);

  /* "pymusic.pyx":474
 *         cdef EventOutputPort p = EventOutputPort()
 *         p.ptr = self.ptr.publishEventOutput(s)
 *         self.ports.add(p)             # <<<<<<<<<<<<<<
 *         return p
 * 
 */
  if (unlikely(__pyx_v_self->ports == Py_None)) {
    PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%s'", "add");
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 474; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_t_2 = PySet_Add(__pyx_v_self->ports, ((PyObject *)__pyx_v_p)); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 474; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "pymusic.pyx":475
 *         p.ptr = self.ptr.publishEventOutput(s)
 *         self.ports.add(p)
 *         return p             # <<<<<<<<<<<<<<
 * 
 *     def publishEventInput(self, string s):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_p));
  __pyx_r = ((PyObject *)__pyx_v_p);
  goto __pyx_L0;

  /* "pymusic.pyx":467
 *         return p
 * 
 *     def publishEventOutput(self, string s):             # <<<<<<<<<<<<<<
 *         """
 *         Discrete boolean source
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pymusic.Setup.publishEventOutput", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_p);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":477
 *         return p
 * 
 *     def publishEventInput(self, string s):             # <<<<<<<<<<<<<<
 *         """
 *         Discrete boolean sink
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pymusic_5Setup_15publishEventInput(PyObject *__pyx_v_self, PyObject *__pyx_arg_s); /*proto*/
static char __pyx_doc_7pymusic_5Setup_14publishEventInput[] = "\n        Discrete boolean sink\n        string s: port name for music config\n        ";
static PyObject *__pyx_pw_7pymusic_5Setup_15publishEventInput(PyObject *__pyx_v_self, PyObject *__pyx_arg_s) {
  std::string __pyx_v_s;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("publishEventInput (wrapper)", 0);
  assert(__pyx_arg_s); {
    __pyx_v_s = __pyx_convert_string_from_py_std__string(__pyx_arg_s); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 477; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("pymusic.Setup.publishEventInput", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_7pymusic_5Setup_14publishEventInput(((struct __pyx_obj_7pymusic_Setup *)__pyx_v_self), ((std::string)__pyx_v_s));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pymusic_5Setup_14publishEventInput(struct __pyx_obj_7pymusic_Setup *__pyx_v_self, std::string __pyx_v_s) {
  struct __pyx_obj_7pymusic_EventInputPort *__pyx_v_p = 0;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("publishEventInput", 0);

  /* "pymusic.pyx":482
 *         string s: port name for music config
 *         """
 *         cdef EventInputPort p = EventInputPort()             # <<<<<<<<<<<<<<
 *         p.ptr = self.ptr.publishEventInput(s)
 *         self.ports.add(p)
 */
  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_7pymusic_EventInputPort)), __pyx_empty_tuple, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 482; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_p = ((struct __pyx_obj_7pymusic_EventInputPort *)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "pymusic.pyx":483
 *         """
 *         cdef EventInputPort p = EventInputPort()
 *         p.ptr = self.ptr.publishEventInput(s)             # <<<<<<<<<<<<<<
 *         self.ports.add(p)
 *         return p
 */
  __pyx_v_p->__pyx_base.ptr = __pyx_v_self->ptr->publishEventInput(__pyx_v_s);

  /* "pymusic.pyx":484
 *         cdef EventInputPort p = EventInputPort()
 *         p.ptr = self.ptr.publishEventInput(s)
 *         self.ports.add(p)             # <<<<<<<<<<<<<<
 *         return p
 * 
 */
  if (unlikely(__pyx_v_self->ports == Py_None)) {
    PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%s'", "add");
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 484; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_t_2 = PySet_Add(__pyx_v_self->ports, ((PyObject *)__pyx_v_p)); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 484; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "pymusic.pyx":485
 *         p.ptr = self.ptr.publishEventInput(s)
 *         self.ports.add(p)
 *         return p             # <<<<<<<<<<<<<<
 * 
 *     def publishMessageOutput(self, string s):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_p));
  __pyx_r = ((PyObject *)__pyx_v_p);
  goto __pyx_L0;

  /* "pymusic.pyx":477
 *         return p
 * 
 *     def publishEventInput(self, string s):             # <<<<<<<<<<<<<<
 *         """
 *         Discrete boolean sink
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pymusic.Setup.publishEventInput", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_p);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":487
 *         return p
 * 
 *     def publishMessageOutput(self, string s):             # <<<<<<<<<<<<<<
 *         """
 *         Discrete python object source
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pymusic_5Setup_17publishMessageOutput(PyObject *__pyx_v_self, PyObject *__pyx_arg_s); /*proto*/
static char __pyx_doc_7pymusic_5Setup_16publishMessageOutput[] = "\n        Discrete python object source\n        string s: port name for music config\n        ";
static PyObject *__pyx_pw_7pymusic_5Setup_17publishMessageOutput(PyObject *__pyx_v_self, PyObject *__pyx_arg_s) {
  std::string __pyx_v_s;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("publishMessageOutput (wrapper)", 0);
  assert(__pyx_arg_s); {
    __pyx_v_s = __pyx_convert_string_from_py_std__string(__pyx_arg_s); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 487; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("pymusic.Setup.publishMessageOutput", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_7pymusic_5Setup_16publishMessageOutput(((struct __pyx_obj_7pymusic_Setup *)__pyx_v_self), ((std::string)__pyx_v_s));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pymusic_5Setup_16publishMessageOutput(struct __pyx_obj_7pymusic_Setup *__pyx_v_self, std::string __pyx_v_s) {
  struct __pyx_obj_7pymusic_MessageOutputPort *__pyx_v_p = 0;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("publishMessageOutput", 0);

  /* "pymusic.pyx":492
 *         string s: port name for music config
 *         """
 *         cdef MessageOutputPort p = MessageOutputPort()             # <<<<<<<<<<<<<<
 *         p.ptr = self.ptr.publishMessageOutput(s)
 *         self.ports.add(p)
 */
  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_7pymusic_MessageOutputPort)), __pyx_empty_tuple, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 492; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_p = ((struct __pyx_obj_7pymusic_MessageOutputPort *)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "pymusic.pyx":493
 *         """
 *         cdef MessageOutputPort p = MessageOutputPort()
 *         p.ptr = self.ptr.publishMessageOutput(s)             # <<<<<<<<<<<<<<
 *         self.ports.add(p)
 *         return p
 */
  __pyx_v_p->__pyx_base.ptr = __pyx_v_self->ptr->publishMessageOutput(__pyx_v_s);

  /* "pymusic.pyx":494
 *         cdef MessageOutputPort p = MessageOutputPort()
 *         p.ptr = self.ptr.publishMessageOutput(s)
 *         self.ports.add(p)             # <<<<<<<<<<<<<<
 *         return p
 * 
 */
  if (unlikely(__pyx_v_self->ports == Py_None)) {
    PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%s'", "add");
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 494; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_t_2 = PySet_Add(__pyx_v_self->ports, ((PyObject *)__pyx_v_p)); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 494; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "pymusic.pyx":495
 *         p.ptr = self.ptr.publishMessageOutput(s)
 *         self.ports.add(p)
 *         return p             # <<<<<<<<<<<<<<
 * 
 *     def publishMessageInput(self, string s):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_p));
  __pyx_r = ((PyObject *)__pyx_v_p);
  goto __pyx_L0;

  /* "pymusic.pyx":487
 *         return p
 * 
 *     def publishMessageOutput(self, string s):             # <<<<<<<<<<<<<<
 *         """
 *         Discrete python object source
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pymusic.Setup.publishMessageOutput", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_p);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":497
 *         return p
 * 
 *     def publishMessageInput(self, string s):             # <<<<<<<<<<<<<<
 *         """
 *         Discrete python object sink
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pymusic_5Setup_19publishMessageInput(PyObject *__pyx_v_self, PyObject *__pyx_arg_s); /*proto*/
static char __pyx_doc_7pymusic_5Setup_18publishMessageInput[] = "\n        Discrete python object sink\n        string s: port name for music config\n        ";
static PyObject *__pyx_pw_7pymusic_5Setup_19publishMessageInput(PyObject *__pyx_v_self, PyObject *__pyx_arg_s) {
  std::string __pyx_v_s;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("publishMessageInput (wrapper)", 0);
  assert(__pyx_arg_s); {
    __pyx_v_s = __pyx_convert_string_from_py_std__string(__pyx_arg_s); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 497; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("pymusic.Setup.publishMessageInput", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_7pymusic_5Setup_18publishMessageInput(((struct __pyx_obj_7pymusic_Setup *)__pyx_v_self), ((std::string)__pyx_v_s));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pymusic_5Setup_18publishMessageInput(struct __pyx_obj_7pymusic_Setup *__pyx_v_self, std::string __pyx_v_s) {
  struct __pyx_obj_7pymusic_MessageInputPort *__pyx_v_p = 0;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("publishMessageInput", 0);

  /* "pymusic.pyx":502
 *         string s: port name for music config
 *         """
 *         cdef MessageInputPort p = MessageInputPort()             # <<<<<<<<<<<<<<
 *         p.ptr = self.ptr.publishMessageInput(s)
 *         self.ports.add(p)
 */
  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_7pymusic_MessageInputPort)), __pyx_empty_tuple, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 502; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_p = ((struct __pyx_obj_7pymusic_MessageInputPort *)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "pymusic.pyx":503
 *         """
 *         cdef MessageInputPort p = MessageInputPort()
 *         p.ptr = self.ptr.publishMessageInput(s)             # <<<<<<<<<<<<<<
 *         self.ports.add(p)
 *         return p
 */
  __pyx_v_p->__pyx_base.ptr = __pyx_v_self->ptr->publishMessageInput(__pyx_v_s);

  /* "pymusic.pyx":504
 *         cdef MessageInputPort p = MessageInputPort()
 *         p.ptr = self.ptr.publishMessageInput(s)
 *         self.ports.add(p)             # <<<<<<<<<<<<<<
 *         return p
 * 
 */
  if (unlikely(__pyx_v_self->ports == Py_None)) {
    PyErr_Format(PyExc_AttributeError, "'NoneType' object has no attribute '%s'", "add");
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 504; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_t_2 = PySet_Add(__pyx_v_self->ports, ((PyObject *)__pyx_v_p)); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 504; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "pymusic.pyx":505
 *         p.ptr = self.ptr.publishMessageInput(s)
 *         self.ports.add(p)
 *         return p             # <<<<<<<<<<<<<<
 * 
 *     def runtime(self, double timestep):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_p));
  __pyx_r = ((PyObject *)__pyx_v_p);
  goto __pyx_L0;

  /* "pymusic.pyx":497
 *         return p
 * 
 *     def publishMessageInput(self, string s):             # <<<<<<<<<<<<<<
 *         """
 *         Discrete python object sink
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pymusic.Setup.publishMessageInput", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_p);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":507
 *         return p
 * 
 *     def runtime(self, double timestep):             # <<<<<<<<<<<<<<
 *         """
 *         Create a runtime.
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pymusic_5Setup_21runtime(PyObject *__pyx_v_self, PyObject *__pyx_arg_timestep); /*proto*/
static char __pyx_doc_7pymusic_5Setup_20runtime[] = "\n        Create a runtime.\n        After return, this Setup object is invalid\n        double timestep: size of timestep (\077\077 units)\n        ";
static PyObject *__pyx_pw_7pymusic_5Setup_21runtime(PyObject *__pyx_v_self, PyObject *__pyx_arg_timestep) {
  double __pyx_v_timestep;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("runtime (wrapper)", 0);
  assert(__pyx_arg_timestep); {
    __pyx_v_timestep = __pyx_PyFloat_AsDouble(__pyx_arg_timestep); if (unlikely((__pyx_v_timestep == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 507; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("pymusic.Setup.runtime", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_7pymusic_5Setup_20runtime(((struct __pyx_obj_7pymusic_Setup *)__pyx_v_self), ((double)__pyx_v_timestep));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pymusic_5Setup_20runtime(struct __pyx_obj_7pymusic_Setup *__pyx_v_self, double __pyx_v_timestep) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("runtime", 0);

  /* "pymusic.pyx":513
 *         double timestep: size of timestep (?? units)
 *         """
 *         return Runtime(self, timestep)             # <<<<<<<<<<<<<<
 * 
 * ###########################################################
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyFloat_FromDouble(__pyx_v_timestep); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 513; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 513; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(((PyObject *)__pyx_v_self));
  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_v_self));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_7pymusic_Runtime)), __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 513; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pymusic.pyx":507
 *         return p
 * 
 *     def runtime(self, double timestep):             # <<<<<<<<<<<<<<
 *         """
 *         Create a runtime.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("pymusic.Setup.runtime", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pxd":168
 *     cdef list argv
 *     cdef int provided
 *     cdef readonly MPI.Intracomm comm             # <<<<<<<<<<<<<<
 *     cdef set ports
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pymusic_5Setup_4comm_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_7pymusic_5Setup_4comm_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pymusic_5Setup_4comm___get__(((struct __pyx_obj_7pymusic_Setup *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pymusic_5Setup_4comm___get__(struct __pyx_obj_7pymusic_Setup *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__", 0);
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_self->comm));
  __pyx_r = ((PyObject *)__pyx_v_self->comm);
  goto __pyx_L0;

  /* function exit code */
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":518
 * 
 * cdef class Runtime(object):
 *     def __cinit__(self, Setup setup, double h):             # <<<<<<<<<<<<<<
 *         self.ptr = new CRuntime(setup.ptr, h)
 *         self.ports = setup.ports
 */

/* Python wrapper */
static int __pyx_pw_7pymusic_7Runtime_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_7pymusic_7Runtime_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_7pymusic_Setup *__pyx_v_setup = 0;
  double __pyx_v_h;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_setup,&__pyx_n_s_h,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_setup)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_h)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 518; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 518; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_setup = ((struct __pyx_obj_7pymusic_Setup *)values[0]);
    __pyx_v_h = __pyx_PyFloat_AsDouble(values[1]); if (unlikely((__pyx_v_h == (double)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 518; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 518; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("pymusic.Runtime.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_setup), __pyx_ptype_7pymusic_Setup, 1, "setup", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 518; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_7pymusic_7Runtime___cinit__(((struct __pyx_obj_7pymusic_Runtime *)__pyx_v_self), __pyx_v_setup, __pyx_v_h);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_7pymusic_7Runtime___cinit__(struct __pyx_obj_7pymusic_Runtime *__pyx_v_self, struct __pyx_obj_7pymusic_Setup *__pyx_v_setup, double __pyx_v_h) {
  struct PyMPIIntracommObject *__pyx_v_comm = 0;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  MUSIC::Runtime *__pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__cinit__", 0);

  /* "pymusic.pyx":519
 * cdef class Runtime(object):
 *     def __cinit__(self, Setup setup, double h):
 *         self.ptr = new CRuntime(setup.ptr, h)             # <<<<<<<<<<<<<<
 *         self.ports = setup.ports
 *         setup.null()
 */
  try {
    __pyx_t_1 = new MUSIC::Runtime(__pyx_v_setup->ptr, __pyx_v_h);
  } catch(...) {
    __Pyx_CppExn2PyErr();
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 519; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_v_self->ptr = __pyx_t_1;

  /* "pymusic.pyx":520
 *     def __cinit__(self, Setup setup, double h):
 *         self.ptr = new CRuntime(setup.ptr, h)
 *         self.ports = setup.ports             # <<<<<<<<<<<<<<
 *         setup.null()
 * 
 */
  __pyx_t_2 = __pyx_v_setup->ports;
  __Pyx_INCREF(__pyx_t_2);
  __Pyx_GIVEREF(__pyx_t_2);
  __Pyx_GOTREF(__pyx_v_self->ports);
  __Pyx_DECREF(__pyx_v_self->ports);
  __pyx_v_self->ports = ((PyObject*)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "pymusic.pyx":521
 *         self.ptr = new CRuntime(setup.ptr, h)
 *         self.ports = setup.ports
 *         setup.null()             # <<<<<<<<<<<<<<
 * 
 *         cdef MPI.Intracomm comm = MPI.Intracomm()
 */
  __pyx_t_2 = ((struct __pyx_vtabstruct_7pymusic_Setup *)__pyx_v_setup->__pyx_vtab)->null(__pyx_v_setup); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 521; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "pymusic.pyx":523
 *         setup.null()
 * 
 *         cdef MPI.Intracomm comm = MPI.Intracomm()             # <<<<<<<<<<<<<<
 *         comm.ob_mpi = communicator(self.ptr)
 *         self.comm = comm
 */
  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_6mpi4py_3MPI_Intracomm)), __pyx_empty_tuple, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 523; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_v_comm = ((struct PyMPIIntracommObject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "pymusic.pyx":524
 * 
 *         cdef MPI.Intracomm comm = MPI.Intracomm()
 *         comm.ob_mpi = communicator(self.ptr)             # <<<<<<<<<<<<<<
 *         self.comm = comm
 * 
 */
  __pyx_v_comm->__pyx_base.ob_mpi = MUSIC::communicator(__pyx_v_self->ptr);

  /* "pymusic.pyx":525
 *         cdef MPI.Intracomm comm = MPI.Intracomm()
 *         comm.ob_mpi = communicator(self.ptr)
 *         self.comm = comm             # <<<<<<<<<<<<<<
 * 
 *     def __dealloc__(self):
 */
  __Pyx_INCREF(((PyObject *)__pyx_v_comm));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_comm));
  __Pyx_GOTREF(__pyx_v_self->comm);
  __Pyx_DECREF(((PyObject *)__pyx_v_self->comm));
  __pyx_v_self->comm = __pyx_v_comm;

  /* "pymusic.pyx":518
 * 
 * cdef class Runtime(object):
 *     def __cinit__(self, Setup setup, double h):             # <<<<<<<<<<<<<<
 *         self.ptr = new CRuntime(setup.ptr, h)
 *         self.ports = setup.ports
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("pymusic.Runtime.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_comm);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":527
 *         self.comm = comm
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         self.ptr.finalize()
 * 
 */

/* Python wrapper */
static void __pyx_pw_7pymusic_7Runtime_3__dealloc__(PyObject *__pyx_v_self); /*proto*/
static void __pyx_pw_7pymusic_7Runtime_3__dealloc__(PyObject *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
  __pyx_pf_7pymusic_7Runtime_2__dealloc__(((struct __pyx_obj_7pymusic_Runtime *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

static void __pyx_pf_7pymusic_7Runtime_2__dealloc__(struct __pyx_obj_7pymusic_Runtime *__pyx_v_self) {
  PyObject *__pyx_v_p = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *(*__pyx_t_2)(PyObject *);
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__dealloc__", 0);

  /* "pymusic.pyx":528
 * 
 *     def __dealloc__(self):
 *         self.ptr.finalize()             # <<<<<<<<<<<<<<
 * 
 *         for p in self.ports:
 */
  __pyx_v_self->ptr->finalize();

  /* "pymusic.pyx":530
 *         self.ptr.finalize()
 * 
 *         for p in self.ports:             # <<<<<<<<<<<<<<
 *             p.null()
 * 
 */
  __pyx_t_1 = PyObject_GetIter(__pyx_v_self->ports); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 530; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 530; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  for (;;) {
    {
      __pyx_t_3 = __pyx_t_2(__pyx_t_1);
      if (unlikely(!__pyx_t_3)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else {__pyx_filename = __pyx_f[0]; __pyx_lineno = 530; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_3);
    }
    __Pyx_XDECREF_SET(__pyx_v_p, __pyx_t_3);
    __pyx_t_3 = 0;

    /* "pymusic.pyx":531
 * 
 *         for p in self.ports:
 *             p.null()             # <<<<<<<<<<<<<<
 * 
 *         del self.ptr
 */
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_p, __pyx_n_s_null); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 531; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = NULL;
    if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    if (__pyx_t_5) {
      __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_5); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 531; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    } else {
      __pyx_t_3 = __Pyx_PyObject_CallNoArg(__pyx_t_4); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 531; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    }
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

    /* "pymusic.pyx":530
 *         self.ptr.finalize()
 * 
 *         for p in self.ports:             # <<<<<<<<<<<<<<
 *             p.null()
 * 
 */
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pymusic.pyx":533
 *             p.null()
 * 
 *         del self.ptr             # <<<<<<<<<<<<<<
 * 
 *     def time(self): return self.ptr.time()
 */
  delete __pyx_v_self->ptr;

  /* "pymusic.pyx":527
 *         self.comm = comm
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         self.ptr.finalize()
 * 
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_WriteUnraisable("pymusic.Runtime.__dealloc__", __pyx_clineno, __pyx_lineno, __pyx_filename, 0);
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_p);
  __Pyx_RefNannyFinishContext();
}

/* "pymusic.pyx":535
 *         del self.ptr
 * 
 *     def time(self): return self.ptr.time()             # <<<<<<<<<<<<<<
 *     def tick(self): tick(self.ptr)
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pymusic_7Runtime_5time(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyObject *__pyx_pw_7pymusic_7Runtime_5time(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("time (wrapper)", 0);
  __pyx_r = __pyx_pf_7pymusic_7Runtime_4time(((struct __pyx_obj_7pymusic_Runtime *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pymusic_7Runtime_4time(struct __pyx_obj_7pymusic_Runtime *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("time", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyFloat_FromDouble(__pyx_v_self->ptr->time()); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 535; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pymusic.Runtime.time", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":536
 * 
 *     def time(self): return self.ptr.time()
 *     def tick(self): tick(self.ptr)             # <<<<<<<<<<<<<<
 * 
 *     def __iter__(self):
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pymusic_7Runtime_7tick(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyObject *__pyx_pw_7pymusic_7Runtime_7tick(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("tick (wrapper)", 0);
  __pyx_r = __pyx_pf_7pymusic_7Runtime_6tick(((struct __pyx_obj_7pymusic_Runtime *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pymusic_7Runtime_6tick(struct __pyx_obj_7pymusic_Runtime *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  bool __pyx_t_1;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("tick", 0);
  __pyx_t_1 = MUSIC::tick(__pyx_v_self->ptr); if (unlikely(__pyx_t_1 == 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 536; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("pymusic.Runtime.tick", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}
static PyObject *__pyx_gb_7pymusic_7Runtime_10generator(__pyx_GeneratorObject *__pyx_generator, PyObject *__pyx_sent_value); /* proto */

/* "pymusic.pyx":538
 *     def tick(self): tick(self.ptr)
 * 
 *     def __iter__(self):             # <<<<<<<<<<<<<<
 *         cdef CRuntime* ptr = self.ptr
 *         while True:
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pymusic_7Runtime_9__iter__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_7pymusic_7Runtime_9__iter__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__iter__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pymusic_7Runtime_8__iter__(((struct __pyx_obj_7pymusic_Runtime *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pymusic_7Runtime_8__iter__(struct __pyx_obj_7pymusic_Runtime *__pyx_v_self) {
  struct __pyx_obj_7pymusic___pyx_scope_struct____iter__ *__pyx_cur_scope;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__iter__", 0);
  __pyx_cur_scope = (struct __pyx_obj_7pymusic___pyx_scope_struct____iter__ *)__pyx_tp_new_7pymusic___pyx_scope_struct____iter__(__pyx_ptype_7pymusic___pyx_scope_struct____iter__, __pyx_empty_tuple, NULL);
  if (unlikely(!__pyx_cur_scope)) {
    __Pyx_RefNannyFinishContext();
    return NULL;
  }
  __Pyx_GOTREF(__pyx_cur_scope);
  __pyx_cur_scope->__pyx_v_self = __pyx_v_self;
  __Pyx_INCREF((PyObject *)__pyx_cur_scope->__pyx_v_self);
  __Pyx_GIVEREF((PyObject *)__pyx_cur_scope->__pyx_v_self);
  {
    __pyx_GeneratorObject *gen = __Pyx_Generator_New((__pyx_generator_body_t) __pyx_gb_7pymusic_7Runtime_10generator, (PyObject *) __pyx_cur_scope, __pyx_n_s_iter, __pyx_n_s_Runtime___iter); if (unlikely(!gen)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 538; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_cur_scope);
    __Pyx_RefNannyFinishContext();
    return (PyObject *) gen;
  }

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("pymusic.Runtime.__iter__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __Pyx_DECREF(((PyObject *)__pyx_cur_scope));
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_gb_7pymusic_7Runtime_10generator(__pyx_GeneratorObject *__pyx_generator, PyObject *__pyx_sent_value) /* generator body */
{
  struct __pyx_obj_7pymusic___pyx_scope_struct____iter__ *__pyx_cur_scope = ((struct __pyx_obj_7pymusic___pyx_scope_struct____iter__ *)__pyx_generator->closure);
  PyObject *__pyx_r = NULL;
  MUSIC::Runtime *__pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  bool __pyx_t_3;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("None", 0);
  switch (__pyx_generator->resume_label) {
    case 0: goto __pyx_L3_first_run;
    case 1: goto __pyx_L6_resume_from_yield;
    default: /* CPython raises the right error here */
    __Pyx_RefNannyFinishContext();
    return NULL;
  }
  __pyx_L3_first_run:;
  if (unlikely(!__pyx_sent_value)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 538; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "pymusic.pyx":539
 * 
 *     def __iter__(self):
 *         cdef CRuntime* ptr = self.ptr             # <<<<<<<<<<<<<<
 *         while True:
 *             yield ptr.time()
 */
  __pyx_t_1 = __pyx_cur_scope->__pyx_v_self->ptr;
  __pyx_cur_scope->__pyx_v_ptr = __pyx_t_1;

  /* "pymusic.pyx":540
 *     def __iter__(self):
 *         cdef CRuntime* ptr = self.ptr
 *         while True:             # <<<<<<<<<<<<<<
 *             yield ptr.time()
 *             tick(ptr)
 */
  while (1) {

    /* "pymusic.pyx":541
 *         cdef CRuntime* ptr = self.ptr
 *         while True:
 *             yield ptr.time()             # <<<<<<<<<<<<<<
 *             tick(ptr)
 * 
 */
    __pyx_t_2 = PyFloat_FromDouble(__pyx_cur_scope->__pyx_v_ptr->time()); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 541; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    __Pyx_XGIVEREF(__pyx_r);
    __Pyx_RefNannyFinishContext();
    /* return from generator, yielding value */
    __pyx_generator->resume_label = 1;
    return __pyx_r;
    __pyx_L6_resume_from_yield:;
    if (unlikely(!__pyx_sent_value)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 541; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

    /* "pymusic.pyx":542
 *         while True:
 *             yield ptr.time()
 *             tick(ptr)             # <<<<<<<<<<<<<<
 * 
 * ###########################################################
 */
    __pyx_t_3 = MUSIC::tick(__pyx_cur_scope->__pyx_v_ptr); if (unlikely(__pyx_t_3 == 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 542; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }

  /* "pymusic.pyx":538
 *     def tick(self): tick(self.ptr)
 * 
 *     def __iter__(self):             # <<<<<<<<<<<<<<
 *         cdef CRuntime* ptr = self.ptr
 *         while True:
 */

  /* function exit code */
  PyErr_SetNone(PyExc_StopIteration);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("__iter__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_r);
  __pyx_generator->resume_label = -1;
  __Pyx_Generator_clear((PyObject*)__pyx_generator);
  __Pyx_RefNannyFinishContext();
  return NULL;
}

/* "pymusic.pxd":178
 * cdef class Runtime(object):
 *     cdef CRuntime* ptr
 *     cdef readonly MPI.Intracomm comm             # <<<<<<<<<<<<<<
 *     cdef set ports
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pymusic_7Runtime_4comm_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_7pymusic_7Runtime_4comm_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pymusic_7Runtime_4comm___get__(((struct __pyx_obj_7pymusic_Runtime *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pymusic_7Runtime_4comm___get__(struct __pyx_obj_7pymusic_Runtime *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__", 0);
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_self->comm));
  __pyx_r = ((PyObject *)__pyx_v_self->comm);
  goto __pyx_L0;

  /* function exit code */
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":559
 *     PermutationIndex: g = perm[l], where perm is an array
 *     """
 *     def __cinit__(self, object perm=None, int base=0, int size=-1):             # <<<<<<<<<<<<<<
 *         """
 *         Created internally
 */

/* Python wrapper */
static int __pyx_pw_7pymusic_8IndexMap_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_7pymusic_8IndexMap_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_perm = 0;
  int __pyx_v_base;
  int __pyx_v_size;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_perm,&__pyx_n_s_base,&__pyx_n_s_size,0};
    PyObject* values[3] = {0,0,0};
    values[0] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_perm);
          if (value) { values[0] = value; kw_args--; }
        }
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_base);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_size);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 559; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_perm = values[0];
    if (values[1]) {
      __pyx_v_base = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_base == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 559; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_base = ((int)0);
    }
    if (values[2]) {
      __pyx_v_size = __Pyx_PyInt_As_int(values[2]); if (unlikely((__pyx_v_size == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 559; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_size = ((int)-1);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 0, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 559; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("pymusic.IndexMap.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_7pymusic_8IndexMap___cinit__(((struct __pyx_obj_7pymusic_IndexMap *)__pyx_v_self), __pyx_v_perm, __pyx_v_base, __pyx_v_size);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_7pymusic_8IndexMap___cinit__(struct __pyx_obj_7pymusic_IndexMap *__pyx_v_self, PyObject *__pyx_v_perm, int __pyx_v_base, int __pyx_v_size) {
  arrayobject *__pyx_v_arr = 0;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  Py_ssize_t __pyx_t_6;
  PyObject *__pyx_t_7 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__cinit__", 0);

  /* "pymusic.pyx":570
 *         cdef array.array arr
 * 
 *         if perm is None:             # <<<<<<<<<<<<<<
 *             self.buf = None
 *             self.ptr = new LinearIndex(GlobalIndex(base), size)
 */
  __pyx_t_1 = (__pyx_v_perm == Py_None);
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "pymusic.pyx":571
 * 
 *         if perm is None:
 *             self.buf = None             # <<<<<<<<<<<<<<
 *             self.ptr = new LinearIndex(GlobalIndex(base), size)
 *         else:
 */
    __Pyx_INCREF(Py_None);
    __Pyx_GIVEREF(Py_None);
    __Pyx_GOTREF(__pyx_v_self->buf);
    __Pyx_DECREF(((PyObject *)__pyx_v_self->buf));
    __pyx_v_self->buf = ((struct __pyx_obj_5music_8pybuffer_Buffer *)Py_None);

    /* "pymusic.pyx":572
 *         if perm is None:
 *             self.buf = None
 *             self.ptr = new LinearIndex(GlobalIndex(base), size)             # <<<<<<<<<<<<<<
 *         else:
 *             self.buf = Buffer(perm)
 */
    __pyx_v_self->ptr = new MUSIC::LinearIndex(MUSIC::GlobalIndex(__pyx_v_base), __pyx_v_size);
    goto __pyx_L3;
  }
  /*else*/ {

    /* "pymusic.pyx":574
 *             self.ptr = new LinearIndex(GlobalIndex(base), size)
 *         else:
 *             self.buf = Buffer(perm)             # <<<<<<<<<<<<<<
 *             if self.buf.dtype.size() != sizeof(int):
 *                 arr = array('i', perm)
 */
    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 574; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_INCREF(__pyx_v_perm);
    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_perm);
    __Pyx_GIVEREF(__pyx_v_perm);
    __pyx_t_4 = __Pyx_PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_5music_8pybuffer_Buffer)), __pyx_t_3, NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 574; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_GIVEREF(__pyx_t_4);
    __Pyx_GOTREF(__pyx_v_self->buf);
    __Pyx_DECREF(((PyObject *)__pyx_v_self->buf));
    __pyx_v_self->buf = ((struct __pyx_obj_5music_8pybuffer_Buffer *)__pyx_t_4);
    __pyx_t_4 = 0;

    /* "pymusic.pyx":575
 *         else:
 *             self.buf = Buffer(perm)
 *             if self.buf.dtype.size() != sizeof(int):             # <<<<<<<<<<<<<<
 *                 arr = array('i', perm)
 *                 self.buf = Buffer(arr)
 */
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self->buf->dtype), __pyx_n_s_size); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 575; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_5 = NULL;
    if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
      }
    }
    if (__pyx_t_5) {
      __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_5); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 575; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    } else {
      __pyx_t_4 = __Pyx_PyObject_CallNoArg(__pyx_t_3); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 575; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    }
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_3 = __Pyx_PyInt_FromSize_t((sizeof(int))); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 575; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_5 = PyObject_RichCompare(__pyx_t_4, __pyx_t_3, Py_NE); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 575; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 575; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    if (__pyx_t_2) {

      /* "pymusic.pyx":576
 *             self.buf = Buffer(perm)
 *             if self.buf.dtype.size() != sizeof(int):
 *                 arr = array('i', perm)             # <<<<<<<<<<<<<<
 *                 self.buf = Buffer(arr)
 *             self.ptr = new PermutationIndex(<GlobalIndex*>
 */
      __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_array); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 576; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_4 = NULL;
      __pyx_t_6 = 0;
      if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_3))) {
        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
        if (likely(__pyx_t_4)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
          __Pyx_INCREF(__pyx_t_4);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_3, function);
          __pyx_t_6 = 1;
        }
      }
      __pyx_t_7 = PyTuple_New(2+__pyx_t_6); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 576; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_7);
      if (__pyx_t_4) {
        PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_4); __Pyx_GIVEREF(__pyx_t_4); __pyx_t_4 = NULL;
      }
      __Pyx_INCREF(__pyx_n_s_i);
      PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_6, __pyx_n_s_i);
      __Pyx_GIVEREF(__pyx_n_s_i);
      __Pyx_INCREF(__pyx_v_perm);
      PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_6, __pyx_v_perm);
      __Pyx_GIVEREF(__pyx_v_perm);
      __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_7, NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 576; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (!(likely(((__pyx_t_5) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_5, __pyx_ptype_7cpython_5array_array))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 576; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __pyx_v_arr = ((arrayobject *)__pyx_t_5);
      __pyx_t_5 = 0;

      /* "pymusic.pyx":577
 *             if self.buf.dtype.size() != sizeof(int):
 *                 arr = array('i', perm)
 *                 self.buf = Buffer(arr)             # <<<<<<<<<<<<<<
 *             self.ptr = new PermutationIndex(<GlobalIndex*>
 *                                             self.buf.pybuf.buf,
 */
      __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 577; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_INCREF(((PyObject *)__pyx_v_arr));
      PyTuple_SET_ITEM(__pyx_t_5, 0, ((PyObject *)__pyx_v_arr));
      __Pyx_GIVEREF(((PyObject *)__pyx_v_arr));
      __pyx_t_3 = __Pyx_PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_5music_8pybuffer_Buffer)), __pyx_t_5, NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 577; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_GIVEREF(__pyx_t_3);
      __Pyx_GOTREF(__pyx_v_self->buf);
      __Pyx_DECREF(((PyObject *)__pyx_v_self->buf));
      __pyx_v_self->buf = ((struct __pyx_obj_5music_8pybuffer_Buffer *)__pyx_t_3);
      __pyx_t_3 = 0;
      goto __pyx_L4;
    }
    __pyx_L4:;

    /* "pymusic.pyx":578
 *                 arr = array('i', perm)
 *                 self.buf = Buffer(arr)
 *             self.ptr = new PermutationIndex(<GlobalIndex*>             # <<<<<<<<<<<<<<
 *                                             self.buf.pybuf.buf,
 *                                             self.buf.items)
 */
    __pyx_v_self->ptr = new MUSIC::PermutationIndex(((MUSIC::GlobalIndex *)__pyx_v_self->buf->pybuf.buf), __pyx_v_self->buf->items);
  }
  __pyx_L3:;

  /* "pymusic.pyx":559
 *     PermutationIndex: g = perm[l], where perm is an array
 *     """
 *     def __cinit__(self, object perm=None, int base=0, int size=-1):             # <<<<<<<<<<<<<<
 *         """
 *         Created internally
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("pymusic.IndexMap.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_arr);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":582
 *                                             self.buf.items)
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         del self.ptr
 * 
 */

/* Python wrapper */
static void __pyx_pw_7pymusic_8IndexMap_3__dealloc__(PyObject *__pyx_v_self); /*proto*/
static void __pyx_pw_7pymusic_8IndexMap_3__dealloc__(PyObject *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
  __pyx_pf_7pymusic_8IndexMap_2__dealloc__(((struct __pyx_obj_7pymusic_IndexMap *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

static void __pyx_pf_7pymusic_8IndexMap_2__dealloc__(struct __pyx_obj_7pymusic_IndexMap *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__", 0);

  /* "pymusic.pyx":583
 * 
 *     def __dealloc__(self):
 *         del self.ptr             # <<<<<<<<<<<<<<
 * 
 * cdef class DataMap(object):
 */
  delete __pyx_v_self->ptr;

  /* "pymusic.pyx":582
 *                                             self.buf.items)
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         del self.ptr
 * 
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

/* "pymusic.pyx":591
 *     IndexMap to construct a mapping for the Cont*Port transfers.
 *     """
 *     def __cinit__(self, Buffer buf, IndexMap index_map=None, int index=0):             # <<<<<<<<<<<<<<
 *         """
 *         Maps the Buffer of a data object between local and global indices.
 */

/* Python wrapper */
static int __pyx_pw_7pymusic_7DataMap_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_7pymusic_7DataMap_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_5music_8pybuffer_Buffer *__pyx_v_buf = 0;
  struct __pyx_obj_7pymusic_IndexMap *__pyx_v_index_map = 0;
  int __pyx_v_index;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_buf,&__pyx_n_s_index_map,&__pyx_n_s_index,0};
    PyObject* values[3] = {0,0,0};
    values[1] = (PyObject *)((struct __pyx_obj_7pymusic_IndexMap *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_buf)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_index_map);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_index);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 591; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_buf = ((struct __pyx_obj_5music_8pybuffer_Buffer *)values[0]);
    __pyx_v_index_map = ((struct __pyx_obj_7pymusic_IndexMap *)values[1]);
    if (values[2]) {
      __pyx_v_index = __Pyx_PyInt_As_int(values[2]); if (unlikely((__pyx_v_index == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 591; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_index = ((int)0);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 1, 3, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 591; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("pymusic.DataMap.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_buf), __pyx_ptype_5music_8pybuffer_Buffer, 1, "buf", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 591; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_index_map), __pyx_ptype_7pymusic_IndexMap, 1, "index_map", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 591; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_pf_7pymusic_7DataMap___cinit__(((struct __pyx_obj_7pymusic_DataMap *)__pyx_v_self), __pyx_v_buf, __pyx_v_index_map, __pyx_v_index);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_7pymusic_7DataMap___cinit__(struct __pyx_obj_7pymusic_DataMap *__pyx_v_self, struct __pyx_obj_5music_8pybuffer_Buffer *__pyx_v_buf, struct __pyx_obj_7pymusic_IndexMap *__pyx_v_index_map, int __pyx_v_index) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  MUSIC::ArrayData *__pyx_t_1;
  int __pyx_t_2;
  __Pyx_RefNannySetupContext("__cinit__", 0);

  /* "pymusic.pyx":599
 *                    a linear index
 *         """
 *         self.buf = buf             # <<<<<<<<<<<<<<
 *         self.ptr = new CArrayData(buf.pybuf.buf,
 *                                   buf.dtype.ob_mpi,
 */
  __Pyx_INCREF(((PyObject *)__pyx_v_buf));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_buf));
  __Pyx_GOTREF(__pyx_v_self->buf);
  __Pyx_DECREF(((PyObject *)__pyx_v_self->buf));
  __pyx_v_self->buf = __pyx_v_buf;

  /* "pymusic.pyx":603
 *                                   buf.dtype.ob_mpi,
 *                                   index, buf.items) \
 *                    if index_map is None else \             # <<<<<<<<<<<<<<
 *                    new CArrayData(buf.pybuf.buf,
 *                                   buf.dtype.ob_mpi,
 */
  __pyx_t_2 = (((PyObject *)__pyx_v_index_map) == Py_None);
  if ((__pyx_t_2 != 0)) {

    /* "pymusic.pyx":600
 *         """
 *         self.buf = buf
 *         self.ptr = new CArrayData(buf.pybuf.buf,             # <<<<<<<<<<<<<<
 *                                   buf.dtype.ob_mpi,
 *                                   index, buf.items) \
 */
    __pyx_t_1 = new MUSIC::ArrayData(__pyx_v_buf->pybuf.buf, __pyx_v_buf->dtype->ob_mpi, __pyx_v_index, __pyx_v_buf->items);
  } else {

    /* "pymusic.pyx":604
 *                                   index, buf.items) \
 *                    if index_map is None else \
 *                    new CArrayData(buf.pybuf.buf,             # <<<<<<<<<<<<<<
 *                                   buf.dtype.ob_mpi,
 *                                   index_map.ptr)
 */
    __pyx_t_1 = new MUSIC::ArrayData(__pyx_v_buf->pybuf.buf, __pyx_v_buf->dtype->ob_mpi, __pyx_v_index_map->ptr);
  }

  /* "pymusic.pyx":600
 *         """
 *         self.buf = buf
 *         self.ptr = new CArrayData(buf.pybuf.buf,             # <<<<<<<<<<<<<<
 *                                   buf.dtype.ob_mpi,
 *                                   index, buf.items) \
 */
  __pyx_v_self->ptr = __pyx_t_1;

  /* "pymusic.pyx":591
 *     IndexMap to construct a mapping for the Cont*Port transfers.
 *     """
 *     def __cinit__(self, Buffer buf, IndexMap index_map=None, int index=0):             # <<<<<<<<<<<<<<
 *         """
 *         Maps the Buffer of a data object between local and global indices.
 */

  /* function exit code */
  __pyx_r = 0;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":608
 *                                   index_map.ptr)
 * 
 *     def __dealloc__(self): del self.ptr             # <<<<<<<<<<<<<<
 * 
 * cdef class EventHandler:
 */

/* Python wrapper */
static void __pyx_pw_7pymusic_7DataMap_3__dealloc__(PyObject *__pyx_v_self); /*proto*/
static void __pyx_pw_7pymusic_7DataMap_3__dealloc__(PyObject *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
  __pyx_pf_7pymusic_7DataMap_2__dealloc__(((struct __pyx_obj_7pymusic_DataMap *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

static void __pyx_pf_7pymusic_7DataMap_2__dealloc__(struct __pyx_obj_7pymusic_DataMap *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__", 0);
  delete __pyx_v_self->ptr;

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

/* "pymusic.pyx":616
 *     or local EventHandler object for EventInputPort
 *     """
 *     def __cinit__(self, object func, IndexType t):             # <<<<<<<<<<<<<<
 *         """
 *         func: a callable of the form
 */

/* Python wrapper */
static int __pyx_pw_7pymusic_12EventHandler_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_7pymusic_12EventHandler_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_func = 0;
  MUSIC::Index::Type __pyx_v_t;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_func,&__pyx_n_s_t,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_func)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_t)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 616; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 616; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_func = values[0];
    __pyx_v_t = ((MUSIC::Index::Type)PyInt_AsLong(values[1])); if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 616; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 616; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("pymusic.EventHandler.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_7pymusic_12EventHandler___cinit__(((struct __pyx_obj_7pymusic_EventHandler *)__pyx_v_self), __pyx_v_func, __pyx_v_t);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_7pymusic_12EventHandler___cinit__(struct __pyx_obj_7pymusic_EventHandler *__pyx_v_self, PyObject *__pyx_v_func, MUSIC::Index::Type __pyx_v_t) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  MUSIC::EventHandler *__pyx_t_1;
  __Pyx_RefNannySetupContext("__cinit__", 0);

  /* "pymusic.pyx":629
 *         self.ptr = <CEventHandler*>                \
 *                    new CEHGlobal(<PyObject*>func) \
 *                    if t == IndexGLOBAL else       \             # <<<<<<<<<<<<<<
 *                    <CEventHandler*>               \
 *                    new CEHLocal(<PyObject*>func)
 */
  if (((__pyx_v_t == MUSIC::Index::GLOBAL) != 0)) {

    /* "pymusic.pyx":627
 *               to generalize func like this??)
 *         """
 *         self.ptr = <CEventHandler*>                \             # <<<<<<<<<<<<<<
 *                    new CEHGlobal(<PyObject*>func) \
 *                    if t == IndexGLOBAL else       \
 */
    __pyx_t_1 = ((MUSIC::EventHandler *)new MUSIC::EHGlobal(((PyObject *)__pyx_v_func)));
  } else {

    /* "pymusic.pyx":630
 *                    new CEHGlobal(<PyObject*>func) \
 *                    if t == IndexGLOBAL else       \
 *                    <CEventHandler*>               \             # <<<<<<<<<<<<<<
 *                    new CEHLocal(<PyObject*>func)
 *         self.func = func
 */
    __pyx_t_1 = ((MUSIC::EventHandler *)new MUSIC::EHLocal(((PyObject *)__pyx_v_func)));
  }

  /* "pymusic.pyx":627
 *               to generalize func like this??)
 *         """
 *         self.ptr = <CEventHandler*>                \             # <<<<<<<<<<<<<<
 *                    new CEHGlobal(<PyObject*>func) \
 *                    if t == IndexGLOBAL else       \
 */
  __pyx_v_self->ptr = __pyx_t_1;

  /* "pymusic.pyx":632
 *                    <CEventHandler*>               \
 *                    new CEHLocal(<PyObject*>func)
 *         self.func = func             # <<<<<<<<<<<<<<
 * 
 *     def __dealloc__(self): del self.ptr
 */
  __Pyx_INCREF(__pyx_v_func);
  __Pyx_GIVEREF(__pyx_v_func);
  __Pyx_GOTREF(__pyx_v_self->func);
  __Pyx_DECREF(__pyx_v_self->func);
  __pyx_v_self->func = __pyx_v_func;

  /* "pymusic.pyx":616
 *     or local EventHandler object for EventInputPort
 *     """
 *     def __cinit__(self, object func, IndexType t):             # <<<<<<<<<<<<<<
 *         """
 *         func: a callable of the form
 */

  /* function exit code */
  __pyx_r = 0;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":634
 *         self.func = func
 * 
 *     def __dealloc__(self): del self.ptr             # <<<<<<<<<<<<<<
 * 
 * cdef class _Index:
 */

/* Python wrapper */
static void __pyx_pw_7pymusic_12EventHandler_3__dealloc__(PyObject *__pyx_v_self); /*proto*/
static void __pyx_pw_7pymusic_12EventHandler_3__dealloc__(PyObject *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
  __pyx_pf_7pymusic_12EventHandler_2__dealloc__(((struct __pyx_obj_7pymusic_EventHandler *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

static void __pyx_pf_7pymusic_12EventHandler_2__dealloc__(struct __pyx_obj_7pymusic_EventHandler *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__", 0);
  delete __pyx_v_self->ptr;

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

/* "pymusic.pyx":648
 *     cdef readonly dict backmap
 * 
 *     def __cinit__(self):             # <<<<<<<<<<<<<<
 *         """ SINGLETON """
 *         self.GLOBAL = IndexGLOBAL
 */

/* Python wrapper */
static int __pyx_pw_7pymusic_6_Index_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_7pymusic_6_Index_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
  if (unlikely(PyTuple_GET_SIZE(__pyx_args) > 0)) {
    __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 0, 0, PyTuple_GET_SIZE(__pyx_args)); return -1;}
  if (unlikely(__pyx_kwds) && unlikely(PyDict_Size(__pyx_kwds) > 0) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "__cinit__", 0))) return -1;
  __pyx_r = __pyx_pf_7pymusic_6_Index___cinit__(((struct __pyx_obj_7pymusic__Index *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_7pymusic_6_Index___cinit__(struct __pyx_obj_7pymusic__Index *__pyx_v_self) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__cinit__", 0);

  /* "pymusic.pyx":650
 *     def __cinit__(self):
 *         """ SINGLETON """
 *         self.GLOBAL = IndexGLOBAL             # <<<<<<<<<<<<<<
 *         self.LOCAL = IndexLOCAL
 *         self.backmap = {
 */
  __pyx_v_self->GLOBAL = MUSIC::Index::GLOBAL;

  /* "pymusic.pyx":651
 *         """ SINGLETON """
 *         self.GLOBAL = IndexGLOBAL
 *         self.LOCAL = IndexLOCAL             # <<<<<<<<<<<<<<
 *         self.backmap = {
 *             IndexGLOBAL: "GLOBAL",
 */
  __pyx_v_self->LOCAL = MUSIC::Index::LOCAL;

  /* "pymusic.pyx":652
 *         self.GLOBAL = IndexGLOBAL
 *         self.LOCAL = IndexLOCAL
 *         self.backmap = {             # <<<<<<<<<<<<<<
 *             IndexGLOBAL: "GLOBAL",
 *             IndexLOCAL: "LOCAL"
 */
  __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 652; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);

  /* "pymusic.pyx":653
 *         self.LOCAL = IndexLOCAL
 *         self.backmap = {
 *             IndexGLOBAL: "GLOBAL",             # <<<<<<<<<<<<<<
 *             IndexLOCAL: "LOCAL"
 *         };
 */
  __pyx_t_2 = PyInt_FromLong(MUSIC::Index::GLOBAL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 653; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_1, __pyx_t_2, __pyx_n_s_GLOBAL) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 652; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "pymusic.pyx":654
 *         self.backmap = {
 *             IndexGLOBAL: "GLOBAL",
 *             IndexLOCAL: "LOCAL"             # <<<<<<<<<<<<<<
 *         };
 * 
 */
  __pyx_t_2 = PyInt_FromLong(MUSIC::Index::LOCAL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 654; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_1, __pyx_t_2, __pyx_n_s_LOCAL) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 652; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "pymusic.pyx":652
 *         self.GLOBAL = IndexGLOBAL
 *         self.LOCAL = IndexLOCAL
 *         self.backmap = {             # <<<<<<<<<<<<<<
 *             IndexGLOBAL: "GLOBAL",
 *             IndexLOCAL: "LOCAL"
 */
  __Pyx_GIVEREF(__pyx_t_1);
  __Pyx_GOTREF(__pyx_v_self->backmap);
  __Pyx_DECREF(__pyx_v_self->backmap);
  __pyx_v_self->backmap = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "pymusic.pyx":648
 *     cdef readonly dict backmap
 * 
 *     def __cinit__(self):             # <<<<<<<<<<<<<<
 *         """ SINGLETON """
 *         self.GLOBAL = IndexGLOBAL
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("pymusic._Index.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":657
 *         };
 * 
 *     def tostr(self, int index):             # <<<<<<<<<<<<<<
 *         """" tostring(Index.{GLOBAL,LOCAL}) --> "{GLOBAL,LOCAL}" """
 *         return self.backmap[index]
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pymusic_6_Index_3tostr(PyObject *__pyx_v_self, PyObject *__pyx_arg_index); /*proto*/
static char __pyx_doc_7pymusic_6_Index_2tostr[] = "\" tostring(Index.{GLOBAL,LOCAL}) --> \"{GLOBAL,LOCAL}\" ";
static PyObject *__pyx_pw_7pymusic_6_Index_3tostr(PyObject *__pyx_v_self, PyObject *__pyx_arg_index) {
  int __pyx_v_index;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("tostr (wrapper)", 0);
  assert(__pyx_arg_index); {
    __pyx_v_index = __Pyx_PyInt_As_int(__pyx_arg_index); if (unlikely((__pyx_v_index == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 657; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("pymusic._Index.tostr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_7pymusic_6_Index_2tostr(((struct __pyx_obj_7pymusic__Index *)__pyx_v_self), ((int)__pyx_v_index));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pymusic_6_Index_2tostr(struct __pyx_obj_7pymusic__Index *__pyx_v_self, int __pyx_v_index) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("tostr", 0);

  /* "pymusic.pyx":659
 *     def tostr(self, int index):
 *         """" tostring(Index.{GLOBAL,LOCAL}) --> "{GLOBAL,LOCAL}" """
 *         return self.backmap[index]             # <<<<<<<<<<<<<<
 * 
 * # And here is the singleton def
 */
  __Pyx_XDECREF(__pyx_r);
  if (unlikely(__pyx_v_self->backmap == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not subscriptable");
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 659; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_index); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 659; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyDict_GetItem(__pyx_v_self->backmap, __pyx_t_1); if (unlikely(__pyx_t_2 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 659; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "pymusic.pyx":657
 *         };
 * 
 *     def tostr(self, int index):             # <<<<<<<<<<<<<<
 *         """" tostring(Index.{GLOBAL,LOCAL}) --> "{GLOBAL,LOCAL}" """
 *         return self.backmap[index]
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("pymusic._Index.tostr", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":644
 *     purposes
 *     """
 *     cdef readonly int GLOBAL             # <<<<<<<<<<<<<<
 *     cdef readonly int LOCAL
 *     cdef readonly dict backmap
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pymusic_6_Index_6GLOBAL_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_7pymusic_6_Index_6GLOBAL_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pymusic_6_Index_6GLOBAL___get__(((struct __pyx_obj_7pymusic__Index *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pymusic_6_Index_6GLOBAL___get__(struct __pyx_obj_7pymusic__Index *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__get__", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_self->GLOBAL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 644; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pymusic._Index.GLOBAL.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":645
 *     """
 *     cdef readonly int GLOBAL
 *     cdef readonly int LOCAL             # <<<<<<<<<<<<<<
 *     cdef readonly dict backmap
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pymusic_6_Index_5LOCAL_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_7pymusic_6_Index_5LOCAL_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pymusic_6_Index_5LOCAL___get__(((struct __pyx_obj_7pymusic__Index *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pymusic_6_Index_5LOCAL___get__(struct __pyx_obj_7pymusic__Index *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__get__", 0);
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_self->LOCAL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 645; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pymusic._Index.LOCAL.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":646
 *     cdef readonly int GLOBAL
 *     cdef readonly int LOCAL
 *     cdef readonly dict backmap             # <<<<<<<<<<<<<<
 * 
 *     def __cinit__(self):
 */

/* Python wrapper */
static PyObject *__pyx_pw_7pymusic_6_Index_7backmap_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_7pymusic_6_Index_7backmap_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7pymusic_6_Index_7backmap___get__(((struct __pyx_obj_7pymusic__Index *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_7pymusic_6_Index_7backmap___get__(struct __pyx_obj_7pymusic__Index *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__", 0);
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_self->backmap);
  __pyx_r = __pyx_v_self->backmap;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":664
 * Index = _Index()
 * 
 * cdef cbool EventCallback(PyObject* func,             # <<<<<<<<<<<<<<
 *                          double d,
 *                          IndexType t,
 */

bool MUSIC::EventCallback(PyObject *__pyx_v_func, double __pyx_v_d, MUSIC::Index::Type __pyx_v_t, int __pyx_v_i) {
  bool __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  Py_ssize_t __pyx_t_7;
  PyObject *__pyx_t_8 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("EventCallback", 0);

  /* "pymusic.pyx":676
 *     int i: index of event
 *     """
 *     (<object>func)(d, t, i)             # <<<<<<<<<<<<<<
 *     return True
 * 
 */
  __pyx_t_2 = PyFloat_FromDouble(__pyx_v_d); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 676; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = PyInt_FromLong(__pyx_v_t); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 676; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_i); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 676; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_INCREF(((PyObject *)__pyx_v_func));
  __pyx_t_5 = ((PyObject *)__pyx_v_func); __pyx_t_6 = NULL;
  __pyx_t_7 = 0;
  if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_5))) {
    __pyx_t_6 = PyMethod_GET_SELF(__pyx_t_5);
    if (likely(__pyx_t_6)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
      __Pyx_INCREF(__pyx_t_6);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_5, function);
      __pyx_t_7 = 1;
    }
  }
  __pyx_t_8 = PyTuple_New(3+__pyx_t_7); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 676; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_8);
  if (__pyx_t_6) {
    PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_6); __Pyx_GIVEREF(__pyx_t_6); __pyx_t_6 = NULL;
  }
  PyTuple_SET_ITEM(__pyx_t_8, 0+__pyx_t_7, __pyx_t_2);
  __Pyx_GIVEREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_8, 1+__pyx_t_7, __pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_3);
  PyTuple_SET_ITEM(__pyx_t_8, 2+__pyx_t_7, __pyx_t_4);
  __Pyx_GIVEREF(__pyx_t_4);
  __pyx_t_2 = 0;
  __pyx_t_3 = 0;
  __pyx_t_4 = 0;
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_8, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 676; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pymusic.pyx":677
 *     """
 *     (<object>func)(d, t, i)
 *     return True             # <<<<<<<<<<<<<<
 * 
 * cdef class MessageHandler:
 */
  __pyx_r = 1;
  goto __pyx_L0;

  /* "pymusic.pyx":664
 * Index = _Index()
 * 
 * cdef cbool EventCallback(PyObject* func,             # <<<<<<<<<<<<<<
 *                          double d,
 *                          IndexType t,
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("pymusic.EventCallback", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":685
 *     It may (or may not) depickle messages
 *     """
 *     def __cinit__(self, object func, bint pickled):             # <<<<<<<<<<<<<<
 *         """
 *         func: The function to be called on a message, of the form
 */

/* Python wrapper */
static int __pyx_pw_7pymusic_14MessageHandler_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_7pymusic_14MessageHandler_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_func = 0;
  int __pyx_v_pickled;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_func,&__pyx_n_s_pickled,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_func)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_pickled)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 685; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__cinit__") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 685; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_func = values[0];
    __pyx_v_pickled = __Pyx_PyObject_IsTrue(values[1]); if (unlikely((__pyx_v_pickled == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 685; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 685; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("pymusic.MessageHandler.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_7pymusic_14MessageHandler___cinit__(((struct __pyx_obj_7pymusic_MessageHandler *)__pyx_v_self), __pyx_v_func, __pyx_v_pickled);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_7pymusic_14MessageHandler___cinit__(struct __pyx_obj_7pymusic_MessageHandler *__pyx_v_self, PyObject *__pyx_v_func, int __pyx_v_pickled) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__", 0);

  /* "pymusic.pyx":693
 *         pickled: if true, the msg needs to be depickled
 *         """
 *         self.ptr = new CMHandler(<PyObject*>func, pickled)             # <<<<<<<<<<<<<<
 *         self.func = func
 * 
 */
  __pyx_v_self->ptr = new MUSIC::MHandler(((PyObject *)__pyx_v_func), __pyx_v_pickled);

  /* "pymusic.pyx":694
 *         """
 *         self.ptr = new CMHandler(<PyObject*>func, pickled)
 *         self.func = func             # <<<<<<<<<<<<<<
 * 
 *     def __dealloc__(self):  del self.ptr
 */
  __Pyx_INCREF(__pyx_v_func);
  __Pyx_GIVEREF(__pyx_v_func);
  __Pyx_GOTREF(__pyx_v_self->func);
  __Pyx_DECREF(__pyx_v_self->func);
  __pyx_v_self->func = __pyx_v_func;

  /* "pymusic.pyx":685
 *     It may (or may not) depickle messages
 *     """
 *     def __cinit__(self, object func, bint pickled):             # <<<<<<<<<<<<<<
 *         """
 *         func: The function to be called on a message, of the form
 */

  /* function exit code */
  __pyx_r = 0;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pymusic.pyx":696
 *         self.func = func
 * 
 *     def __dealloc__(self):  del self.ptr             # <<<<<<<<<<<<<<
 * 
 * cdef cbool MessageCallback(PyObject* func,
 */

/* Python wrapper */
static void __pyx_pw_7pymusic_14MessageHandler_3__dealloc__(PyObject *__pyx_v_self); /*proto*/
static void __pyx_pw_7pymusic_14MessageHandler_3__dealloc__(PyObject *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
  __pyx_pf_7pymusic_14MessageHandler_2__dealloc__(((struct __pyx_obj_7pymusic_MessageHandler *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

static void __pyx_pf_7pymusic_14MessageHandler_2__dealloc__(struct __pyx_obj_7pymusic_MessageHandler *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__", 0);
  delete __pyx_v_self->ptr;

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

/* "pymusic.pyx":698
 *     def __dealloc__(self):  del self.ptr
 * 
 * cdef cbool MessageCallback(PyObject* func,             # <<<<<<<<<<<<<<
 *                            double t,
 *                            void* msg,
 */

bool MUSIC::MessageCallback(PyObject *__pyx_v_func, double __pyx_v_t, void *__pyx_v_msg, size_t __pyx_v_s, bool __pyx_v_pickled) {
  PyObject *__pyx_v_pobj = 0;
  PyObject *__pyx_v_obj = 0;
  bool __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  Py_ssize_t __pyx_t_6;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("MessageCallback", 0);

  /* "pymusic.pyx":712
 *               or simply a bytearray of data (you figure out the source)
 *     """
 *     cdef str pobj = (<char*>msg)[:s]             # <<<<<<<<<<<<<<
 *     cdef object obj = pickle.loads(pobj) if pickled else <bytearray> pobj
 *     (<object>func)(t, obj)
 */
  __pyx_t_1 = __Pyx_PyStr_FromStringAndSize(((char *)__pyx_v_msg) + 0, __pyx_v_s - 0); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 712; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_pobj = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "pymusic.pyx":713
 *     """
 *     cdef str pobj = (<char*>msg)[:s]
 *     cdef object obj = pickle.loads(pobj) if pickled else <bytearray> pobj             # <<<<<<<<<<<<<<
 *     (<object>func)(t, obj)
 *     return True
 */
  if ((__pyx_v_pickled != 0)) {
    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_pickle); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 713; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_loads); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 713; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_3 = NULL;
    if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_3)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_3);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    if (!__pyx_t_3) {
      __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_v_pobj); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 713; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_2);
    } else {
      __pyx_t_5 = PyTuple_New(1+1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 713; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_3); __Pyx_GIVEREF(__pyx_t_3); __pyx_t_3 = NULL;
      __Pyx_INCREF(__pyx_v_pobj);
      PyTuple_SET_ITEM(__pyx_t_5, 0+1, __pyx_v_pobj);
      __Pyx_GIVEREF(__pyx_v_pobj);
      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_5, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 713; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    }
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_1 = __pyx_t_2;
    __pyx_t_2 = 0;
  } else {
    __Pyx_INCREF(((PyObject*)__pyx_v_pobj));
    __pyx_t_1 = __pyx_v_pobj;
  }
  __pyx_v_obj = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "pymusic.pyx":714
 *     cdef str pobj = (<char*>msg)[:s]
 *     cdef object obj = pickle.loads(pobj) if pickled else <bytearray> pobj
 *     (<object>func)(t, obj)             # <<<<<<<<<<<<<<
 *     return True
 * 
 */
  __pyx_t_2 = PyFloat_FromDouble(__pyx_v_t); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 714; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(((PyObject *)__pyx_v_func));
  __pyx_t_4 = ((PyObject *)__pyx_v_func); __pyx_t_5 = NULL;
  __pyx_t_6 = 0;
  if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_4))) {
    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
    if (likely(__pyx_t_5)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
      __Pyx_INCREF(__pyx_t_5);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_4, function);
      __pyx_t_6 = 1;
    }
  }
  __pyx_t_3 = PyTuple_New(2+__pyx_t_6); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 714; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  if (__pyx_t_5) {
    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_5); __Pyx_GIVEREF(__pyx_t_5); __pyx_t_5 = NULL;
  }
  PyTuple_SET_ITEM(__pyx_t_3, 0+__pyx_t_6, __pyx_t_2);
  __Pyx_GIVEREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_v_obj);
  PyTuple_SET_ITEM(__pyx_t_3, 1+__pyx_t_6, __pyx_v_obj);
  __Pyx_GIVEREF(__pyx_v_obj);
  __pyx_t_2 = 0;
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_3, NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 714; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pymusic.pyx":715
 *     cdef object obj = pickle.loads(pobj) if pickled else <bytearray> pobj
 *     (<object>func)(t, obj)
 *     return True             # <<<<<<<<<<<<<<
 * 
 * #############################################################################
 */
  __pyx_r = 1;
  goto __pyx_L0;

  /* "pymusic.pyx":698
 *     def __dealloc__(self):  del self.ptr
 * 
 * cdef cbool MessageCallback(PyObject* func,             # <<<<<<<<<<<<<<
 *                            double t,
 *                            void* msg,
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("pymusic.MessageCallback", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_pobj);
  __Pyx_XDECREF(__pyx_v_obj);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "array.pxd":91
 *             __data_union data
 * 
 *         def __getbuffer__(self, Py_buffer* info, int flags):             # <<<<<<<<<<<<<<
 *             # This implementation of getbuffer is geared towards Cython
 *             # requirements, and does not yet fullfill the PEP.
 */

/* Python wrapper */
static CYTHON_UNUSED int __pyx_pw_7cpython_5array_5array_1__getbuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /*proto*/
static CYTHON_UNUSED int __pyx_pw_7cpython_5array_5array_1__getbuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__getbuffer__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7cpython_5array_5array___getbuffer__(((arrayobject *)__pyx_v_self), ((Py_buffer *)__pyx_v_info), ((int)__pyx_v_flags));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_7cpython_5array_5array___getbuffer__(arrayobject *__pyx_v_self, Py_buffer *__pyx_v_info, CYTHON_UNUSED int __pyx_v_flags) {
  PyObject *__pyx_v_item_count = NULL;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  char *__pyx_t_2;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  Py_ssize_t __pyx_t_5;
  int __pyx_t_6;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__getbuffer__", 0);
  if (__pyx_v_info != NULL) {
    __pyx_v_info->obj = Py_None; __Pyx_INCREF(Py_None);
    __Pyx_GIVEREF(__pyx_v_info->obj);
  }

  /* "array.pxd":96
 *             # In particular strided access is always provided regardless
 *             # of flags
 *             item_count = Py_SIZE(self)             # <<<<<<<<<<<<<<
 * 
 *             info.suboffsets = NULL
 */
  __pyx_t_1 = PyInt_FromSsize_t(Py_SIZE(((PyObject *)__pyx_v_self))); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 96; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_item_count = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "array.pxd":98
 *             item_count = Py_SIZE(self)
 * 
 *             info.suboffsets = NULL             # <<<<<<<<<<<<<<
 *             info.buf = self.data.as_chars
 *             info.readonly = 0
 */
  __pyx_v_info->suboffsets = NULL;

  /* "array.pxd":99
 * 
 *             info.suboffsets = NULL
 *             info.buf = self.data.as_chars             # <<<<<<<<<<<<<<
 *             info.readonly = 0
 *             info.ndim = 1
 */
  __pyx_t_2 = __pyx_v_self->data.as_chars;
  __pyx_v_info->buf = __pyx_t_2;

  /* "array.pxd":100
 *             info.suboffsets = NULL
 *             info.buf = self.data.as_chars
 *             info.readonly = 0             # <<<<<<<<<<<<<<
 *             info.ndim = 1
 *             info.itemsize = self.ob_descr.itemsize   # e.g. sizeof(float)
 */
  __pyx_v_info->readonly = 0;

  /* "array.pxd":101
 *             info.buf = self.data.as_chars
 *             info.readonly = 0
 *             info.ndim = 1             # <<<<<<<<<<<<<<
 *             info.itemsize = self.ob_descr.itemsize   # e.g. sizeof(float)
 *             info.len = info.itemsize * item_count
 */
  __pyx_v_info->ndim = 1;

  /* "array.pxd":102
 *             info.readonly = 0
 *             info.ndim = 1
 *             info.itemsize = self.ob_descr.itemsize   # e.g. sizeof(float)             # <<<<<<<<<<<<<<
 *             info.len = info.itemsize * item_count
 * 
 */
  __pyx_t_3 = __pyx_v_self->ob_descr->itemsize;
  __pyx_v_info->itemsize = __pyx_t_3;

  /* "array.pxd":103
 *             info.ndim = 1
 *             info.itemsize = self.ob_descr.itemsize   # e.g. sizeof(float)
 *             info.len = info.itemsize * item_count             # <<<<<<<<<<<<<<
 * 
 *             info.shape = <Py_ssize_t*> PyMem_Malloc(sizeof(Py_ssize_t) + 2)
 */
  __pyx_t_1 = PyInt_FromSsize_t(__pyx_v_info->itemsize); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 103; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_4 = PyNumber_Multiply(__pyx_t_1, __pyx_v_item_count); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 103; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_5 = __Pyx_PyIndex_AsSsize_t(__pyx_t_4); if (unlikely((__pyx_t_5 == (Py_ssize_t)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 103; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_v_info->len = __pyx_t_5;

  /* "array.pxd":105
 *             info.len = info.itemsize * item_count
 * 
 *             info.shape = <Py_ssize_t*> PyMem_Malloc(sizeof(Py_ssize_t) + 2)             # <<<<<<<<<<<<<<
 *             if not info.shape:
 *                 raise MemoryError()
 */
  __pyx_v_info->shape = ((Py_ssize_t *)PyMem_Malloc(((sizeof(Py_ssize_t)) + 2)));

  /* "array.pxd":106
 * 
 *             info.shape = <Py_ssize_t*> PyMem_Malloc(sizeof(Py_ssize_t) + 2)
 *             if not info.shape:             # <<<<<<<<<<<<<<
 *                 raise MemoryError()
 *             info.shape[0] = item_count      # constant regardless of resizing
 */
  __pyx_t_6 = ((!(__pyx_v_info->shape != 0)) != 0);
  if (__pyx_t_6) {

    /* "array.pxd":107
 *             info.shape = <Py_ssize_t*> PyMem_Malloc(sizeof(Py_ssize_t) + 2)
 *             if not info.shape:
 *                 raise MemoryError()             # <<<<<<<<<<<<<<
 *             info.shape[0] = item_count      # constant regardless of resizing
 *             info.strides = &info.itemsize
 */
    PyErr_NoMemory(); {__pyx_filename = __pyx_f[1]; __pyx_lineno = 107; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }

  /* "array.pxd":108
 *             if not info.shape:
 *                 raise MemoryError()
 *             info.shape[0] = item_count      # constant regardless of resizing             # <<<<<<<<<<<<<<
 *             info.strides = &info.itemsize
 * 
 */
  __pyx_t_5 = __Pyx_PyIndex_AsSsize_t(__pyx_v_item_count); if (unlikely((__pyx_t_5 == (Py_ssize_t)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 108; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  (__pyx_v_info->shape[0]) = __pyx_t_5;

  /* "array.pxd":109
 *                 raise MemoryError()
 *             info.shape[0] = item_count      # constant regardless of resizing
 *             info.strides = &info.itemsize             # <<<<<<<<<<<<<<
 * 
 *             info.format = <char*> (info.shape + 1)
 */
  __pyx_v_info->strides = (&__pyx_v_info->itemsize);

  /* "array.pxd":111
 *             info.strides = &info.itemsize
 * 
 *             info.format = <char*> (info.shape + 1)             # <<<<<<<<<<<<<<
 *             info.format[0] = self.ob_descr.typecode
 *             info.format[1] = 0
 */
  __pyx_v_info->format = ((char *)(__pyx_v_info->shape + 1));

  /* "array.pxd":112
 * 
 *             info.format = <char*> (info.shape + 1)
 *             info.format[0] = self.ob_descr.typecode             # <<<<<<<<<<<<<<
 *             info.format[1] = 0
 *             info.obj = self
 */
  __pyx_t_3 = __pyx_v_self->ob_descr->typecode;
  (__pyx_v_info->format[0]) = __pyx_t_3;

  /* "array.pxd":113
 *             info.format = <char*> (info.shape + 1)
 *             info.format[0] = self.ob_descr.typecode
 *             info.format[1] = 0             # <<<<<<<<<<<<<<
 *             info.obj = self
 * 
 */
  (__pyx_v_info->format[1]) = 0;

  /* "array.pxd":114
 *             info.format[0] = self.ob_descr.typecode
 *             info.format[1] = 0
 *             info.obj = self             # <<<<<<<<<<<<<<
 * 
 *         def __releasebuffer__(self, Py_buffer* info):
 */
  __Pyx_INCREF(((PyObject *)__pyx_v_self));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
  __Pyx_GOTREF(__pyx_v_info->obj);
  __Pyx_DECREF(__pyx_v_info->obj);
  __pyx_v_info->obj = ((PyObject *)__pyx_v_self);

  /* "array.pxd":91
 *             __data_union data
 * 
 *         def __getbuffer__(self, Py_buffer* info, int flags):             # <<<<<<<<<<<<<<
 *             # This implementation of getbuffer is geared towards Cython
 *             # requirements, and does not yet fullfill the PEP.
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("cpython.array.array.__getbuffer__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  if (__pyx_v_info != NULL && __pyx_v_info->obj != NULL) {
    __Pyx_GOTREF(__pyx_v_info->obj);
    __Pyx_DECREF(__pyx_v_info->obj); __pyx_v_info->obj = NULL;
  }
  goto __pyx_L2;
  __pyx_L0:;
  if (__pyx_v_info != NULL && __pyx_v_info->obj == Py_None) {
    __Pyx_GOTREF(Py_None);
    __Pyx_DECREF(Py_None); __pyx_v_info->obj = NULL;
  }
  __pyx_L2:;
  __Pyx_XDECREF(__pyx_v_item_count);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "array.pxd":116
 *             info.obj = self
 * 
 *         def __releasebuffer__(self, Py_buffer* info):             # <<<<<<<<<<<<<<
 *             PyMem_Free(info.shape)
 * 
 */

/* Python wrapper */
static CYTHON_UNUSED void __pyx_pw_7cpython_5array_5array_3__releasebuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info); /*proto*/
static CYTHON_UNUSED void __pyx_pw_7cpython_5array_5array_3__releasebuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__releasebuffer__ (wrapper)", 0);
  __pyx_pf_7cpython_5array_5array_2__releasebuffer__(((arrayobject *)__pyx_v_self), ((Py_buffer *)__pyx_v_info));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

static void __pyx_pf_7cpython_5array_5array_2__releasebuffer__(CYTHON_UNUSED arrayobject *__pyx_v_self, Py_buffer *__pyx_v_info) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__releasebuffer__", 0);

  /* "array.pxd":117
 * 
 *         def __releasebuffer__(self, Py_buffer* info):
 *             PyMem_Free(info.shape)             # <<<<<<<<<<<<<<
 * 
 *     array newarrayobject(PyTypeObject* type, Py_ssize_t size, arraydescr *descr)
 */
  PyMem_Free(__pyx_v_info->shape);

  /* "array.pxd":116
 *             info.obj = self
 * 
 *         def __releasebuffer__(self, Py_buffer* info):             # <<<<<<<<<<<<<<
 *             PyMem_Free(info.shape)
 * 
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

/* "array.pxd":128
 * 
 * 
 * cdef inline array clone(array template, Py_ssize_t length, bint zero):             # <<<<<<<<<<<<<<
 *     """ fast creation of a new array, given a template array.
 *     type will be same as template.
 */

static CYTHON_INLINE arrayobject *__pyx_f_7cpython_5array_clone(arrayobject *__pyx_v_template, Py_ssize_t __pyx_v_length, int __pyx_v_zero) {
  arrayobject *__pyx_v_op = NULL;
  arrayobject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_t_3;
  int __pyx_t_4;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("clone", 0);

  /* "array.pxd":132
 *     type will be same as template.
 *     if zero is true, new array will be initialized with zeroes."""
 *     op = newarrayobject(Py_TYPE(template), length, template.ob_descr)             # <<<<<<<<<<<<<<
 *     if zero and op is not None:
 *         memset(op.data.as_chars, 0, length * op.ob_descr.itemsize)
 */
  __pyx_t_1 = ((PyObject *)newarrayobject(Py_TYPE(((PyObject *)__pyx_v_template)), __pyx_v_length, __pyx_v_template->ob_descr)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 132; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_op = ((arrayobject *)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "array.pxd":133
 *     if zero is true, new array will be initialized with zeroes."""
 *     op = newarrayobject(Py_TYPE(template), length, template.ob_descr)
 *     if zero and op is not None:             # <<<<<<<<<<<<<<
 *         memset(op.data.as_chars, 0, length * op.ob_descr.itemsize)
 *     return op
 */
  __pyx_t_3 = (__pyx_v_zero != 0);
  if (__pyx_t_3) {
  } else {
    __pyx_t_2 = __pyx_t_3;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_3 = (((PyObject *)__pyx_v_op) != Py_None);
  __pyx_t_4 = (__pyx_t_3 != 0);
  __pyx_t_2 = __pyx_t_4;
  __pyx_L4_bool_binop_done:;
  if (__pyx_t_2) {

    /* "array.pxd":134
 *     op = newarrayobject(Py_TYPE(template), length, template.ob_descr)
 *     if zero and op is not None:
 *         memset(op.data.as_chars, 0, length * op.ob_descr.itemsize)             # <<<<<<<<<<<<<<
 *     return op
 * 
 */
    memset(__pyx_v_op->data.as_chars, 0, (__pyx_v_length * __pyx_v_op->ob_descr->itemsize));
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "array.pxd":135
 *     if zero and op is not None:
 *         memset(op.data.as_chars, 0, length * op.ob_descr.itemsize)
 *     return op             # <<<<<<<<<<<<<<
 * 
 * cdef inline array copy(array self):
 */
  __Pyx_XDECREF(((PyObject *)__pyx_r));
  __Pyx_INCREF(((PyObject *)__pyx_v_op));
  __pyx_r = __pyx_v_op;
  goto __pyx_L0;

  /* "array.pxd":128
 * 
 * 
 * cdef inline array clone(array template, Py_ssize_t length, bint zero):             # <<<<<<<<<<<<<<
 *     """ fast creation of a new array, given a template array.
 *     type will be same as template.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("cpython.array.clone", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_op);
  __Pyx_XGIVEREF((PyObject *)__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "array.pxd":137
 *     return op
 * 
 * cdef inline array copy(array self):             # <<<<<<<<<<<<<<
 *     """ make a copy of an array. """
 *     op = newarrayobject(Py_TYPE(self), Py_SIZE(self), self.ob_descr)
 */

static CYTHON_INLINE arrayobject *__pyx_f_7cpython_5array_copy(arrayobject *__pyx_v_self) {
  arrayobject *__pyx_v_op = NULL;
  arrayobject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("copy", 0);

  /* "array.pxd":139
 * cdef inline array copy(array self):
 *     """ make a copy of an array. """
 *     op = newarrayobject(Py_TYPE(self), Py_SIZE(self), self.ob_descr)             # <<<<<<<<<<<<<<
 *     memcpy(op.data.as_chars, self.data.as_chars, Py_SIZE(op) * op.ob_descr.itemsize)
 *     return op
 */
  __pyx_t_1 = ((PyObject *)newarrayobject(Py_TYPE(((PyObject *)__pyx_v_self)), Py_SIZE(((PyObject *)__pyx_v_self)), __pyx_v_self->ob_descr)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 139; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_op = ((arrayobject *)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "array.pxd":140
 *     """ make a copy of an array. """
 *     op = newarrayobject(Py_TYPE(self), Py_SIZE(self), self.ob_descr)
 *     memcpy(op.data.as_chars, self.data.as_chars, Py_SIZE(op) * op.ob_descr.itemsize)             # <<<<<<<<<<<<<<
 *     return op
 * 
 */
  memcpy(__pyx_v_op->data.as_chars, __pyx_v_self->data.as_chars, (Py_SIZE(((PyObject *)__pyx_v_op)) * __pyx_v_op->ob_descr->itemsize));

  /* "array.pxd":141
 *     op = newarrayobject(Py_TYPE(self), Py_SIZE(self), self.ob_descr)
 *     memcpy(op.data.as_chars, self.data.as_chars, Py_SIZE(op) * op.ob_descr.itemsize)
 *     return op             # <<<<<<<<<<<<<<
 * 
 * cdef inline int extend_buffer(array self, char* stuff, Py_ssize_t n) except -1:
 */
  __Pyx_XDECREF(((PyObject *)__pyx_r));
  __Pyx_INCREF(((PyObject *)__pyx_v_op));
  __pyx_r = __pyx_v_op;
  goto __pyx_L0;

  /* "array.pxd":137
 *     return op
 * 
 * cdef inline array copy(array self):             # <<<<<<<<<<<<<<
 *     """ make a copy of an array. """
 *     op = newarrayobject(Py_TYPE(self), Py_SIZE(self), self.ob_descr)
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("cpython.array.copy", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_op);
  __Pyx_XGIVEREF((PyObject *)__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "array.pxd":143
 *     return op
 * 
 * cdef inline int extend_buffer(array self, char* stuff, Py_ssize_t n) except -1:             # <<<<<<<<<<<<<<
 *     """ efficent appending of new stuff of same type
 *     (e.g. of same array type)
 */

static CYTHON_INLINE int __pyx_f_7cpython_5array_extend_buffer(arrayobject *__pyx_v_self, char *__pyx_v_stuff, Py_ssize_t __pyx_v_n) {
  Py_ssize_t __pyx_v_itemsize;
  Py_ssize_t __pyx_v_origsize;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("extend_buffer", 0);

  /* "array.pxd":147
 *     (e.g. of same array type)
 *     n: number of elements (not number of bytes!) """
 *     cdef Py_ssize_t itemsize = self.ob_descr.itemsize             # <<<<<<<<<<<<<<
 *     cdef Py_ssize_t origsize = Py_SIZE(self)
 *     resize_smart(self, origsize + n)
 */
  __pyx_t_1 = __pyx_v_self->ob_descr->itemsize;
  __pyx_v_itemsize = __pyx_t_1;

  /* "array.pxd":148
 *     n: number of elements (not number of bytes!) """
 *     cdef Py_ssize_t itemsize = self.ob_descr.itemsize
 *     cdef Py_ssize_t origsize = Py_SIZE(self)             # <<<<<<<<<<<<<<
 *     resize_smart(self, origsize + n)
 *     memcpy(self.data.as_chars + origsize * itemsize, stuff, n * itemsize)
 */
  __pyx_v_origsize = Py_SIZE(((PyObject *)__pyx_v_self));

  /* "array.pxd":149
 *     cdef Py_ssize_t itemsize = self.ob_descr.itemsize
 *     cdef Py_ssize_t origsize = Py_SIZE(self)
 *     resize_smart(self, origsize + n)             # <<<<<<<<<<<<<<
 *     memcpy(self.data.as_chars + origsize * itemsize, stuff, n * itemsize)
 *     return 0
 */
  __pyx_t_1 = resize_smart(__pyx_v_self, (__pyx_v_origsize + __pyx_v_n)); if (unlikely(__pyx_t_1 == -1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 149; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "array.pxd":150
 *     cdef Py_ssize_t origsize = Py_SIZE(self)
 *     resize_smart(self, origsize + n)
 *     memcpy(self.data.as_chars + origsize * itemsize, stuff, n * itemsize)             # <<<<<<<<<<<<<<
 *     return 0
 * 
 */
  memcpy((__pyx_v_self->data.as_chars + (__pyx_v_origsize * __pyx_v_itemsize)), __pyx_v_stuff, (__pyx_v_n * __pyx_v_itemsize));

  /* "array.pxd":151
 *     resize_smart(self, origsize + n)
 *     memcpy(self.data.as_chars + origsize * itemsize, stuff, n * itemsize)
 *     return 0             # <<<<<<<<<<<<<<
 * 
 * cdef inline int extend(array self, array other) except -1:
 */
  __pyx_r = 0;
  goto __pyx_L0;

  /* "array.pxd":143
 *     return op
 * 
 * cdef inline int extend_buffer(array self, char* stuff, Py_ssize_t n) except -1:             # <<<<<<<<<<<<<<
 *     """ efficent appending of new stuff of same type
 *     (e.g. of same array type)
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("cpython.array.extend_buffer", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "array.pxd":153
 *     return 0
 * 
 * cdef inline int extend(array self, array other) except -1:             # <<<<<<<<<<<<<<
 *     """ extend array with data from another array; types must match. """
 *     if self.ob_descr.typecode != other.ob_descr.typecode:
 */

static CYTHON_INLINE int __pyx_f_7cpython_5array_extend(arrayobject *__pyx_v_self, arrayobject *__pyx_v_other) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("extend", 0);

  /* "array.pxd":155
 * cdef inline int extend(array self, array other) except -1:
 *     """ extend array with data from another array; types must match. """
 *     if self.ob_descr.typecode != other.ob_descr.typecode:             # <<<<<<<<<<<<<<
 *         PyErr_BadArgument()
 *     return extend_buffer(self, other.data.as_chars, Py_SIZE(other))
 */
  __pyx_t_1 = ((__pyx_v_self->ob_descr->typecode != __pyx_v_other->ob_descr->typecode) != 0);
  if (__pyx_t_1) {

    /* "array.pxd":156
 *     """ extend array with data from another array; types must match. """
 *     if self.ob_descr.typecode != other.ob_descr.typecode:
 *         PyErr_BadArgument()             # <<<<<<<<<<<<<<
 *     return extend_buffer(self, other.data.as_chars, Py_SIZE(other))
 * 
 */
    __pyx_t_2 = PyErr_BadArgument(); if (unlikely(__pyx_t_2 == 0)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 156; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "array.pxd":157
 *     if self.ob_descr.typecode != other.ob_descr.typecode:
 *         PyErr_BadArgument()
 *     return extend_buffer(self, other.data.as_chars, Py_SIZE(other))             # <<<<<<<<<<<<<<
 * 
 * cdef inline void zero(array self):
 */
  __pyx_t_2 = __pyx_f_7cpython_5array_extend_buffer(__pyx_v_self, __pyx_v_other->data.as_chars, Py_SIZE(((PyObject *)__pyx_v_other))); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 157; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_r = __pyx_t_2;
  goto __pyx_L0;

  /* "array.pxd":153
 *     return 0
 * 
 * cdef inline int extend(array self, array other) except -1:             # <<<<<<<<<<<<<<
 *     """ extend array with data from another array; types must match. """
 *     if self.ob_descr.typecode != other.ob_descr.typecode:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("cpython.array.extend", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "array.pxd":159
 *     return extend_buffer(self, other.data.as_chars, Py_SIZE(other))
 * 
 * cdef inline void zero(array self):             # <<<<<<<<<<<<<<
 *     """ set all elements of array to zero. """
 *     memset(self.data.as_chars, 0, Py_SIZE(self) * self.ob_descr.itemsize)
 */

static CYTHON_INLINE void __pyx_f_7cpython_5array_zero(arrayobject *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("zero", 0);

  /* "array.pxd":161
 * cdef inline void zero(array self):
 *     """ set all elements of array to zero. """
 *     memset(self.data.as_chars, 0, Py_SIZE(self) * self.ob_descr.itemsize)             # <<<<<<<<<<<<<<
 */
  memset(__pyx_v_self->data.as_chars, 0, (Py_SIZE(((PyObject *)__pyx_v_self)) * __pyx_v_self->ob_descr->itemsize));

  /* "array.pxd":159
 *     return extend_buffer(self, other.data.as_chars, Py_SIZE(other))
 * 
 * cdef inline void zero(array self):             # <<<<<<<<<<<<<<
 *     """ set all elements of array to zero. """
 *     memset(self.data.as_chars, 0, Py_SIZE(self) * self.ob_descr.itemsize)
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

/* "string.from_py":13
 * 
 * @cname("__pyx_convert_string_from_py_std__string")
 * cdef string __pyx_convert_string_from_py_std__string(object o) except *:             # <<<<<<<<<<<<<<
 *     cdef Py_ssize_t length
 *     cdef char* data = __Pyx_PyObject_AsStringAndSize(o, &length)
 */

static std::string __pyx_convert_string_from_py_std__string(PyObject *__pyx_v_o) {
  Py_ssize_t __pyx_v_length;
  char *__pyx_v_data;
  std::string __pyx_r;
  __Pyx_RefNannyDeclarations
  char *__pyx_t_1;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__pyx_convert_string_from_py_std__string", 0);

  /* "string.from_py":15
 * cdef string __pyx_convert_string_from_py_std__string(object o) except *:
 *     cdef Py_ssize_t length
 *     cdef char* data = __Pyx_PyObject_AsStringAndSize(o, &length)             # <<<<<<<<<<<<<<
 *     return string(data, length)
 * 
 */
  __pyx_t_1 = __Pyx_PyObject_AsStringAndSize(__pyx_v_o, (&__pyx_v_length)); if (unlikely(__pyx_t_1 == NULL)) {__pyx_filename = __pyx_f[2]; __pyx_lineno = 15; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_data = __pyx_t_1;

  /* "string.from_py":16
 *     cdef Py_ssize_t length
 *     cdef char* data = __Pyx_PyObject_AsStringAndSize(o, &length)
 *     return string(data, length)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_r = std::string(__pyx_v_data, __pyx_v_length);
  goto __pyx_L0;

  /* "string.from_py":13
 * 
 * @cname("__pyx_convert_string_from_py_std__string")
 * cdef string __pyx_convert_string_from_py_std__string(object o) except *:             # <<<<<<<<<<<<<<
 *     cdef Py_ssize_t length
 *     cdef char* data = __Pyx_PyObject_AsStringAndSize(o, &length)
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("string.from_py.__pyx_convert_string_from_py_std__string", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "string.to_py":33
 * 
 * @cname("__pyx_convert_PyObject_string_to_py_std__string")
 * cdef inline object __pyx_convert_PyObject_string_to_py_std__string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyObject_FromStringAndSize(s.data(), s.size())
 * 
 */

static CYTHON_INLINE PyObject *__pyx_convert_PyObject_string_to_py_std__string(std::string const &__pyx_v_s) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__pyx_convert_PyObject_string_to_py_std__string", 0);

  /* "string.to_py":34
 * @cname("__pyx_convert_PyObject_string_to_py_std__string")
 * cdef inline object __pyx_convert_PyObject_string_to_py_std__string(const string& s):
 *     return __Pyx_PyObject_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
 * 
 * @cname("__pyx_convert_PyUnicode_string_to_py_std__string")
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyObject_FromStringAndSize(__pyx_v_s.data(), __pyx_v_s.size()); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 34; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "string.to_py":33
 * 
 * @cname("__pyx_convert_PyObject_string_to_py_std__string")
 * cdef inline object __pyx_convert_PyObject_string_to_py_std__string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyObject_FromStringAndSize(s.data(), s.size())
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("string.to_py.__pyx_convert_PyObject_string_to_py_std__string", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "string.to_py":37
 * 
 * @cname("__pyx_convert_PyUnicode_string_to_py_std__string")
 * cdef inline object __pyx_convert_PyUnicode_string_to_py_std__string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyUnicode_FromStringAndSize(s.data(), s.size())
 * 
 */

static CYTHON_INLINE PyObject *__pyx_convert_PyUnicode_string_to_py_std__string(std::string const &__pyx_v_s) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__pyx_convert_PyUnicode_string_to_py_std__string", 0);

  /* "string.to_py":38
 * @cname("__pyx_convert_PyUnicode_string_to_py_std__string")
 * cdef inline object __pyx_convert_PyUnicode_string_to_py_std__string(const string& s):
 *     return __Pyx_PyUnicode_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
 * 
 * @cname("__pyx_convert_PyBytes_string_to_py_std__string")
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyUnicode_FromStringAndSize(__pyx_v_s.data(), __pyx_v_s.size()); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 38; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "string.to_py":37
 * 
 * @cname("__pyx_convert_PyUnicode_string_to_py_std__string")
 * cdef inline object __pyx_convert_PyUnicode_string_to_py_std__string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyUnicode_FromStringAndSize(s.data(), s.size())
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("string.to_py.__pyx_convert_PyUnicode_string_to_py_std__string", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "string.to_py":41
 * 
 * @cname("__pyx_convert_PyBytes_string_to_py_std__string")
 * cdef inline object __pyx_convert_PyBytes_string_to_py_std__string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyBytes_FromStringAndSize(s.data(), s.size())
 * 
 */

static CYTHON_INLINE PyObject *__pyx_convert_PyBytes_string_to_py_std__string(std::string const &__pyx_v_s) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__pyx_convert_PyBytes_string_to_py_std__string", 0);

  /* "string.to_py":42
 * @cname("__pyx_convert_PyBytes_string_to_py_std__string")
 * cdef inline object __pyx_convert_PyBytes_string_to_py_std__string(const string& s):
 *     return __Pyx_PyBytes_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
 * 
 * @cname("__pyx_convert_PyByteArray_string_to_py_std__string")
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBytes_FromStringAndSize(__pyx_v_s.data(), __pyx_v_s.size()); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 42; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "string.to_py":41
 * 
 * @cname("__pyx_convert_PyBytes_string_to_py_std__string")
 * cdef inline object __pyx_convert_PyBytes_string_to_py_std__string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyBytes_FromStringAndSize(s.data(), s.size())
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("string.to_py.__pyx_convert_PyBytes_string_to_py_std__string", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "string.to_py":45
 * 
 * @cname("__pyx_convert_PyByteArray_string_to_py_std__string")
 * cdef inline object __pyx_convert_PyByteArray_string_to_py_std__string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyByteArray_FromStringAndSize(s.data(), s.size())
 * 
 */

static CYTHON_INLINE PyObject *__pyx_convert_PyByteArray_string_to_py_std__string(std::string const &__pyx_v_s) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("__pyx_convert_PyByteArray_string_to_py_std__string", 0);

  /* "string.to_py":46
 * @cname("__pyx_convert_PyByteArray_string_to_py_std__string")
 * cdef inline object __pyx_convert_PyByteArray_string_to_py_std__string(const string& s):
 *     return __Pyx_PyByteArray_FromStringAndSize(s.data(), s.size())             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyByteArray_FromStringAndSize(__pyx_v_s.data(), __pyx_v_s.size()); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[3]; __pyx_lineno = 46; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "string.to_py":45
 * 
 * @cname("__pyx_convert_PyByteArray_string_to_py_std__string")
 * cdef inline object __pyx_convert_PyByteArray_string_to_py_std__string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyByteArray_FromStringAndSize(s.data(), s.size())
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("string.to_py.__pyx_convert_PyByteArray_string_to_py_std__string", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}
static struct __pyx_vtabstruct_7pymusic_Setup __pyx_vtable_7pymusic_Setup;

static PyObject *__pyx_tp_new_7pymusic_Setup(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_7pymusic_Setup *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_7pymusic_Setup *)o);
  p->__pyx_vtab = __pyx_vtabptr_7pymusic_Setup;
  p->argv = ((PyObject*)Py_None); Py_INCREF(Py_None);
  p->comm = ((struct PyMPIIntracommObject *)Py_None); Py_INCREF(Py_None);
  p->ports = ((PyObject*)Py_None); Py_INCREF(Py_None);
  if (unlikely(__pyx_pw_7pymusic_5Setup_1__cinit__(o, a, k) < 0)) {
    Py_DECREF(o); o = 0;
  }
  return o;
}

static void __pyx_tp_dealloc_7pymusic_Setup(PyObject *o) {
  struct __pyx_obj_7pymusic_Setup *p = (struct __pyx_obj_7pymusic_Setup *)o;
  #if PY_VERSION_HEX >= 0x030400a1
  if (unlikely(Py_TYPE(o)->tp_finalize) && !_PyGC_FINALIZED(o)) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  PyObject_GC_UnTrack(o);
  {
    PyObject *etype, *eval, *etb;
    PyErr_Fetch(&etype, &eval, &etb);
    ++Py_REFCNT(o);
    __pyx_pw_7pymusic_5Setup_3__dealloc__(o);
    --Py_REFCNT(o);
    PyErr_Restore(etype, eval, etb);
  }
  Py_CLEAR(p->argv);
  Py_CLEAR(p->comm);
  Py_CLEAR(p->ports);
  (*Py_TYPE(o)->tp_free)(o);
}

static int __pyx_tp_traverse_7pymusic_Setup(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_7pymusic_Setup *p = (struct __pyx_obj_7pymusic_Setup *)o;
  if (p->argv) {
    e = (*v)(p->argv, a); if (e) return e;
  }
  if (p->comm) {
    e = (*v)(((PyObject*)p->comm), a); if (e) return e;
  }
  if (p->ports) {
    e = (*v)(p->ports, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_7pymusic_Setup(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_7pymusic_Setup *p = (struct __pyx_obj_7pymusic_Setup *)o;
  tmp = ((PyObject*)p->argv);
  p->argv = ((PyObject*)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->comm);
  p->comm = ((struct PyMPIIntracommObject *)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->ports);
  p->ports = ((PyObject*)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyObject *__pyx_getprop_7pymusic_5Setup_comm(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_7pymusic_5Setup_4comm_1__get__(o);
}

static PyMethodDef __pyx_methods_7pymusic_Setup[] = {
  {"getcomm", (PyCFunction)__pyx_pw_7pymusic_5Setup_5getcomm, METH_NOARGS, __pyx_doc_7pymusic_5Setup_4getcomm},
  {"config", (PyCFunction)__pyx_pw_7pymusic_5Setup_7config, METH_O, __pyx_doc_7pymusic_5Setup_6config},
  {"publishContInput", (PyCFunction)__pyx_pw_7pymusic_5Setup_9publishContInput, METH_O, __pyx_doc_7pymusic_5Setup_8publishContInput},
  {"publishContOutput", (PyCFunction)__pyx_pw_7pymusic_5Setup_11publishContOutput, METH_O, __pyx_doc_7pymusic_5Setup_10publishContOutput},
  {"publishEventOutput", (PyCFunction)__pyx_pw_7pymusic_5Setup_13publishEventOutput, METH_O, __pyx_doc_7pymusic_5Setup_12publishEventOutput},
  {"publishEventInput", (PyCFunction)__pyx_pw_7pymusic_5Setup_15publishEventInput, METH_O, __pyx_doc_7pymusic_5Setup_14publishEventInput},
  {"publishMessageOutput", (PyCFunction)__pyx_pw_7pymusic_5Setup_17publishMessageOutput, METH_O, __pyx_doc_7pymusic_5Setup_16publishMessageOutput},
  {"publishMessageInput", (PyCFunction)__pyx_pw_7pymusic_5Setup_19publishMessageInput, METH_O, __pyx_doc_7pymusic_5Setup_18publishMessageInput},
  {"runtime", (PyCFunction)__pyx_pw_7pymusic_5Setup_21runtime, METH_O, __pyx_doc_7pymusic_5Setup_20runtime},
  {0, 0, 0, 0}
};

static struct PyGetSetDef __pyx_getsets_7pymusic_Setup[] = {
  {(char *)"comm", __pyx_getprop_7pymusic_5Setup_comm, 0, 0, 0},
  {0, 0, 0, 0, 0}
};

static PyTypeObject __pyx_type_7pymusic_Setup = {
  PyVarObject_HEAD_INIT(0, 0)
  "pymusic.Setup", /*tp_name*/
  sizeof(struct __pyx_obj_7pymusic_Setup), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_7pymusic_Setup, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #else
  0, /*reserved*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  "\n    API to setup the music interface.\n    Becomes invalid after a Runtime object is created.\n    It gives access to config variables (*.music file),\n    and creates sinks and sources which can then be configured with\n    the respective map method of each.\n    ", /*tp_doc*/
  __pyx_tp_traverse_7pymusic_Setup, /*tp_traverse*/
  __pyx_tp_clear_7pymusic_Setup, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_7pymusic_Setup, /*tp_methods*/
  0, /*tp_members*/
  __pyx_getsets_7pymusic_Setup, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_7pymusic_Setup, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static PyObject *__pyx_tp_new_7pymusic_Runtime(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_7pymusic_Runtime *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_7pymusic_Runtime *)o);
  p->comm = ((struct PyMPIIntracommObject *)Py_None); Py_INCREF(Py_None);
  p->ports = ((PyObject*)Py_None); Py_INCREF(Py_None);
  if (unlikely(__pyx_pw_7pymusic_7Runtime_1__cinit__(o, a, k) < 0)) {
    Py_DECREF(o); o = 0;
  }
  return o;
}

static void __pyx_tp_dealloc_7pymusic_Runtime(PyObject *o) {
  struct __pyx_obj_7pymusic_Runtime *p = (struct __pyx_obj_7pymusic_Runtime *)o;
  #if PY_VERSION_HEX >= 0x030400a1
  if (unlikely(Py_TYPE(o)->tp_finalize) && !_PyGC_FINALIZED(o)) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  PyObject_GC_UnTrack(o);
  {
    PyObject *etype, *eval, *etb;
    PyErr_Fetch(&etype, &eval, &etb);
    ++Py_REFCNT(o);
    __pyx_pw_7pymusic_7Runtime_3__dealloc__(o);
    --Py_REFCNT(o);
    PyErr_Restore(etype, eval, etb);
  }
  Py_CLEAR(p->comm);
  Py_CLEAR(p->ports);
  (*Py_TYPE(o)->tp_free)(o);
}

static int __pyx_tp_traverse_7pymusic_Runtime(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_7pymusic_Runtime *p = (struct __pyx_obj_7pymusic_Runtime *)o;
  if (p->comm) {
    e = (*v)(((PyObject*)p->comm), a); if (e) return e;
  }
  if (p->ports) {
    e = (*v)(p->ports, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_7pymusic_Runtime(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_7pymusic_Runtime *p = (struct __pyx_obj_7pymusic_Runtime *)o;
  tmp = ((PyObject*)p->comm);
  p->comm = ((struct PyMPIIntracommObject *)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->ports);
  p->ports = ((PyObject*)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyObject *__pyx_getprop_7pymusic_7Runtime_comm(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_7pymusic_7Runtime_4comm_1__get__(o);
}

static PyMethodDef __pyx_methods_7pymusic_Runtime[] = {
  {"time", (PyCFunction)__pyx_pw_7pymusic_7Runtime_5time, METH_NOARGS, 0},
  {"tick", (PyCFunction)__pyx_pw_7pymusic_7Runtime_7tick, METH_NOARGS, 0},
  {0, 0, 0, 0}
};

static struct PyGetSetDef __pyx_getsets_7pymusic_Runtime[] = {
  {(char *)"comm", __pyx_getprop_7pymusic_7Runtime_comm, 0, 0, 0},
  {0, 0, 0, 0, 0}
};

static PyTypeObject __pyx_type_7pymusic_Runtime = {
  PyVarObject_HEAD_INIT(0, 0)
  "pymusic.Runtime", /*tp_name*/
  sizeof(struct __pyx_obj_7pymusic_Runtime), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_7pymusic_Runtime, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #else
  0, /*reserved*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_7pymusic_Runtime, /*tp_traverse*/
  __pyx_tp_clear_7pymusic_Runtime, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  __pyx_pw_7pymusic_7Runtime_9__iter__, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_7pymusic_Runtime, /*tp_methods*/
  0, /*tp_members*/
  __pyx_getsets_7pymusic_Runtime, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_7pymusic_Runtime, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};
static struct __pyx_vtabstruct_7pymusic_Port __pyx_vtable_7pymusic_Port;

static PyObject *__pyx_tp_new_7pymusic_Port(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  struct __pyx_obj_7pymusic_Port *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_7pymusic_Port *)o);
  p->__pyx_vtab = __pyx_vtabptr_7pymusic_Port;
  if (unlikely(__pyx_pw_7pymusic_4Port_1__cinit__(o, __pyx_empty_tuple, NULL) < 0)) {
    Py_DECREF(o); o = 0;
  }
  return o;
}

static void __pyx_tp_dealloc_7pymusic_Port(PyObject *o) {
  #if PY_VERSION_HEX >= 0x030400a1
  if (unlikely(Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  (*Py_TYPE(o)->tp_free)(o);
}

static PyMethodDef __pyx_methods_7pymusic_Port[] = {
  {"null", (PyCFunction)__pyx_pw_7pymusic_4Port_5null, METH_NOARGS, __pyx_doc_7pymusic_4Port_4null},
  {"isConnected", (PyCFunction)__pyx_pw_7pymusic_4Port_7isConnected, METH_NOARGS, __pyx_doc_7pymusic_4Port_6isConnected},
  {"width", (PyCFunction)__pyx_pw_7pymusic_4Port_9width, METH_NOARGS, __pyx_doc_7pymusic_4Port_8width},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_7pymusic_Port = {
  PyVarObject_HEAD_INIT(0, 0)
  "pymusic.Port", /*tp_name*/
  sizeof(struct __pyx_obj_7pymusic_Port), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_7pymusic_Port, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #else
  0, /*reserved*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  __pyx_pw_7pymusic_4Port_3__hash__, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "\n    Base Port class.\n\n    The underlying pointer is not deallocated here, since in MUSIC the\n    port is owned by Setup/Runtime.  This does null the value when we\n    believe the underlying object may be deallocated by the\n    container.\n    ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_7pymusic_Port, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_7pymusic_Port, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};
static struct __pyx_vtabstruct_7pymusic_ContInputPort __pyx_vtable_7pymusic_ContInputPort;

static PyObject *__pyx_tp_new_7pymusic_ContInputPort(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_7pymusic_ContInputPort *p;
  PyObject *o = __pyx_tp_new_7pymusic_Port(t, a, k);
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_7pymusic_ContInputPort *)o);
  p->__pyx_base.__pyx_vtab = (struct __pyx_vtabstruct_7pymusic_Port*)__pyx_vtabptr_7pymusic_ContInputPort;
  return o;
}

static PyMethodDef __pyx_methods_7pymusic_ContInputPort[] = {
  {"map", (PyCFunction)__pyx_pw_7pymusic_13ContInputPort_1map, METH_VARARGS|METH_KEYWORDS, __pyx_doc_7pymusic_13ContInputPort_map},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_7pymusic_ContInputPort = {
  PyVarObject_HEAD_INIT(0, 0)
  "pymusic.ContInputPort", /*tp_name*/
  sizeof(struct __pyx_obj_7pymusic_ContInputPort), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_7pymusic_Port, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #else
  0, /*reserved*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "\n    ContInputPort maps data indices between sources and sinks. This is\n    the sink side; source is ContOutputPort. Created by\n    Setup.publishContInputPort(portname).\n    ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_7pymusic_ContInputPort, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_7pymusic_ContInputPort, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};
static struct __pyx_vtabstruct_7pymusic_ContOutputPort __pyx_vtable_7pymusic_ContOutputPort;

static PyObject *__pyx_tp_new_7pymusic_ContOutputPort(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_7pymusic_ContOutputPort *p;
  PyObject *o = __pyx_tp_new_7pymusic_Port(t, a, k);
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_7pymusic_ContOutputPort *)o);
  p->__pyx_base.__pyx_vtab = (struct __pyx_vtabstruct_7pymusic_Port*)__pyx_vtabptr_7pymusic_ContOutputPort;
  return o;
}

static PyMethodDef __pyx_methods_7pymusic_ContOutputPort[] = {
  {"map", (PyCFunction)__pyx_pw_7pymusic_14ContOutputPort_1map, METH_VARARGS|METH_KEYWORDS, __pyx_doc_7pymusic_14ContOutputPort_map},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_7pymusic_ContOutputPort = {
  PyVarObject_HEAD_INIT(0, 0)
  "pymusic.ContOutputPort", /*tp_name*/
  sizeof(struct __pyx_obj_7pymusic_ContOutputPort), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_7pymusic_Port, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #else
  0, /*reserved*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "\n    ContOutputPort maps data indices between sources and sinks. This\n    is the source side; ContInputPort is the sink. Created by\n    Setup.publishContOutputPort(portname).\n    ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_7pymusic_ContOutputPort, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_7pymusic_ContOutputPort, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};
static struct __pyx_vtabstruct_7pymusic_EventInputPort __pyx_vtable_7pymusic_EventInputPort;

static PyObject *__pyx_tp_new_7pymusic_EventInputPort(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_7pymusic_EventInputPort *p;
  PyObject *o = __pyx_tp_new_7pymusic_Port(t, a, k);
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_7pymusic_EventInputPort *)o);
  p->__pyx_base.__pyx_vtab = (struct __pyx_vtabstruct_7pymusic_Port*)__pyx_vtabptr_7pymusic_EventInputPort;
  p->events = ((PyObject*)Py_None); Py_INCREF(Py_None);
  if (unlikely(__pyx_pw_7pymusic_14EventInputPort_1__cinit__(o, __pyx_empty_tuple, NULL) < 0)) {
    Py_DECREF(o); o = 0;
  }
  return o;
}

static void __pyx_tp_dealloc_7pymusic_EventInputPort(PyObject *o) {
  struct __pyx_obj_7pymusic_EventInputPort *p = (struct __pyx_obj_7pymusic_EventInputPort *)o;
  #if PY_VERSION_HEX >= 0x030400a1
  if (unlikely(Py_TYPE(o)->tp_finalize) && !_PyGC_FINALIZED(o)) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->events);
  #if CYTHON_COMPILING_IN_CPYTHON
  if (PyType_IS_GC(Py_TYPE(o)->tp_base))
  #endif
  PyObject_GC_Track(o);
  __pyx_tp_dealloc_7pymusic_Port(o);
}

static int __pyx_tp_traverse_7pymusic_EventInputPort(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_7pymusic_EventInputPort *p = (struct __pyx_obj_7pymusic_EventInputPort *)o;
  e = ((likely(__pyx_ptype_7pymusic_Port)) ? ((__pyx_ptype_7pymusic_Port->tp_traverse) ? __pyx_ptype_7pymusic_Port->tp_traverse(o, v, a) : 0) : __Pyx_call_next_tp_traverse(o, v, a, __pyx_tp_traverse_7pymusic_EventInputPort)); if (e) return e;
  if (p->events) {
    e = (*v)(p->events, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_7pymusic_EventInputPort(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_7pymusic_EventInputPort *p = (struct __pyx_obj_7pymusic_EventInputPort *)o;
  if (likely(__pyx_ptype_7pymusic_Port)) { if (__pyx_ptype_7pymusic_Port->tp_clear) __pyx_ptype_7pymusic_Port->tp_clear(o); } else __Pyx_call_next_tp_clear(o, __pyx_tp_clear_7pymusic_EventInputPort);
  tmp = ((PyObject*)p->events);
  p->events = ((PyObject*)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyMethodDef __pyx_methods_7pymusic_EventInputPort[] = {
  {"null", (PyCFunction)__pyx_pw_7pymusic_14EventInputPort_3null, METH_NOARGS, __pyx_doc_7pymusic_14EventInputPort_2null},
  {"map", (PyCFunction)__pyx_pw_7pymusic_14EventInputPort_5map, METH_VARARGS|METH_KEYWORDS, __pyx_doc_7pymusic_14EventInputPort_4map},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_7pymusic_EventInputPort = {
  PyVarObject_HEAD_INIT(0, 0)
  "pymusic.EventInputPort", /*tp_name*/
  sizeof(struct __pyx_obj_7pymusic_EventInputPort), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_7pymusic_EventInputPort, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #else
  0, /*reserved*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  "\n    Event sink. Maps 'events' to handlers. Events are spike-like\n    events at a defined time associated with an id, either/or\n    global/local in some (unclear to me) way.\n\n    Since these 'events' must be protected from deallocation as long\n    as the port exists (until finalization), we keep a set of them\n    here and drop the reference when this object is null'd (events member).\n    ", /*tp_doc*/
  __pyx_tp_traverse_7pymusic_EventInputPort, /*tp_traverse*/
  __pyx_tp_clear_7pymusic_EventInputPort, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_7pymusic_EventInputPort, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_7pymusic_EventInputPort, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};
static struct __pyx_vtabstruct_7pymusic_EventOutputPort __pyx_vtable_7pymusic_EventOutputPort;

static PyObject *__pyx_tp_new_7pymusic_EventOutputPort(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_7pymusic_EventOutputPort *p;
  PyObject *o = __pyx_tp_new_7pymusic_Port(t, a, k);
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_7pymusic_EventOutputPort *)o);
  p->__pyx_base.__pyx_vtab = (struct __pyx_vtabstruct_7pymusic_Port*)__pyx_vtabptr_7pymusic_EventOutputPort;
  return o;
}

static PyMethodDef __pyx_methods_7pymusic_EventOutputPort[] = {
  {"map", (PyCFunction)__pyx_pw_7pymusic_15EventOutputPort_1map, METH_VARARGS|METH_KEYWORDS, __pyx_doc_7pymusic_15EventOutputPort_map},
  {"insertEvent", (PyCFunction)__pyx_pw_7pymusic_15EventOutputPort_3insertEvent, METH_VARARGS|METH_KEYWORDS, __pyx_doc_7pymusic_15EventOutputPort_2insertEvent},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_7pymusic_EventOutputPort = {
  PyVarObject_HEAD_INIT(0, 0)
  "pymusic.EventOutputPort", /*tp_name*/
  sizeof(struct __pyx_obj_7pymusic_EventOutputPort), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_7pymusic_Port, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #else
  0, /*reserved*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "\n    Map events from this sink. See EventInputPort for description of\n    events.\n    ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_7pymusic_EventOutputPort, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_7pymusic_EventOutputPort, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};
static struct __pyx_vtabstruct_7pymusic_MessageInputPort __pyx_vtable_7pymusic_MessageInputPort;

static PyObject *__pyx_tp_new_7pymusic_MessageInputPort(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_7pymusic_MessageInputPort *p;
  PyObject *o = __pyx_tp_new_7pymusic_Port(t, a, k);
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_7pymusic_MessageInputPort *)o);
  p->__pyx_base.__pyx_vtab = (struct __pyx_vtabstruct_7pymusic_Port*)__pyx_vtabptr_7pymusic_MessageInputPort;
  p->events = ((PyObject*)Py_None); Py_INCREF(Py_None);
  if (unlikely(__pyx_pw_7pymusic_16MessageInputPort_1__cinit__(o, __pyx_empty_tuple, NULL) < 0)) {
    Py_DECREF(o); o = 0;
  }
  return o;
}

static void __pyx_tp_dealloc_7pymusic_MessageInputPort(PyObject *o) {
  struct __pyx_obj_7pymusic_MessageInputPort *p = (struct __pyx_obj_7pymusic_MessageInputPort *)o;
  #if PY_VERSION_HEX >= 0x030400a1
  if (unlikely(Py_TYPE(o)->tp_finalize) && !_PyGC_FINALIZED(o)) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->events);
  #if CYTHON_COMPILING_IN_CPYTHON
  if (PyType_IS_GC(Py_TYPE(o)->tp_base))
  #endif
  PyObject_GC_Track(o);
  __pyx_tp_dealloc_7pymusic_Port(o);
}

static int __pyx_tp_traverse_7pymusic_MessageInputPort(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_7pymusic_MessageInputPort *p = (struct __pyx_obj_7pymusic_MessageInputPort *)o;
  e = ((likely(__pyx_ptype_7pymusic_Port)) ? ((__pyx_ptype_7pymusic_Port->tp_traverse) ? __pyx_ptype_7pymusic_Port->tp_traverse(o, v, a) : 0) : __Pyx_call_next_tp_traverse(o, v, a, __pyx_tp_traverse_7pymusic_MessageInputPort)); if (e) return e;
  if (p->events) {
    e = (*v)(p->events, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_7pymusic_MessageInputPort(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_7pymusic_MessageInputPort *p = (struct __pyx_obj_7pymusic_MessageInputPort *)o;
  if (likely(__pyx_ptype_7pymusic_Port)) { if (__pyx_ptype_7pymusic_Port->tp_clear) __pyx_ptype_7pymusic_Port->tp_clear(o); } else __Pyx_call_next_tp_clear(o, __pyx_tp_clear_7pymusic_MessageInputPort);
  tmp = ((PyObject*)p->events);
  p->events = ((PyObject*)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyMethodDef __pyx_methods_7pymusic_MessageInputPort[] = {
  {"null", (PyCFunction)__pyx_pw_7pymusic_16MessageInputPort_3null, METH_NOARGS, __pyx_doc_7pymusic_16MessageInputPort_2null},
  {"map", (PyCFunction)__pyx_pw_7pymusic_16MessageInputPort_5map, METH_VARARGS|METH_KEYWORDS, __pyx_doc_7pymusic_16MessageInputPort_4map},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_7pymusic_MessageInputPort = {
  PyVarObject_HEAD_INIT(0, 0)
  "pymusic.MessageInputPort", /*tp_name*/
  sizeof(struct __pyx_obj_7pymusic_MessageInputPort), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_7pymusic_MessageInputPort, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #else
  0, /*reserved*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  "\n    Maps 'events' to handlers.\n\n    Since these 'events' must be protected from deallocation as long\n    as the port exists (until finalization), we keep a set of them\n    here and drop the reference when this object is null'd.\n    ", /*tp_doc*/
  __pyx_tp_traverse_7pymusic_MessageInputPort, /*tp_traverse*/
  __pyx_tp_clear_7pymusic_MessageInputPort, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_7pymusic_MessageInputPort, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_7pymusic_MessageInputPort, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};
static struct __pyx_vtabstruct_7pymusic_MessageOutputPort __pyx_vtable_7pymusic_MessageOutputPort;

static PyObject *__pyx_tp_new_7pymusic_MessageOutputPort(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_7pymusic_MessageOutputPort *p;
  PyObject *o = __pyx_tp_new_7pymusic_Port(t, a, k);
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_7pymusic_MessageOutputPort *)o);
  p->__pyx_base.__pyx_vtab = (struct __pyx_vtabstruct_7pymusic_Port*)__pyx_vtabptr_7pymusic_MessageOutputPort;
  return o;
}

static PyMethodDef __pyx_methods_7pymusic_MessageOutputPort[] = {
  {"map", (PyCFunction)__pyx_pw_7pymusic_17MessageOutputPort_1map, METH_VARARGS|METH_KEYWORDS, __pyx_doc_7pymusic_17MessageOutputPort_map},
  {"insertMessage", (PyCFunction)__pyx_pw_7pymusic_17MessageOutputPort_3insertMessage, METH_VARARGS|METH_KEYWORDS, __pyx_doc_7pymusic_17MessageOutputPort_2insertMessage},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_7pymusic_MessageOutputPort = {
  PyVarObject_HEAD_INIT(0, 0)
  "pymusic.MessageOutputPort", /*tp_name*/
  sizeof(struct __pyx_obj_7pymusic_MessageOutputPort), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_7pymusic_Port, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #else
  0, /*reserved*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "\n    The source of \"messages\". A message is a python object that is\n    pickled and fed to the other end, associated with a time.\n    ", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_7pymusic_MessageOutputPort, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_7pymusic_MessageOutputPort, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static PyObject *__pyx_tp_new_7pymusic_DataMap(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_7pymusic_DataMap *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_7pymusic_DataMap *)o);
  p->buf = ((struct __pyx_obj_5music_8pybuffer_Buffer *)Py_None); Py_INCREF(Py_None);
  if (unlikely(__pyx_pw_7pymusic_7DataMap_1__cinit__(o, a, k) < 0)) {
    Py_DECREF(o); o = 0;
  }
  return o;
}

static void __pyx_tp_dealloc_7pymusic_DataMap(PyObject *o) {
  struct __pyx_obj_7pymusic_DataMap *p = (struct __pyx_obj_7pymusic_DataMap *)o;
  #if PY_VERSION_HEX >= 0x030400a1
  if (unlikely(Py_TYPE(o)->tp_finalize) && !_PyGC_FINALIZED(o)) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  PyObject_GC_UnTrack(o);
  {
    PyObject *etype, *eval, *etb;
    PyErr_Fetch(&etype, &eval, &etb);
    ++Py_REFCNT(o);
    __pyx_pw_7pymusic_7DataMap_3__dealloc__(o);
    --Py_REFCNT(o);
    PyErr_Restore(etype, eval, etb);
  }
  Py_CLEAR(p->buf);
  (*Py_TYPE(o)->tp_free)(o);
}

static int __pyx_tp_traverse_7pymusic_DataMap(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_7pymusic_DataMap *p = (struct __pyx_obj_7pymusic_DataMap *)o;
  if (p->buf) {
    e = (*v)(((PyObject*)p->buf), a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_7pymusic_DataMap(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_7pymusic_DataMap *p = (struct __pyx_obj_7pymusic_DataMap *)o;
  tmp = ((PyObject*)p->buf);
  p->buf = ((struct __pyx_obj_5music_8pybuffer_Buffer *)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyMethodDef __pyx_methods_7pymusic_DataMap[] = {
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_7pymusic_DataMap = {
  PyVarObject_HEAD_INIT(0, 0)
  "pymusic.DataMap", /*tp_name*/
  sizeof(struct __pyx_obj_7pymusic_DataMap), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_7pymusic_DataMap, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #else
  0, /*reserved*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  "\n    Internal:\n    An ArrayData object. Takes a data object as a Buffer and possibly an\n    IndexMap to construct a mapping for the Cont*Port transfers.\n    ", /*tp_doc*/
  __pyx_tp_traverse_7pymusic_DataMap, /*tp_traverse*/
  __pyx_tp_clear_7pymusic_DataMap, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_7pymusic_DataMap, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_7pymusic_DataMap, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static PyObject *__pyx_tp_new_7pymusic_IndexMap(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_7pymusic_IndexMap *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_7pymusic_IndexMap *)o);
  p->buf = ((struct __pyx_obj_5music_8pybuffer_Buffer *)Py_None); Py_INCREF(Py_None);
  if (unlikely(__pyx_pw_7pymusic_8IndexMap_1__cinit__(o, a, k) < 0)) {
    Py_DECREF(o); o = 0;
  }
  return o;
}

static void __pyx_tp_dealloc_7pymusic_IndexMap(PyObject *o) {
  struct __pyx_obj_7pymusic_IndexMap *p = (struct __pyx_obj_7pymusic_IndexMap *)o;
  #if PY_VERSION_HEX >= 0x030400a1
  if (unlikely(Py_TYPE(o)->tp_finalize) && !_PyGC_FINALIZED(o)) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  PyObject_GC_UnTrack(o);
  {
    PyObject *etype, *eval, *etb;
    PyErr_Fetch(&etype, &eval, &etb);
    ++Py_REFCNT(o);
    __pyx_pw_7pymusic_8IndexMap_3__dealloc__(o);
    --Py_REFCNT(o);
    PyErr_Restore(etype, eval, etb);
  }
  Py_CLEAR(p->buf);
  (*Py_TYPE(o)->tp_free)(o);
}

static int __pyx_tp_traverse_7pymusic_IndexMap(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_7pymusic_IndexMap *p = (struct __pyx_obj_7pymusic_IndexMap *)o;
  if (p->buf) {
    e = (*v)(((PyObject*)p->buf), a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_7pymusic_IndexMap(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_7pymusic_IndexMap *p = (struct __pyx_obj_7pymusic_IndexMap *)o;
  tmp = ((PyObject*)p->buf);
  p->buf = ((struct __pyx_obj_5music_8pybuffer_Buffer *)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyMethodDef __pyx_methods_7pymusic_IndexMap[] = {
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_7pymusic_IndexMap = {
  PyVarObject_HEAD_INIT(0, 0)
  "pymusic.IndexMap", /*tp_name*/
  sizeof(struct __pyx_obj_7pymusic_IndexMap), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_7pymusic_IndexMap, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #else
  0, /*reserved*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  "\n    Internal:\n    Contains a C++ LinearIndex or PermutationIndex.\n    These map between \"local\" index i to \"global\" index j\n    LinearIndex: g = l + base, for l < size\n    PermutationIndex: g = perm[l], where perm is an array\n    ", /*tp_doc*/
  __pyx_tp_traverse_7pymusic_IndexMap, /*tp_traverse*/
  __pyx_tp_clear_7pymusic_IndexMap, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_7pymusic_IndexMap, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_7pymusic_IndexMap, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static PyObject *__pyx_tp_new_7pymusic_EventHandler(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_7pymusic_EventHandler *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_7pymusic_EventHandler *)o);
  p->func = Py_None; Py_INCREF(Py_None);
  if (unlikely(__pyx_pw_7pymusic_12EventHandler_1__cinit__(o, a, k) < 0)) {
    Py_DECREF(o); o = 0;
  }
  return o;
}

static void __pyx_tp_dealloc_7pymusic_EventHandler(PyObject *o) {
  struct __pyx_obj_7pymusic_EventHandler *p = (struct __pyx_obj_7pymusic_EventHandler *)o;
  #if PY_VERSION_HEX >= 0x030400a1
  if (unlikely(Py_TYPE(o)->tp_finalize) && !_PyGC_FINALIZED(o)) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  PyObject_GC_UnTrack(o);
  {
    PyObject *etype, *eval, *etb;
    PyErr_Fetch(&etype, &eval, &etb);
    ++Py_REFCNT(o);
    __pyx_pw_7pymusic_12EventHandler_3__dealloc__(o);
    --Py_REFCNT(o);
    PyErr_Restore(etype, eval, etb);
  }
  Py_CLEAR(p->func);
  (*Py_TYPE(o)->tp_free)(o);
}

static int __pyx_tp_traverse_7pymusic_EventHandler(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_7pymusic_EventHandler *p = (struct __pyx_obj_7pymusic_EventHandler *)o;
  if (p->func) {
    e = (*v)(p->func, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_7pymusic_EventHandler(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_7pymusic_EventHandler *p = (struct __pyx_obj_7pymusic_EventHandler *)o;
  tmp = ((PyObject*)p->func);
  p->func = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyMethodDef __pyx_methods_7pymusic_EventHandler[] = {
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_7pymusic_EventHandler = {
  PyVarObject_HEAD_INIT(0, 0)
  "pymusic.EventHandler", /*tp_name*/
  sizeof(struct __pyx_obj_7pymusic_EventHandler), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_7pymusic_EventHandler, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #else
  0, /*reserved*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  "\n    Internal:\n    An EventHandler is the python wrapper around a global\n    or local EventHandler object for EventInputPort\n    ", /*tp_doc*/
  __pyx_tp_traverse_7pymusic_EventHandler, /*tp_traverse*/
  __pyx_tp_clear_7pymusic_EventHandler, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_7pymusic_EventHandler, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_7pymusic_EventHandler, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static PyObject *__pyx_tp_new_7pymusic_MessageHandler(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_7pymusic_MessageHandler *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_7pymusic_MessageHandler *)o);
  p->func = Py_None; Py_INCREF(Py_None);
  if (unlikely(__pyx_pw_7pymusic_14MessageHandler_1__cinit__(o, a, k) < 0)) {
    Py_DECREF(o); o = 0;
  }
  return o;
}

static void __pyx_tp_dealloc_7pymusic_MessageHandler(PyObject *o) {
  struct __pyx_obj_7pymusic_MessageHandler *p = (struct __pyx_obj_7pymusic_MessageHandler *)o;
  #if PY_VERSION_HEX >= 0x030400a1
  if (unlikely(Py_TYPE(o)->tp_finalize) && !_PyGC_FINALIZED(o)) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  PyObject_GC_UnTrack(o);
  {
    PyObject *etype, *eval, *etb;
    PyErr_Fetch(&etype, &eval, &etb);
    ++Py_REFCNT(o);
    __pyx_pw_7pymusic_14MessageHandler_3__dealloc__(o);
    --Py_REFCNT(o);
    PyErr_Restore(etype, eval, etb);
  }
  Py_CLEAR(p->func);
  (*Py_TYPE(o)->tp_free)(o);
}

static int __pyx_tp_traverse_7pymusic_MessageHandler(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_7pymusic_MessageHandler *p = (struct __pyx_obj_7pymusic_MessageHandler *)o;
  if (p->func) {
    e = (*v)(p->func, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_7pymusic_MessageHandler(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_7pymusic_MessageHandler *p = (struct __pyx_obj_7pymusic_MessageHandler *)o;
  tmp = ((PyObject*)p->func);
  p->func = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyMethodDef __pyx_methods_7pymusic_MessageHandler[] = {
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_7pymusic_MessageHandler = {
  PyVarObject_HEAD_INIT(0, 0)
  "pymusic.MessageHandler", /*tp_name*/
  sizeof(struct __pyx_obj_7pymusic_MessageHandler), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_7pymusic_MessageHandler, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #else
  0, /*reserved*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  "\n    MessageHandler wraps up Message*Port communications between C & python,\n    wrapping n particular the C++ MessageHandler object bound with a function.\n    It may (or may not) depickle messages\n    ", /*tp_doc*/
  __pyx_tp_traverse_7pymusic_MessageHandler, /*tp_traverse*/
  __pyx_tp_clear_7pymusic_MessageHandler, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_7pymusic_MessageHandler, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_7pymusic_MessageHandler, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static PyObject *__pyx_tp_new_7pymusic__Index(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  struct __pyx_obj_7pymusic__Index *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_7pymusic__Index *)o);
  p->backmap = ((PyObject*)Py_None); Py_INCREF(Py_None);
  if (unlikely(__pyx_pw_7pymusic_6_Index_1__cinit__(o, __pyx_empty_tuple, NULL) < 0)) {
    Py_DECREF(o); o = 0;
  }
  return o;
}

static void __pyx_tp_dealloc_7pymusic__Index(PyObject *o) {
  struct __pyx_obj_7pymusic__Index *p = (struct __pyx_obj_7pymusic__Index *)o;
  #if PY_VERSION_HEX >= 0x030400a1
  if (unlikely(Py_TYPE(o)->tp_finalize) && !_PyGC_FINALIZED(o)) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->backmap);
  (*Py_TYPE(o)->tp_free)(o);
}

static int __pyx_tp_traverse_7pymusic__Index(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_7pymusic__Index *p = (struct __pyx_obj_7pymusic__Index *)o;
  if (p->backmap) {
    e = (*v)(p->backmap, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_7pymusic__Index(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_7pymusic__Index *p = (struct __pyx_obj_7pymusic__Index *)o;
  tmp = ((PyObject*)p->backmap);
  p->backmap = ((PyObject*)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyObject *__pyx_getprop_7pymusic_6_Index_GLOBAL(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_7pymusic_6_Index_6GLOBAL_1__get__(o);
}

static PyObject *__pyx_getprop_7pymusic_6_Index_LOCAL(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_7pymusic_6_Index_5LOCAL_1__get__(o);
}

static PyObject *__pyx_getprop_7pymusic_6_Index_backmap(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_7pymusic_6_Index_7backmap_1__get__(o);
}

static PyMethodDef __pyx_methods_7pymusic__Index[] = {
  {"tostr", (PyCFunction)__pyx_pw_7pymusic_6_Index_3tostr, METH_O, __pyx_doc_7pymusic_6_Index_2tostr},
  {0, 0, 0, 0}
};

static struct PyGetSetDef __pyx_getsets_7pymusic__Index[] = {
  {(char *)"GLOBAL", __pyx_getprop_7pymusic_6_Index_GLOBAL, 0, 0, 0},
  {(char *)"LOCAL", __pyx_getprop_7pymusic_6_Index_LOCAL, 0, 0, 0},
  {(char *)"backmap", __pyx_getprop_7pymusic_6_Index_backmap, 0, 0, 0},
  {0, 0, 0, 0, 0}
};

static PyTypeObject __pyx_type_7pymusic__Index = {
  PyVarObject_HEAD_INIT(0, 0)
  "pymusic._Index", /*tp_name*/
  sizeof(struct __pyx_obj_7pymusic__Index), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_7pymusic__Index, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #else
  0, /*reserved*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  "\n    Internal: the type of the variable Index\n    that encapsulates the enum mapping\n    GLOBAL and LOCAL are the ints of the C enums\n    backmap maps from the enum to a string for output\n    purposes\n    ", /*tp_doc*/
  __pyx_tp_traverse_7pymusic__Index, /*tp_traverse*/
  __pyx_tp_clear_7pymusic__Index, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_7pymusic__Index, /*tp_methods*/
  0, /*tp_members*/
  __pyx_getsets_7pymusic__Index, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_7pymusic__Index, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static struct __pyx_obj_7pymusic___pyx_scope_struct____iter__ *__pyx_freelist_7pymusic___pyx_scope_struct____iter__[8];
static int __pyx_freecount_7pymusic___pyx_scope_struct____iter__ = 0;

static PyObject *__pyx_tp_new_7pymusic___pyx_scope_struct____iter__(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (CYTHON_COMPILING_IN_CPYTHON && likely((__pyx_freecount_7pymusic___pyx_scope_struct____iter__ > 0) & (t->tp_basicsize == sizeof(struct __pyx_obj_7pymusic___pyx_scope_struct____iter__)))) {
    o = (PyObject*)__pyx_freelist_7pymusic___pyx_scope_struct____iter__[--__pyx_freecount_7pymusic___pyx_scope_struct____iter__];
    memset(o, 0, sizeof(struct __pyx_obj_7pymusic___pyx_scope_struct____iter__));
    (void) PyObject_INIT(o, t);
    PyObject_GC_Track(o);
  } else {
    o = (*t->tp_alloc)(t, 0);
    if (unlikely(!o)) return 0;
  }
  return o;
}

static void __pyx_tp_dealloc_7pymusic___pyx_scope_struct____iter__(PyObject *o) {
  struct __pyx_obj_7pymusic___pyx_scope_struct____iter__ *p = (struct __pyx_obj_7pymusic___pyx_scope_struct____iter__ *)o;
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->__pyx_v_self);
  if (CYTHON_COMPILING_IN_CPYTHON && ((__pyx_freecount_7pymusic___pyx_scope_struct____iter__ < 8) & (Py_TYPE(o)->tp_basicsize == sizeof(struct __pyx_obj_7pymusic___pyx_scope_struct____iter__)))) {
    __pyx_freelist_7pymusic___pyx_scope_struct____iter__[__pyx_freecount_7pymusic___pyx_scope_struct____iter__++] = ((struct __pyx_obj_7pymusic___pyx_scope_struct____iter__ *)o);
  } else {
    (*Py_TYPE(o)->tp_free)(o);
  }
}

static int __pyx_tp_traverse_7pymusic___pyx_scope_struct____iter__(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_7pymusic___pyx_scope_struct____iter__ *p = (struct __pyx_obj_7pymusic___pyx_scope_struct____iter__ *)o;
  if (p->__pyx_v_self) {
    e = (*v)(((PyObject*)p->__pyx_v_self), a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_7pymusic___pyx_scope_struct____iter__(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_7pymusic___pyx_scope_struct____iter__ *p = (struct __pyx_obj_7pymusic___pyx_scope_struct____iter__ *)o;
  tmp = ((PyObject*)p->__pyx_v_self);
  p->__pyx_v_self = ((struct __pyx_obj_7pymusic_Runtime *)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyTypeObject __pyx_type_7pymusic___pyx_scope_struct____iter__ = {
  PyVarObject_HEAD_INIT(0, 0)
  "pymusic.__pyx_scope_struct____iter__", /*tp_name*/
  sizeof(struct __pyx_obj_7pymusic___pyx_scope_struct____iter__), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_7pymusic___pyx_scope_struct____iter__, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #else
  0, /*reserved*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_7pymusic___pyx_scope_struct____iter__, /*tp_traverse*/
  __pyx_tp_clear_7pymusic___pyx_scope_struct____iter__, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_7pymusic___pyx_scope_struct____iter__, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static PyMethodDef __pyx_methods[] = {
  {0, 0, 0, 0}
};

#if PY_MAJOR_VERSION >= 3
static struct PyModuleDef __pyx_moduledef = {
  #if PY_VERSION_HEX < 0x03020000
    { PyObject_HEAD_INIT(NULL) NULL, 0, NULL },
  #else
    PyModuleDef_HEAD_INIT,
  #endif
    "pymusic",
    0, /* m_doc */
    -1, /* m_size */
    __pyx_methods /* m_methods */,
    NULL, /* m_reload */
    NULL, /* m_traverse */
    NULL, /* m_clear */
    NULL /* m_free */
};
#endif

static __Pyx_StringTabEntry __pyx_string_tab[] = {
  {&__pyx_kp_s_All_exceptions_in_pymusic_are_M, __pyx_k_All_exceptions_in_pymusic_are_M, sizeof(__pyx_k_All_exceptions_in_pymusic_are_M), 0, 0, 1, 0},
  {&__pyx_n_s_Buffer, __pyx_k_Buffer, sizeof(__pyx_k_Buffer), 0, 0, 1, 1},
  {&__pyx_n_s_COMM_NULL, __pyx_k_COMM_NULL, sizeof(__pyx_k_COMM_NULL), 0, 0, 1, 1},
  {&__pyx_kp_s_Config_variable_is_not_defined, __pyx_k_Config_variable_is_not_defined, sizeof(__pyx_k_Config_variable_is_not_defined), 0, 0, 1, 0},
  {&__pyx_n_s_Exception, __pyx_k_Exception, sizeof(__pyx_k_Exception), 0, 0, 1, 1},
  {&__pyx_n_s_GLOBAL, __pyx_k_GLOBAL, sizeof(__pyx_k_GLOBAL), 0, 0, 1, 1},
  {&__pyx_n_s_HIGHEST_PROTOCOL, __pyx_k_HIGHEST_PROTOCOL, sizeof(__pyx_k_HIGHEST_PROTOCOL), 0, 0, 1, 1},
  {&__pyx_n_s_Index, __pyx_k_Index, sizeof(__pyx_k_Index), 0, 0, 1, 1},
  {&__pyx_n_s_LOCAL, __pyx_k_LOCAL, sizeof(__pyx_k_LOCAL), 0, 0, 1, 1},
  {&__pyx_n_s_MPI, __pyx_k_MPI, sizeof(__pyx_k_MPI), 0, 0, 1, 1},
  {&__pyx_n_s_MUSICError, __pyx_k_MUSICError, sizeof(__pyx_k_MUSICError), 0, 0, 1, 1},
  {&__pyx_n_s_MemoryError, __pyx_k_MemoryError, sizeof(__pyx_k_MemoryError), 0, 0, 1, 1},
  {&__pyx_n_s_NoWidth, __pyx_k_NoWidth, sizeof(__pyx_k_NoWidth), 0, 0, 1, 1},
  {&__pyx_n_s_NoWidth___init, __pyx_k_NoWidth___init, sizeof(__pyx_k_NoWidth___init), 0, 0, 1, 1},
  {&__pyx_kp_s_No_width_defined, __pyx_k_No_width_defined, sizeof(__pyx_k_No_width_defined), 0, 0, 1, 0},
  {&__pyx_n_s_Runtime___iter, __pyx_k_Runtime___iter, sizeof(__pyx_k_Runtime___iter), 0, 0, 1, 1},
  {&__pyx_kp_s_Thrown_if_Port_width_is_called, __pyx_k_Thrown_if_Port_width_is_called, sizeof(__pyx_k_Thrown_if_Port_width_is_called), 0, 0, 1, 0},
  {&__pyx_kp_s_Thrown_if_a_configuration_value, __pyx_k_Thrown_if_a_configuration_value, sizeof(__pyx_k_Thrown_if_a_configuration_value), 0, 0, 1, 0},
  {&__pyx_n_s_UndefinedConfig, __pyx_k_UndefinedConfig, sizeof(__pyx_k_UndefinedConfig), 0, 0, 1, 1},
  {&__pyx_n_s_UndefinedConfig___init, __pyx_k_UndefinedConfig___init, sizeof(__pyx_k_UndefinedConfig___init), 0, 0, 1, 1},
  {&__pyx_n_s_ValueError, __pyx_k_ValueError, sizeof(__pyx_k_ValueError), 0, 0, 1, 1},
  {&__pyx_n_s__3, __pyx_k__3, sizeof(__pyx_k__3), 0, 0, 1, 1},
  {&__pyx_n_s_accLatency, __pyx_k_accLatency, sizeof(__pyx_k_accLatency), 0, 0, 1, 1},
  {&__pyx_n_s_args, __pyx_k_args, sizeof(__pyx_k_args), 0, 0, 1, 1},
  {&__pyx_n_s_argv, __pyx_k_argv, sizeof(__pyx_k_argv), 0, 0, 1, 1},
  {&__pyx_kp_s_argv_can_t_be_empty, __pyx_k_argv_can_t_be_empty, sizeof(__pyx_k_argv_can_t_be_empty), 0, 0, 1, 0},
  {&__pyx_n_s_array, __pyx_k_array, sizeof(__pyx_k_array), 0, 0, 1, 1},
  {&__pyx_n_s_base, __pyx_k_base, sizeof(__pyx_k_base), 0, 0, 1, 1},
  {&__pyx_n_s_buf, __pyx_k_buf, sizeof(__pyx_k_buf), 0, 0, 1, 1},
  {&__pyx_n_s_cPickle, __pyx_k_cPickle, sizeof(__pyx_k_cPickle), 0, 0, 1, 1},
  {&__pyx_n_s_close, __pyx_k_close, sizeof(__pyx_k_close), 0, 0, 1, 1},
  {&__pyx_kp_s_couldn_t_allocate_argv, __pyx_k_couldn_t_allocate_argv, sizeof(__pyx_k_couldn_t_allocate_argv), 0, 0, 1, 0},
  {&__pyx_n_s_data, __pyx_k_data, sizeof(__pyx_k_data), 0, 0, 1, 1},
  {&__pyx_n_s_delay, __pyx_k_delay, sizeof(__pyx_k_delay), 0, 0, 1, 1},
  {&__pyx_n_s_doc, __pyx_k_doc, sizeof(__pyx_k_doc), 0, 0, 1, 1},
  {&__pyx_n_s_dumps, __pyx_k_dumps, sizeof(__pyx_k_dumps), 0, 0, 1, 1},
  {&__pyx_n_s_encode, __pyx_k_encode, sizeof(__pyx_k_encode), 0, 0, 1, 1},
  {&__pyx_n_s_format, __pyx_k_format, sizeof(__pyx_k_format), 0, 0, 1, 1},
  {&__pyx_n_s_func, __pyx_k_func, sizeof(__pyx_k_func), 0, 0, 1, 1},
  {&__pyx_n_s_getcomm, __pyx_k_getcomm, sizeof(__pyx_k_getcomm), 0, 0, 1, 1},
  {&__pyx_n_s_h, __pyx_k_h, sizeof(__pyx_k_h), 0, 0, 1, 1},
  {&__pyx_kp_s_home_apeyser_Code_music_pymusic, __pyx_k_home_apeyser_Code_music_pymusic, sizeof(__pyx_k_home_apeyser_Code_music_pymusic), 0, 0, 1, 0},
  {&__pyx_n_s_i, __pyx_k_i, sizeof(__pyx_k_i), 0, 0, 1, 1},
  {&__pyx_n_s_import, __pyx_k_import, sizeof(__pyx_k_import), 0, 0, 1, 1},
  {&__pyx_n_s_index, __pyx_k_index, sizeof(__pyx_k_index), 0, 0, 1, 1},
  {&__pyx_n_s_index_map, __pyx_k_index_map, sizeof(__pyx_k_index_map), 0, 0, 1, 1},
  {&__pyx_n_s_init, __pyx_k_init, sizeof(__pyx_k_init), 0, 0, 1, 1},
  {&__pyx_n_s_interpolate, __pyx_k_interpolate, sizeof(__pyx_k_interpolate), 0, 0, 1, 1},
  {&__pyx_n_s_iter, __pyx_k_iter, sizeof(__pyx_k_iter), 0, 0, 1, 1},
  {&__pyx_n_s_loads, __pyx_k_loads, sizeof(__pyx_k_loads), 0, 0, 1, 1},
  {&__pyx_n_s_main, __pyx_k_main, sizeof(__pyx_k_main), 0, 0, 1, 1},
  {&__pyx_n_s_maxBuffered, __pyx_k_maxBuffered, sizeof(__pyx_k_maxBuffered), 0, 0, 1, 1},
  {&__pyx_n_s_metaclass, __pyx_k_metaclass, sizeof(__pyx_k_metaclass), 0, 0, 1, 1},
  {&__pyx_n_s_module, __pyx_k_module, sizeof(__pyx_k_module), 0, 0, 1, 1},
  {&__pyx_n_s_mpi4py_MPI, __pyx_k_mpi4py_MPI, sizeof(__pyx_k_mpi4py_MPI), 0, 0, 1, 1},
  {&__pyx_n_s_msg, __pyx_k_msg, sizeof(__pyx_k_msg), 0, 0, 1, 1},
  {&__pyx_n_s_music_pybuffer, __pyx_k_music_pybuffer, sizeof(__pyx_k_music_pybuffer), 0, 0, 1, 1},
  {&__pyx_n_s_null, __pyx_k_null, sizeof(__pyx_k_null), 0, 0, 1, 1},
  {&__pyx_n_s_perm, __pyx_k_perm, sizeof(__pyx_k_perm), 0, 0, 1, 1},
  {&__pyx_n_s_pickle, __pyx_k_pickle, sizeof(__pyx_k_pickle), 0, 0, 1, 1},
  {&__pyx_n_s_pickled, __pyx_k_pickled, sizeof(__pyx_k_pickled), 0, 0, 1, 1},
  {&__pyx_n_s_predictRank, __pyx_k_predictRank, sizeof(__pyx_k_predictRank), 0, 0, 1, 1},
  {&__pyx_n_s_prepare, __pyx_k_prepare, sizeof(__pyx_k_prepare), 0, 0, 1, 1},
  {&__pyx_n_s_ptr, __pyx_k_ptr, sizeof(__pyx_k_ptr), 0, 0, 1, 1},
  {&__pyx_n_s_pymusic, __pyx_k_pymusic, sizeof(__pyx_k_pymusic), 0, 0, 1, 1},
  {&__pyx_n_s_pyx_vtable, __pyx_k_pyx_vtable, sizeof(__pyx_k_pyx_vtable), 0, 0, 1, 1},
  {&__pyx_n_s_qualname, __pyx_k_qualname, sizeof(__pyx_k_qualname), 0, 0, 1, 1},
  {&__pyx_n_s_r, __pyx_k_r, sizeof(__pyx_k_r), 0, 0, 1, 1},
  {&__pyx_n_s_range, __pyx_k_range, sizeof(__pyx_k_range), 0, 0, 1, 1},
  {&__pyx_n_s_required, __pyx_k_required, sizeof(__pyx_k_required), 0, 0, 1, 1},
  {&__pyx_n_s_self, __pyx_k_self, sizeof(__pyx_k_self), 0, 0, 1, 1},
  {&__pyx_n_s_send, __pyx_k_send, sizeof(__pyx_k_send), 0, 0, 1, 1},
  {&__pyx_n_s_setup, __pyx_k_setup, sizeof(__pyx_k_setup), 0, 0, 1, 1},
  {&__pyx_n_s_size, __pyx_k_size, sizeof(__pyx_k_size), 0, 0, 1, 1},
  {&__pyx_n_s_sys, __pyx_k_sys, sizeof(__pyx_k_sys), 0, 0, 1, 1},
  {&__pyx_n_s_t, __pyx_k_t, sizeof(__pyx_k_t), 0, 0, 1, 1},
  {&__pyx_n_s_test, __pyx_k_test, sizeof(__pyx_k_test), 0, 0, 1, 1},
  {&__pyx_n_s_throw, __pyx_k_throw, sizeof(__pyx_k_throw), 0, 0, 1, 1},
  {&__pyx_n_s_time, __pyx_k_time, sizeof(__pyx_k_time), 0, 0, 1, 1},
  {&__pyx_n_s_var, __pyx_k_var, sizeof(__pyx_k_var), 0, 0, 1, 1},
  {&__pyx_n_s_xrange, __pyx_k_xrange, sizeof(__pyx_k_xrange), 0, 0, 1, 1},
  {0, 0, 0, 0, 0, 0, 0}
};
static int __Pyx_InitCachedBuiltins(void) {
  __pyx_builtin_Exception = __Pyx_GetBuiltinName(__pyx_n_s_Exception); if (!__pyx_builtin_Exception) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 69; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #if PY_MAJOR_VERSION >= 3
  __pyx_builtin_xrange = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_xrange) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 381; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #else
  __pyx_builtin_xrange = __Pyx_GetBuiltinName(__pyx_n_s_xrange); if (!__pyx_builtin_xrange) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 381; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #endif
  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 439; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_MemoryError = __Pyx_GetBuiltinName(__pyx_n_s_MemoryError); if (!__pyx_builtin_MemoryError) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 107; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  return 0;
  __pyx_L1_error:;
  return -1;
}

static int __Pyx_InitCachedConstants(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);

  /* "pymusic.pyx":60
 *     r.argc = len(argv)
 *     if r.argc <= 0:
 *         raise MUSICError("argv can't be empty")             # <<<<<<<<<<<<<<
 * 
 *     r.argv = <char**> malloc((r.argc+1) * sizeof(char*))
 */
  __pyx_tuple_ = PyTuple_Pack(1, __pyx_kp_s_argv_can_t_be_empty); if (unlikely(!__pyx_tuple_)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 60; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple_);
  __Pyx_GIVEREF(__pyx_tuple_);

  /* "pymusic.pyx":64
 *     r.argv = <char**> malloc((r.argc+1) * sizeof(char*))
 *     if r.argv is NULL:
 *         raise MUSICError("couldn't allocate argv")             # <<<<<<<<<<<<<<
 * 
 *     cdef string
 */
  __pyx_tuple__2 = PyTuple_Pack(1, __pyx_kp_s_couldn_t_allocate_argv); if (unlikely(!__pyx_tuple__2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 64; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__2);
  __Pyx_GIVEREF(__pyx_tuple__2);

  /* "pymusic.pyx":23
 *     have a width defined.
 *     """
 *     def __init__(self):             # <<<<<<<<<<<<<<
 *         MUSICError.__init__(self, "No width defined")
 * 
 */
  __pyx_tuple__4 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 23; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__4);
  __Pyx_GIVEREF(__pyx_tuple__4);
  __pyx_codeobj__5 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__4, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_home_apeyser_Code_music_pymusic, __pyx_n_s_init, 23, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 23; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "pymusic.pyx":32
 *     that has not been defined within the configuration.
 *     """
 *     def __init__(self, var):             # <<<<<<<<<<<<<<
 *         MUSICError.__init__(
 *             self,
 */
  __pyx_tuple__6 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_var); if (unlikely(!__pyx_tuple__6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 32; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__6);
  __Pyx_GIVEREF(__pyx_tuple__6);
  __pyx_codeobj__7 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__6, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_home_apeyser_Code_music_pymusic, __pyx_n_s_init, 32, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 32; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "pymusic.pyx":79
 * ###########################################################
 * 
 * def predictRank(list argv=None):             # <<<<<<<<<<<<<<
 *     """
 *     Map into mpidep/predict_rank for config methods.
 */
  __pyx_tuple__8 = PyTuple_Pack(2, __pyx_n_s_argv, __pyx_n_s_r); if (unlikely(!__pyx_tuple__8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 79; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_tuple__8);
  __Pyx_GIVEREF(__pyx_tuple__8);
  __pyx_codeobj__9 = (PyObject*)__Pyx_PyCode_New(1, 0, 2, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__8, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_home_apeyser_Code_music_pymusic, __pyx_n_s_predictRank, 79, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 79; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_RefNannyFinishContext();
  return 0;
  __pyx_L1_error:;
  __Pyx_RefNannyFinishContext();
  return -1;
}

static int __Pyx_InitGlobals(void) {
  if (__Pyx_InitStrings(__pyx_string_tab) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  return 0;
  __pyx_L1_error:;
  return -1;
}

#if PY_MAJOR_VERSION < 3
PyMODINIT_FUNC initpymusic(void); /*proto*/
PyMODINIT_FUNC initpymusic(void)
#else
PyMODINIT_FUNC PyInit_pymusic(void); /*proto*/
PyMODINIT_FUNC PyInit_pymusic(void)
#endif
{
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannyDeclarations
  #if CYTHON_REFNANNY
  __Pyx_RefNanny = __Pyx_RefNannyImportAPI("refnanny");
  if (!__Pyx_RefNanny) {
      PyErr_Clear();
      __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
      if (!__Pyx_RefNanny)
          Py_FatalError("failed to import 'refnanny' module");
  }
  #endif
  __Pyx_RefNannySetupContext("PyMODINIT_FUNC PyInit_pymusic(void)", 0);
  if ( __Pyx_check_binary_version() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #ifdef __Pyx_CyFunction_USED
  if (__Pyx_CyFunction_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #endif
  #ifdef __Pyx_FusedFunction_USED
  if (__pyx_FusedFunction_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #endif
  #ifdef __Pyx_Generator_USED
  if (__pyx_Generator_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #endif
  /*--- Library function declarations ---*/
  /*--- Threads initialization code ---*/
  #if defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
  #ifdef WITH_THREAD /* Python build with threading support? */
  PyEval_InitThreads();
  #endif
  #endif
  /*--- Module creation code ---*/
  #if PY_MAJOR_VERSION < 3
  __pyx_m = Py_InitModule4("pymusic", __pyx_methods, 0, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
  #else
  __pyx_m = PyModule_Create(&__pyx_moduledef);
  #endif
  if (unlikely(!__pyx_m)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  Py_INCREF(__pyx_d);
  __pyx_b = PyImport_AddModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_b)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #if CYTHON_COMPILING_IN_PYPY
  Py_INCREF(__pyx_b);
  #endif
  if (PyObject_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  /*--- Initialize various global constants etc. ---*/
  if (unlikely(__Pyx_InitGlobals() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
  if (__Pyx_init_sys_getdefaultencoding_params() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #endif
  if (__pyx_module_is_main_pymusic) {
    if (PyObject_SetAttrString(__pyx_m, "__name__", __pyx_n_s_main) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  }
  #if PY_MAJOR_VERSION >= 3
  {
    PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    if (!PyDict_GetItemString(modules, "pymusic")) {
      if (unlikely(PyDict_SetItemString(modules, "pymusic", __pyx_m) < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    }
  }
  #endif
  /*--- Builtin init code ---*/
  if (unlikely(__Pyx_InitCachedBuiltins() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  /*--- Constants init code ---*/
  if (unlikely(__Pyx_InitCachedConstants() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  /*--- Global init code ---*/
  /*--- Variable export code ---*/
  /*--- Function export code ---*/
  if (__Pyx_ExportFunction("EventCallback", (void (*)(void))MUSIC::EventCallback, "bool (PyObject *, double, MUSIC::Index::Type, int)") < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__Pyx_ExportFunction("MessageCallback", (void (*)(void))MUSIC::MessageCallback, "bool (PyObject *, double, void *, size_t, bool)") < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  /*--- Type init code ---*/
  __pyx_vtabptr_7pymusic_Setup = &__pyx_vtable_7pymusic_Setup;
  __pyx_vtable_7pymusic_Setup.null = (PyObject *(*)(struct __pyx_obj_7pymusic_Setup *))__pyx_f_7pymusic_5Setup_null;
  __pyx_vtable_7pymusic_Setup.getcomm = (struct PyMPIIntracommObject *(*)(struct __pyx_obj_7pymusic_Setup *, int __pyx_skip_dispatch))__pyx_f_7pymusic_5Setup_getcomm;
  if (PyType_Ready(&__pyx_type_7pymusic_Setup) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 348; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_type_7pymusic_Setup.tp_print = 0;
  if (__Pyx_SetVtable(__pyx_type_7pymusic_Setup.tp_dict, __pyx_vtabptr_7pymusic_Setup) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 348; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyObject_SetAttrString(__pyx_m, "Setup", (PyObject *)&__pyx_type_7pymusic_Setup) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 348; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_7pymusic_Setup = &__pyx_type_7pymusic_Setup;
  if (PyType_Ready(&__pyx_type_7pymusic_Runtime) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 517; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_type_7pymusic_Runtime.tp_print = 0;
  if (PyObject_SetAttrString(__pyx_m, "Runtime", (PyObject *)&__pyx_type_7pymusic_Runtime) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 517; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_7pymusic_Runtime = &__pyx_type_7pymusic_Runtime;
  __pyx_vtabptr_7pymusic_Port = &__pyx_vtable_7pymusic_Port;
  __pyx_vtable_7pymusic_Port.null = (PyObject *(*)(struct __pyx_obj_7pymusic_Port *, int __pyx_skip_dispatch))__pyx_f_7pymusic_4Port_null;
  if (PyType_Ready(&__pyx_type_7pymusic_Port) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 90; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_type_7pymusic_Port.tp_print = 0;
  #if CYTHON_COMPILING_IN_CPYTHON
  {
    PyObject *wrapper = PyObject_GetAttrString((PyObject *)&__pyx_type_7pymusic_Port, "__hash__"); if (unlikely(!wrapper)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 90; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    if (Py_TYPE(wrapper) == &PyWrapperDescr_Type) {
      __pyx_wrapperbase_7pymusic_4Port_2__hash__ = *((PyWrapperDescrObject *)wrapper)->d_base;
      __pyx_wrapperbase_7pymusic_4Port_2__hash__.doc = __pyx_doc_7pymusic_4Port_2__hash__;
      ((PyWrapperDescrObject *)wrapper)->d_base = &__pyx_wrapperbase_7pymusic_4Port_2__hash__;
    }
  }
  #endif
  if (__Pyx_SetVtable(__pyx_type_7pymusic_Port.tp_dict, __pyx_vtabptr_7pymusic_Port) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 90; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyObject_SetAttrString(__pyx_m, "Port", (PyObject *)&__pyx_type_7pymusic_Port) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 90; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_7pymusic_Port = &__pyx_type_7pymusic_Port;
  __pyx_vtabptr_7pymusic_ContInputPort = &__pyx_vtable_7pymusic_ContInputPort;
  __pyx_vtable_7pymusic_ContInputPort.__pyx_base = *__pyx_vtabptr_7pymusic_Port;
  __pyx_type_7pymusic_ContInputPort.tp_base = __pyx_ptype_7pymusic_Port;
  if (PyType_Ready(&__pyx_type_7pymusic_ContInputPort) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 138; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_type_7pymusic_ContInputPort.tp_print = 0;
  if (__Pyx_SetVtable(__pyx_type_7pymusic_ContInputPort.tp_dict, __pyx_vtabptr_7pymusic_ContInputPort) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 138; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyObject_SetAttrString(__pyx_m, "ContInputPort", (PyObject *)&__pyx_type_7pymusic_ContInputPort) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 138; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_7pymusic_ContInputPort = &__pyx_type_7pymusic_ContInputPort;
  __pyx_vtabptr_7pymusic_ContOutputPort = &__pyx_vtable_7pymusic_ContOutputPort;
  __pyx_vtable_7pymusic_ContOutputPort.__pyx_base = *__pyx_vtabptr_7pymusic_Port;
  __pyx_type_7pymusic_ContOutputPort.tp_base = __pyx_ptype_7pymusic_Port;
  if (PyType_Ready(&__pyx_type_7pymusic_ContOutputPort) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 178; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_type_7pymusic_ContOutputPort.tp_print = 0;
  if (__Pyx_SetVtable(__pyx_type_7pymusic_ContOutputPort.tp_dict, __pyx_vtabptr_7pymusic_ContOutputPort) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 178; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyObject_SetAttrString(__pyx_m, "ContOutputPort", (PyObject *)&__pyx_type_7pymusic_ContOutputPort) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 178; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_7pymusic_ContOutputPort = &__pyx_type_7pymusic_ContOutputPort;
  __pyx_vtabptr_7pymusic_EventInputPort = &__pyx_vtable_7pymusic_EventInputPort;
  __pyx_vtable_7pymusic_EventInputPort.__pyx_base = *__pyx_vtabptr_7pymusic_Port;
  __pyx_vtable_7pymusic_EventInputPort.__pyx_base.null = (PyObject *(*)(struct __pyx_obj_7pymusic_Port *, int __pyx_skip_dispatch))__pyx_f_7pymusic_14EventInputPort_null;
  __pyx_type_7pymusic_EventInputPort.tp_base = __pyx_ptype_7pymusic_Port;
  if (PyType_Ready(&__pyx_type_7pymusic_EventInputPort) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 207; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_type_7pymusic_EventInputPort.tp_print = 0;
  if (__Pyx_SetVtable(__pyx_type_7pymusic_EventInputPort.tp_dict, __pyx_vtabptr_7pymusic_EventInputPort) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 207; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyObject_SetAttrString(__pyx_m, "EventInputPort", (PyObject *)&__pyx_type_7pymusic_EventInputPort) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 207; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_7pymusic_EventInputPort = &__pyx_type_7pymusic_EventInputPort;
  __pyx_vtabptr_7pymusic_EventOutputPort = &__pyx_vtable_7pymusic_EventOutputPort;
  __pyx_vtable_7pymusic_EventOutputPort.__pyx_base = *__pyx_vtabptr_7pymusic_Port;
  __pyx_type_7pymusic_EventOutputPort.tp_base = __pyx_ptype_7pymusic_Port;
  if (PyType_Ready(&__pyx_type_7pymusic_EventOutputPort) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 252; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_type_7pymusic_EventOutputPort.tp_print = 0;
  if (__Pyx_SetVtable(__pyx_type_7pymusic_EventOutputPort.tp_dict, __pyx_vtabptr_7pymusic_EventOutputPort) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 252; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyObject_SetAttrString(__pyx_m, "EventOutputPort", (PyObject *)&__pyx_type_7pymusic_EventOutputPort) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 252; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_7pymusic_EventOutputPort = &__pyx_type_7pymusic_EventOutputPort;
  __pyx_vtabptr_7pymusic_MessageInputPort = &__pyx_vtable_7pymusic_MessageInputPort;
  __pyx_vtable_7pymusic_MessageInputPort.__pyx_base = *__pyx_vtabptr_7pymusic_Port;
  __pyx_vtable_7pymusic_MessageInputPort.__pyx_base.null = (PyObject *(*)(struct __pyx_obj_7pymusic_Port *, int __pyx_skip_dispatch))__pyx_f_7pymusic_16MessageInputPort_null;
  __pyx_type_7pymusic_MessageInputPort.tp_base = __pyx_ptype_7pymusic_Port;
  if (PyType_Ready(&__pyx_type_7pymusic_MessageInputPort) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 277; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_type_7pymusic_MessageInputPort.tp_print = 0;
  if (__Pyx_SetVtable(__pyx_type_7pymusic_MessageInputPort.tp_dict, __pyx_vtabptr_7pymusic_MessageInputPort) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 277; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyObject_SetAttrString(__pyx_m, "MessageInputPort", (PyObject *)&__pyx_type_7pymusic_MessageInputPort) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 277; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_7pymusic_MessageInputPort = &__pyx_type_7pymusic_MessageInputPort;
  __pyx_vtabptr_7pymusic_MessageOutputPort = &__pyx_vtable_7pymusic_MessageOutputPort;
  __pyx_vtable_7pymusic_MessageOutputPort.__pyx_base = *__pyx_vtabptr_7pymusic_Port;
  __pyx_type_7pymusic_MessageOutputPort.tp_base = __pyx_ptype_7pymusic_Port;
  if (PyType_Ready(&__pyx_type_7pymusic_MessageOutputPort) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 313; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_type_7pymusic_MessageOutputPort.tp_print = 0;
  if (__Pyx_SetVtable(__pyx_type_7pymusic_MessageOutputPort.tp_dict, __pyx_vtabptr_7pymusic_MessageOutputPort) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 313; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (PyObject_SetAttrString(__pyx_m, "MessageOutputPort", (PyObject *)&__pyx_type_7pymusic_MessageOutputPort) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 313; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_7pymusic_MessageOutputPort = &__pyx_type_7pymusic_MessageOutputPort;
  if (PyType_Ready(&__pyx_type_7pymusic_DataMap) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 585; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_type_7pymusic_DataMap.tp_print = 0;
  if (PyObject_SetAttrString(__pyx_m, "DataMap", (PyObject *)&__pyx_type_7pymusic_DataMap) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 585; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_7pymusic_DataMap = &__pyx_type_7pymusic_DataMap;
  if (PyType_Ready(&__pyx_type_7pymusic_IndexMap) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 551; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_type_7pymusic_IndexMap.tp_print = 0;
  if (PyObject_SetAttrString(__pyx_m, "IndexMap", (PyObject *)&__pyx_type_7pymusic_IndexMap) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 551; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_7pymusic_IndexMap = &__pyx_type_7pymusic_IndexMap;
  if (PyType_Ready(&__pyx_type_7pymusic_EventHandler) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 610; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_type_7pymusic_EventHandler.tp_print = 0;
  if (PyObject_SetAttrString(__pyx_m, "EventHandler", (PyObject *)&__pyx_type_7pymusic_EventHandler) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 610; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_7pymusic_EventHandler = &__pyx_type_7pymusic_EventHandler;
  if (PyType_Ready(&__pyx_type_7pymusic_MessageHandler) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 679; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_type_7pymusic_MessageHandler.tp_print = 0;
  if (PyObject_SetAttrString(__pyx_m, "MessageHandler", (PyObject *)&__pyx_type_7pymusic_MessageHandler) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 679; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_7pymusic_MessageHandler = &__pyx_type_7pymusic_MessageHandler;
  if (PyType_Ready(&__pyx_type_7pymusic__Index) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 636; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_type_7pymusic__Index.tp_print = 0;
  if (PyObject_SetAttrString(__pyx_m, "_Index", (PyObject *)&__pyx_type_7pymusic__Index) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 636; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_7pymusic__Index = &__pyx_type_7pymusic__Index;
  if (PyType_Ready(&__pyx_type_7pymusic___pyx_scope_struct____iter__) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 538; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_type_7pymusic___pyx_scope_struct____iter__.tp_print = 0;
  __pyx_ptype_7pymusic___pyx_scope_struct____iter__ = &__pyx_type_7pymusic___pyx_scope_struct____iter__;
  /*--- Type import code ---*/
  __pyx_ptype_6mpi4py_3MPI_Status = __Pyx_ImportType("mpi4py.MPI", "Status", sizeof(struct PyMPIStatusObject), 1); if (unlikely(!__pyx_ptype_6mpi4py_3MPI_Status)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 49; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_6mpi4py_3MPI_Datatype = __Pyx_ImportType("mpi4py.MPI", "Datatype", sizeof(struct PyMPIDatatypeObject), 1); if (unlikely(!__pyx_ptype_6mpi4py_3MPI_Datatype)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 56; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_6mpi4py_3MPI_Request = __Pyx_ImportType("mpi4py.MPI", "Request", sizeof(struct PyMPIRequestObject), 1); if (unlikely(!__pyx_ptype_6mpi4py_3MPI_Request)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 63; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_6mpi4py_3MPI_Prequest = __Pyx_ImportType("mpi4py.MPI", "Prequest", sizeof(struct PyMPIPrequestObject), 1); if (unlikely(!__pyx_ptype_6mpi4py_3MPI_Prequest)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 71; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_6mpi4py_3MPI_Grequest = __Pyx_ImportType("mpi4py.MPI", "Grequest", sizeof(struct PyMPIGrequestObject), 1); if (unlikely(!__pyx_ptype_6mpi4py_3MPI_Grequest)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 77; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_6mpi4py_3MPI_Op = __Pyx_ImportType("mpi4py.MPI", "Op", sizeof(struct PyMPIOpObject), 1); if (unlikely(!__pyx_ptype_6mpi4py_3MPI_Op)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 83; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_6mpi4py_3MPI_Group = __Pyx_ImportType("mpi4py.MPI", "Group", sizeof(struct PyMPIGroupObject), 1); if (unlikely(!__pyx_ptype_6mpi4py_3MPI_Group)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 92; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_6mpi4py_3MPI_Info = __Pyx_ImportType("mpi4py.MPI", "Info", sizeof(struct PyMPIInfoObject), 1); if (unlikely(!__pyx_ptype_6mpi4py_3MPI_Info)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 99; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_6mpi4py_3MPI_Errhandler = __Pyx_ImportType("mpi4py.MPI", "Errhandler", sizeof(struct PyMPIErrhandlerObject), 1); if (unlikely(!__pyx_ptype_6mpi4py_3MPI_Errhandler)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 106; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_6mpi4py_3MPI_Comm = __Pyx_ImportType("mpi4py.MPI", "Comm", sizeof(struct PyMPICommObject), 1); if (unlikely(!__pyx_ptype_6mpi4py_3MPI_Comm)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 113; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_6mpi4py_3MPI_Intracomm = __Pyx_ImportType("mpi4py.MPI", "Intracomm", sizeof(struct PyMPIIntracommObject), 1); if (unlikely(!__pyx_ptype_6mpi4py_3MPI_Intracomm)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 120; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_6mpi4py_3MPI_Cartcomm = __Pyx_ImportType("mpi4py.MPI", "Cartcomm", sizeof(struct PyMPICartcommObject), 1); if (unlikely(!__pyx_ptype_6mpi4py_3MPI_Cartcomm)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 126; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_6mpi4py_3MPI_Graphcomm = __Pyx_ImportType("mpi4py.MPI", "Graphcomm", sizeof(struct PyMPIGraphcommObject), 1); if (unlikely(!__pyx_ptype_6mpi4py_3MPI_Graphcomm)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 132; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_6mpi4py_3MPI_Distgraphcomm = __Pyx_ImportType("mpi4py.MPI", "Distgraphcomm", sizeof(struct PyMPIDistgraphcommObject), 1); if (unlikely(!__pyx_ptype_6mpi4py_3MPI_Distgraphcomm)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 138; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_6mpi4py_3MPI_Intercomm = __Pyx_ImportType("mpi4py.MPI", "Intercomm", sizeof(struct PyMPIIntercommObject), 1); if (unlikely(!__pyx_ptype_6mpi4py_3MPI_Intercomm)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 144; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_6mpi4py_3MPI_Win = __Pyx_ImportType("mpi4py.MPI", "Win", sizeof(struct PyMPIWinObject), 1); if (unlikely(!__pyx_ptype_6mpi4py_3MPI_Win)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 150; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_6mpi4py_3MPI_File = __Pyx_ImportType("mpi4py.MPI", "File", sizeof(struct PyMPIFileObject), 1); if (unlikely(!__pyx_ptype_6mpi4py_3MPI_File)) {__pyx_filename = __pyx_f[4]; __pyx_lineno = 157; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_5music_8pybuffer_Buffer = __Pyx_ImportType("music.pybuffer", "Buffer", sizeof(struct __pyx_obj_5music_8pybuffer_Buffer), 1); if (unlikely(!__pyx_ptype_5music_8pybuffer_Buffer)) {__pyx_filename = __pyx_f[5]; __pyx_lineno = 40; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType(__Pyx_BUILTIN_MODULE_NAME, "type", 
  #if CYTHON_COMPILING_IN_PYPY
  sizeof(PyTypeObject),
  #else
  sizeof(PyHeapTypeObject),
  #endif
  0); if (unlikely(!__pyx_ptype_7cpython_4type_type)) {__pyx_filename = __pyx_f[6]; __pyx_lineno = 9; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_7cpython_4bool_bool = __Pyx_ImportType(__Pyx_BUILTIN_MODULE_NAME, "bool", sizeof(PyBoolObject), 0); if (unlikely(!__pyx_ptype_7cpython_4bool_bool)) {__pyx_filename = __pyx_f[7]; __pyx_lineno = 8; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_7cpython_7complex_complex = __Pyx_ImportType(__Pyx_BUILTIN_MODULE_NAME, "complex", sizeof(PyComplexObject), 0); if (unlikely(!__pyx_ptype_7cpython_7complex_complex)) {__pyx_filename = __pyx_f[8]; __pyx_lineno = 15; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_7cpython_5array_array = __Pyx_ImportType("array", "array", sizeof(arrayobject), 0); if (unlikely(!__pyx_ptype_7cpython_5array_array)) {__pyx_filename = __pyx_f[1]; __pyx_lineno = 58; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  /*--- Variable import code ---*/
  /*--- Function import code ---*/
  /*--- Execution code ---*/

  /* "pymusic.pyx":7
 * from libc.stdlib cimport malloc, free
 * 
 * import mpi4py.MPI as MPI             # <<<<<<<<<<<<<<
 * import cPickle as pickle
 * 
 */
  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_n_s__3);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s__3);
  __Pyx_GIVEREF(__pyx_n_s__3);
  __pyx_t_2 = __Pyx_Import(__pyx_n_s_mpi4py_MPI, __pyx_t_1, -1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_MPI, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 7; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "pymusic.pyx":8
 * 
 * import mpi4py.MPI as MPI
 * import cPickle as pickle             # <<<<<<<<<<<<<<
 * 
 * ###########################################################
 */
  __pyx_t_2 = __Pyx_Import(__pyx_n_s_cPickle, 0, -1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_pickle, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 8; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "pymusic.pyx":12
 * ###########################################################
 * 
 * class MUSICError(Exception):             # <<<<<<<<<<<<<<
 *     """
 *     All exceptions in pymusic are MUSICError's
 */
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_builtin_Exception);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_builtin_Exception);
  __Pyx_GIVEREF(__pyx_builtin_Exception);
  __pyx_t_1 = __Pyx_CalculateMetaclass(NULL, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = __Pyx_Py3MetaclassPrepare(__pyx_t_1, __pyx_t_2, __pyx_n_s_MUSICError, __pyx_n_s_MUSICError, (PyObject *) NULL, __pyx_n_s_pymusic, __pyx_kp_s_All_exceptions_in_pymusic_are_M); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __Pyx_Py3ClassCreate(__pyx_t_1, __pyx_n_s_MUSICError, __pyx_t_2, __pyx_t_3, NULL, 0, 1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_MUSICError, __pyx_t_4) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 12; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "pymusic.pyx":18
 *     pass
 * 
 * class NoWidth(MUSICError):             # <<<<<<<<<<<<<<
 *     """
 *     Thrown if Port.width() is called, and port doesn't
 */
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_MUSICError); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 18; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 18; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_2);
  __Pyx_GIVEREF(__pyx_t_2);
  __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_CalculateMetaclass(NULL, __pyx_t_1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 18; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_Py3MetaclassPrepare(__pyx_t_2, __pyx_t_1, __pyx_n_s_NoWidth, __pyx_n_s_NoWidth, (PyObject *) NULL, __pyx_n_s_pymusic, __pyx_kp_s_Thrown_if_Port_width_is_called); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 18; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);

  /* "pymusic.pyx":23
 *     have a width defined.
 *     """
 *     def __init__(self):             # <<<<<<<<<<<<<<
 *         MUSICError.__init__(self, "No width defined")
 * 
 */
  __pyx_t_4 = __Pyx_CyFunction_NewEx(&__pyx_mdef_7pymusic_7NoWidth_1__init__, 0, __pyx_n_s_NoWidth___init, NULL, __pyx_n_s_pymusic, __pyx_d, ((PyObject *)__pyx_codeobj__5)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 23; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  if (PyObject_SetItem(__pyx_t_3, __pyx_n_s_init, __pyx_t_4) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 23; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "pymusic.pyx":18
 *     pass
 * 
 * class NoWidth(MUSICError):             # <<<<<<<<<<<<<<
 *     """
 *     Thrown if Port.width() is called, and port doesn't
 */
  __pyx_t_4 = __Pyx_Py3ClassCreate(__pyx_t_2, __pyx_n_s_NoWidth, __pyx_t_1, __pyx_t_3, NULL, 0, 1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 18; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_NoWidth, __pyx_t_4) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 18; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pymusic.pyx":26
 *         MUSICError.__init__(self, "No width defined")
 * 
 * class UndefinedConfig(MUSICError):             # <<<<<<<<<<<<<<
 *     """
 *     Thrown if a configuration value is requested
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_MUSICError); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 26; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 26; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_CalculateMetaclass(NULL, __pyx_t_2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 26; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_3 = __Pyx_Py3MetaclassPrepare(__pyx_t_1, __pyx_t_2, __pyx_n_s_UndefinedConfig, __pyx_n_s_UndefinedConfig, (PyObject *) NULL, __pyx_n_s_pymusic, __pyx_kp_s_Thrown_if_a_configuration_value); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 26; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);

  /* "pymusic.pyx":32
 *     that has not been defined within the configuration.
 *     """
 *     def __init__(self, var):             # <<<<<<<<<<<<<<
 *         MUSICError.__init__(
 *             self,
 */
  __pyx_t_4 = __Pyx_CyFunction_NewEx(&__pyx_mdef_7pymusic_15UndefinedConfig_1__init__, 0, __pyx_n_s_UndefinedConfig___init, NULL, __pyx_n_s_pymusic, __pyx_d, ((PyObject *)__pyx_codeobj__7)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 32; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  if (PyObject_SetItem(__pyx_t_3, __pyx_n_s_init, __pyx_t_4) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 32; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "pymusic.pyx":26
 *         MUSICError.__init__(self, "No width defined")
 * 
 * class UndefinedConfig(MUSICError):             # <<<<<<<<<<<<<<
 *     """
 *     Thrown if a configuration value is requested
 */
  __pyx_t_4 = __Pyx_Py3ClassCreate(__pyx_t_1, __pyx_n_s_UndefinedConfig, __pyx_t_2, __pyx_t_3, NULL, 0, 1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 26; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_UndefinedConfig, __pyx_t_4) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 26; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "pymusic.pyx":79
 * ###########################################################
 * 
 * def predictRank(list argv=None):             # <<<<<<<<<<<<<<
 *     """
 *     Map into mpidep/predict_rank for config methods.
 */
  __pyx_t_2 = PyCFunction_NewEx(&__pyx_mdef_7pymusic_1predictRank, NULL, __pyx_n_s_pymusic); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 79; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_predictRank, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 79; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "pymusic.pyx":347
 * ###########################################################
 * 
 * import sys             # <<<<<<<<<<<<<<
 * cdef class Setup(object):
 *     """
 */
  __pyx_t_2 = __Pyx_Import(__pyx_n_s_sys, 0, -1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 347; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_sys, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 347; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "pymusic.pyx":546
 * ###########################################################
 * 
 * from music.pybuffer import Buffer             # <<<<<<<<<<<<<<
 * 
 * from cpython cimport array
 */
  __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 546; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(__pyx_n_s_Buffer);
  PyList_SET_ITEM(__pyx_t_2, 0, __pyx_n_s_Buffer);
  __Pyx_GIVEREF(__pyx_n_s_Buffer);
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_music_pybuffer, __pyx_t_2, -1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 546; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pymusic.pyx":549
 * 
 * from cpython cimport array
 * from array import array             # <<<<<<<<<<<<<<
 * 
 * cdef class IndexMap:
 */
  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 549; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(__pyx_n_s_array);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_n_s_array);
  __Pyx_GIVEREF(__pyx_n_s_array);
  __pyx_t_2 = __Pyx_Import(__pyx_n_s_array, __pyx_t_1, -1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 549; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_ImportFrom(__pyx_t_2, __pyx_n_s_array); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 549; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_array, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 549; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "pymusic.pyx":662
 * 
 * # And here is the singleton def
 * Index = _Index()             # <<<<<<<<<<<<<<
 * 
 * cdef cbool EventCallback(PyObject* func,
 */
  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_7pymusic__Index)), __pyx_empty_tuple, NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 662; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_Index, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 662; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "pymusic.pyx":725
 * #    so that it can be thrown
 * #
 * pythonError = False             # <<<<<<<<<<<<<<
 * etype = NULL
 * evalue = NULL
 */
  MUSIC::pythonError = 0;

  /* "pymusic.pyx":726
 * #
 * pythonError = False
 * etype = NULL             # <<<<<<<<<<<<<<
 * evalue = NULL
 * etraceback = NULL
 */
  MUSIC::etype = NULL;

  /* "pymusic.pyx":727
 * pythonError = False
 * etype = NULL
 * evalue = NULL             # <<<<<<<<<<<<<<
 * etraceback = NULL
 */
  MUSIC::evalue = NULL;

  /* "pymusic.pyx":728
 * etype = NULL
 * evalue = NULL
 * etraceback = NULL             # <<<<<<<<<<<<<<
 */
  MUSIC::etraceback = NULL;

  /* "pymusic.pyx":1
 * #             # <<<<<<<<<<<<<<
 * # distutils: language = c++
 * # cython: c_string_encoding = default
 */
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "string.to_py":45
 * 
 * @cname("__pyx_convert_PyByteArray_string_to_py_std__string")
 * cdef inline object __pyx_convert_PyByteArray_string_to_py_std__string(const string& s):             # <<<<<<<<<<<<<<
 *     return __Pyx_PyByteArray_FromStringAndSize(s.data(), s.size())
 * 
 */

  /*--- Wrapped vars code ---*/

  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  if (__pyx_m) {
    if (__pyx_d) {
      __Pyx_AddTraceback("init pymusic", __pyx_clineno, __pyx_lineno, __pyx_filename);
    }
    Py_DECREF(__pyx_m); __pyx_m = 0;
  } else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_ImportError, "init pymusic");
  }
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  #if PY_MAJOR_VERSION < 3
  return;
  #else
  return __pyx_m;
  #endif
}

/* Runtime support code */
#if CYTHON_REFNANNY
static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname) {
    PyObject *m = NULL, *p = NULL;
    void *r = NULL;
    m = PyImport_ImportModule((char *)modname);
    if (!m) goto end;
    p = PyObject_GetAttrString(m, (char *)"RefNannyAPI");
    if (!p) goto end;
    r = PyLong_AsVoidPtr(p);
end:
    Py_XDECREF(p);
    Py_XDECREF(m);
    return (__Pyx_RefNannyAPIStruct *)r;
}
#endif

static PyObject *__Pyx_GetBuiltinName(PyObject *name) {
    PyObject* result = __Pyx_PyObject_GetAttrStr(__pyx_b, name);
    if (unlikely(!result)) {
        PyErr_Format(PyExc_NameError,
#if PY_MAJOR_VERSION >= 3
            "name '%U' is not defined", name);
#else
            "name '%.200s' is not defined", PyString_AS_STRING(name));
#endif
    }
    return result;
}

static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name) {
    PyObject *result;
#if CYTHON_COMPILING_IN_CPYTHON
    result = PyDict_GetItem(__pyx_d, name);
    if (likely(result)) {
        Py_INCREF(result);
    } else {
#else
    result = PyObject_GetItem(__pyx_d, name);
    if (!result) {
        PyErr_Clear();
#endif
        result = __Pyx_GetBuiltinName(name);
    }
    return result;
}

#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw) {
    PyObject *result;
    ternaryfunc call = func->ob_type->tp_call;
    if (unlikely(!call))
        return PyObject_Call(func, arg, kw);
    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
        return NULL;
    result = (*call)(func, arg, kw);
    Py_LeaveRecursiveCall();
    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
        PyErr_SetString(
            PyExc_SystemError,
            "NULL result without error in PyObject_Call");
    }
    return result;
}
#endif

static void __Pyx_RaiseArgtupleInvalid(
    const char* func_name,
    int exact,
    Py_ssize_t num_min,
    Py_ssize_t num_max,
    Py_ssize_t num_found)
{
    Py_ssize_t num_expected;
    const char *more_or_less;
    if (num_found < num_min) {
        num_expected = num_min;
        more_or_less = "at least";
    } else {
        num_expected = num_max;
        more_or_less = "at most";
    }
    if (exact) {
        more_or_less = "exactly";
    }
    PyErr_Format(PyExc_TypeError,
                 "%.200s() takes %.8s %" CYTHON_FORMAT_SSIZE_T "d positional argument%.1s (%" CYTHON_FORMAT_SSIZE_T "d given)",
                 func_name, more_or_less, num_expected,
                 (num_expected == 1) ? "" : "s", num_found);
}

static void __Pyx_RaiseDoubleKeywordsError(
    const char* func_name,
    PyObject* kw_name)
{
    PyErr_Format(PyExc_TypeError,
        #if PY_MAJOR_VERSION >= 3
        "%s() got multiple values for keyword argument '%U'", func_name, kw_name);
        #else
        "%s() got multiple values for keyword argument '%s'", func_name,
        PyString_AsString(kw_name));
        #endif
}

static int __Pyx_ParseOptionalKeywords(
    PyObject *kwds,
    PyObject **argnames[],
    PyObject *kwds2,
    PyObject *values[],
    Py_ssize_t num_pos_args,
    const char* function_name)
{
    PyObject *key = 0, *value = 0;
    Py_ssize_t pos = 0;
    PyObject*** name;
    PyObject*** first_kw_arg = argnames + num_pos_args;
    while (PyDict_Next(kwds, &pos, &key, &value)) {
        name = first_kw_arg;
        while (*name && (**name != key)) name++;
        if (*name) {
            values[name-argnames] = value;
            continue;
        }
        name = first_kw_arg;
        #if PY_MAJOR_VERSION < 3
        if (likely(PyString_CheckExact(key)) || likely(PyString_Check(key))) {
            while (*name) {
                if ((CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**name) == PyString_GET_SIZE(key))
                        && _PyString_Eq(**name, key)) {
                    values[name-argnames] = value;
                    break;
                }
                name++;
            }
            if (*name) continue;
            else {
                PyObject*** argname = argnames;
                while (argname != first_kw_arg) {
                    if ((**argname == key) || (
                            (CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**argname) == PyString_GET_SIZE(key))
                             && _PyString_Eq(**argname, key))) {
                        goto arg_passed_twice;
                    }
                    argname++;
                }
            }
        } else
        #endif
        if (likely(PyUnicode_Check(key))) {
            while (*name) {
                int cmp = (**name == key) ? 0 :
                #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
                    (PyUnicode_GET_SIZE(**name) != PyUnicode_GET_SIZE(key)) ? 1 :
                #endif
                    PyUnicode_Compare(**name, key);
                if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
                if (cmp == 0) {
                    values[name-argnames] = value;
                    break;
                }
                name++;
            }
            if (*name) continue;
            else {
                PyObject*** argname = argnames;
                while (argname != first_kw_arg) {
                    int cmp = (**argname == key) ? 0 :
                    #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
                        (PyUnicode_GET_SIZE(**argname) != PyUnicode_GET_SIZE(key)) ? 1 :
                    #endif
                        PyUnicode_Compare(**argname, key);
                    if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
                    if (cmp == 0) goto arg_passed_twice;
                    argname++;
                }
            }
        } else
            goto invalid_keyword_type;
        if (kwds2) {
            if (unlikely(PyDict_SetItem(kwds2, key, value))) goto bad;
        } else {
            goto invalid_keyword;
        }
    }
    return 0;
arg_passed_twice:
    __Pyx_RaiseDoubleKeywordsError(function_name, key);
    goto bad;
invalid_keyword_type:
    PyErr_Format(PyExc_TypeError,
        "%.200s() keywords must be strings", function_name);
    goto bad;
invalid_keyword:
    PyErr_Format(PyExc_TypeError,
    #if PY_MAJOR_VERSION < 3
        "%.200s() got an unexpected keyword argument '%.200s'",
        function_name, PyString_AsString(key));
    #else
        "%s() got an unexpected keyword argument '%U'",
        function_name, key);
    #endif
bad:
    return -1;
}

#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg) {
    PyObject *self, *result;
    PyCFunction cfunc;
    cfunc = PyCFunction_GET_FUNCTION(func);
    self = PyCFunction_GET_SELF(func);
    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
        return NULL;
    result = cfunc(self, arg);
    Py_LeaveRecursiveCall();
    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
        PyErr_SetString(
            PyExc_SystemError,
            "NULL result without error in PyObject_Call");
    }
    return result;
}
#endif

#if CYTHON_COMPILING_IN_CPYTHON
static PyObject* __Pyx__PyObject_CallOneArg(PyObject *func, PyObject *arg) {
    PyObject *result;
    PyObject *args = PyTuple_New(1);
    if (unlikely(!args)) return NULL;
    Py_INCREF(arg);
    PyTuple_SET_ITEM(args, 0, arg);
    result = __Pyx_PyObject_Call(func, args, NULL);
    Py_DECREF(args);
    return result;
}
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
#ifdef __Pyx_CyFunction_USED
    if (likely(PyCFunction_Check(func) || PyObject_TypeCheck(func, __pyx_CyFunctionType))) {
#else
    if (likely(PyCFunction_Check(func))) {
#endif
        if (likely(PyCFunction_GET_FLAGS(func) & METH_O)) {
            return __Pyx_PyObject_CallMethO(func, arg);
        }
    }
    return __Pyx__PyObject_CallOneArg(func, arg);
}
#else
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
    PyObject* args = PyTuple_Pack(1, arg);
    return (likely(args)) ? __Pyx_PyObject_Call(func, args, NULL) : NULL;
}
#endif

static CYTHON_INLINE void __Pyx_ErrRestore(PyObject *type, PyObject *value, PyObject *tb) {
#if CYTHON_COMPILING_IN_CPYTHON
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    PyThreadState *tstate = PyThreadState_GET();
    tmp_type = tstate->curexc_type;
    tmp_value = tstate->curexc_value;
    tmp_tb = tstate->curexc_traceback;
    tstate->curexc_type = type;
    tstate->curexc_value = value;
    tstate->curexc_traceback = tb;
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
#else
    PyErr_Restore(type, value, tb);
#endif
}
static CYTHON_INLINE void __Pyx_ErrFetch(PyObject **type, PyObject **value, PyObject **tb) {
#if CYTHON_COMPILING_IN_CPYTHON
    PyThreadState *tstate = PyThreadState_GET();
    *type = tstate->curexc_type;
    *value = tstate->curexc_value;
    *tb = tstate->curexc_traceback;
    tstate->curexc_type = 0;
    tstate->curexc_value = 0;
    tstate->curexc_traceback = 0;
#else
    PyErr_Fetch(type, value, tb);
#endif
}

#if PY_MAJOR_VERSION < 3
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb,
                        CYTHON_UNUSED PyObject *cause) {
    Py_XINCREF(type);
    if (!value || value == Py_None)
        value = NULL;
    else
        Py_INCREF(value);
    if (!tb || tb == Py_None)
        tb = NULL;
    else {
        Py_INCREF(tb);
        if (!PyTraceBack_Check(tb)) {
            PyErr_SetString(PyExc_TypeError,
                "raise: arg 3 must be a traceback or None");
            goto raise_error;
        }
    }
    if (PyType_Check(type)) {
#if CYTHON_COMPILING_IN_PYPY
        if (!value) {
            Py_INCREF(Py_None);
            value = Py_None;
        }
#endif
        PyErr_NormalizeException(&type, &value, &tb);
    } else {
        if (value) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto raise_error;
        }
        value = type;
        type = (PyObject*) Py_TYPE(type);
        Py_INCREF(type);
        if (!PyType_IsSubtype((PyTypeObject *)type, (PyTypeObject *)PyExc_BaseException)) {
            PyErr_SetString(PyExc_TypeError,
                "raise: exception class must be a subclass of BaseException");
            goto raise_error;
        }
    }
    __Pyx_ErrRestore(type, value, tb);
    return;
raise_error:
    Py_XDECREF(value);
    Py_XDECREF(type);
    Py_XDECREF(tb);
    return;
}
#else
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause) {
    PyObject* owned_instance = NULL;
    if (tb == Py_None) {
        tb = 0;
    } else if (tb && !PyTraceBack_Check(tb)) {
        PyErr_SetString(PyExc_TypeError,
            "raise: arg 3 must be a traceback or None");
        goto bad;
    }
    if (value == Py_None)
        value = 0;
    if (PyExceptionInstance_Check(type)) {
        if (value) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto bad;
        }
        value = type;
        type = (PyObject*) Py_TYPE(value);
    } else if (PyExceptionClass_Check(type)) {
        PyObject *instance_class = NULL;
        if (value && PyExceptionInstance_Check(value)) {
            instance_class = (PyObject*) Py_TYPE(value);
            if (instance_class != type) {
                if (PyObject_IsSubclass(instance_class, type)) {
                    type = instance_class;
                } else {
                    instance_class = NULL;
                }
            }
        }
        if (!instance_class) {
            PyObject *args;
            if (!value)
                args = PyTuple_New(0);
            else if (PyTuple_Check(value)) {
                Py_INCREF(value);
                args = value;
            } else
                args = PyTuple_Pack(1, value);
            if (!args)
                goto bad;
            owned_instance = PyObject_Call(type, args, NULL);
            Py_DECREF(args);
            if (!owned_instance)
                goto bad;
            value = owned_instance;
            if (!PyExceptionInstance_Check(value)) {
                PyErr_Format(PyExc_TypeError,
                             "calling %R should have returned an instance of "
                             "BaseException, not %R",
                             type, Py_TYPE(value));
                goto bad;
            }
        }
    } else {
        PyErr_SetString(PyExc_TypeError,
            "raise: exception class must be a subclass of BaseException");
        goto bad;
    }
#if PY_VERSION_HEX >= 0x03030000
    if (cause) {
#else
    if (cause && cause != Py_None) {
#endif
        PyObject *fixed_cause;
        if (cause == Py_None) {
            fixed_cause = NULL;
        } else if (PyExceptionClass_Check(cause)) {
            fixed_cause = PyObject_CallObject(cause, NULL);
            if (fixed_cause == NULL)
                goto bad;
        } else if (PyExceptionInstance_Check(cause)) {
            fixed_cause = cause;
            Py_INCREF(fixed_cause);
        } else {
            PyErr_SetString(PyExc_TypeError,
                            "exception causes must derive from "
                            "BaseException");
            goto bad;
        }
        PyException_SetCause(value, fixed_cause);
    }
    PyErr_SetObject(type, value);
    if (tb) {
#if CYTHON_COMPILING_IN_PYPY
        PyObject *tmp_type, *tmp_value, *tmp_tb;
        PyErr_Fetch(tmp_type, tmp_value, tmp_tb);
        Py_INCREF(tb);
        PyErr_Restore(tmp_type, tmp_value, tb);
        Py_XDECREF(tmp_tb);
#else
        PyThreadState *tstate = PyThreadState_GET();
        PyObject* tmp_tb = tstate->curexc_traceback;
        if (tb != tmp_tb) {
            Py_INCREF(tb);
            tstate->curexc_traceback = tb;
            Py_XDECREF(tmp_tb);
        }
#endif
    }
bad:
    Py_XDECREF(owned_instance);
    return;
}
#endif

static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j) {
    PyObject *r;
    if (!j) return NULL;
    r = PyObject_GetItem(o, j);
    Py_DECREF(j);
    return r;
}
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
                                                              int wraparound, int boundscheck) {
#if CYTHON_COMPILING_IN_CPYTHON
    if (wraparound & unlikely(i < 0)) i += PyList_GET_SIZE(o);
    if ((!boundscheck) || likely((0 <= i) & (i < PyList_GET_SIZE(o)))) {
        PyObject *r = PyList_GET_ITEM(o, i);
        Py_INCREF(r);
        return r;
    }
    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
#else
    return PySequence_GetItem(o, i);
#endif
}
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
                                                              int wraparound, int boundscheck) {
#if CYTHON_COMPILING_IN_CPYTHON
    if (wraparound & unlikely(i < 0)) i += PyTuple_GET_SIZE(o);
    if ((!boundscheck) || likely((0 <= i) & (i < PyTuple_GET_SIZE(o)))) {
        PyObject *r = PyTuple_GET_ITEM(o, i);
        Py_INCREF(r);
        return r;
    }
    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
#else
    return PySequence_GetItem(o, i);
#endif
}
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i,
                                                     int is_list, int wraparound, int boundscheck) {
#if CYTHON_COMPILING_IN_CPYTHON
    if (is_list || PyList_CheckExact(o)) {
        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyList_GET_SIZE(o);
        if ((!boundscheck) || (likely((n >= 0) & (n < PyList_GET_SIZE(o))))) {
            PyObject *r = PyList_GET_ITEM(o, n);
            Py_INCREF(r);
            return r;
        }
    }
    else if (PyTuple_CheckExact(o)) {
        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyTuple_GET_SIZE(o);
        if ((!boundscheck) || likely((n >= 0) & (n < PyTuple_GET_SIZE(o)))) {
            PyObject *r = PyTuple_GET_ITEM(o, n);
            Py_INCREF(r);
            return r;
        }
    } else {
        PySequenceMethods *m = Py_TYPE(o)->tp_as_sequence;
        if (likely(m && m->sq_item)) {
            if (wraparound && unlikely(i < 0) && likely(m->sq_length)) {
                Py_ssize_t l = m->sq_length(o);
                if (likely(l >= 0)) {
                    i += l;
                } else {
                    if (PyErr_ExceptionMatches(PyExc_OverflowError))
                        PyErr_Clear();
                    else
                        return NULL;
                }
            }
            return m->sq_item(o, i);
        }
    }
#else
    if (is_list || PySequence_Check(o)) {
        return PySequence_GetItem(o, i);
    }
#endif
    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
}

#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallNoArg(PyObject *func) {
#ifdef __Pyx_CyFunction_USED
    if (likely(PyCFunction_Check(func) || PyObject_TypeCheck(func, __pyx_CyFunctionType))) {
#else
    if (likely(PyCFunction_Check(func))) {
#endif
        if (likely(PyCFunction_GET_FLAGS(func) & METH_NOARGS)) {
            return __Pyx_PyObject_CallMethO(func, NULL);
        }
    }
    return __Pyx_PyObject_Call(func, __pyx_empty_tuple, NULL);
}
#endif

static CYTHON_INLINE void __Pyx_ExceptionSave(PyObject **type, PyObject **value, PyObject **tb) {
#if CYTHON_COMPILING_IN_CPYTHON
    PyThreadState *tstate = PyThreadState_GET();
    *type = tstate->exc_type;
    *value = tstate->exc_value;
    *tb = tstate->exc_traceback;
    Py_XINCREF(*type);
    Py_XINCREF(*value);
    Py_XINCREF(*tb);
#else
    PyErr_GetExcInfo(type, value, tb);
#endif
}
static void __Pyx_ExceptionReset(PyObject *type, PyObject *value, PyObject *tb) {
#if CYTHON_COMPILING_IN_CPYTHON
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    PyThreadState *tstate = PyThreadState_GET();
    tmp_type = tstate->exc_type;
    tmp_value = tstate->exc_value;
    tmp_tb = tstate->exc_traceback;
    tstate->exc_type = type;
    tstate->exc_value = value;
    tstate->exc_traceback = tb;
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
#else
    PyErr_SetExcInfo(type, value, tb);
#endif
}

static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb) {
    PyObject *local_type, *local_value, *local_tb;
#if CYTHON_COMPILING_IN_CPYTHON
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    PyThreadState *tstate = PyThreadState_GET();
    local_type = tstate->curexc_type;
    local_value = tstate->curexc_value;
    local_tb = tstate->curexc_traceback;
    tstate->curexc_type = 0;
    tstate->curexc_value = 0;
    tstate->curexc_traceback = 0;
#else
    PyErr_Fetch(&local_type, &local_value, &local_tb);
#endif
    PyErr_NormalizeException(&local_type, &local_value, &local_tb);
#if CYTHON_COMPILING_IN_CPYTHON
    if (unlikely(tstate->curexc_type))
#else
    if (unlikely(PyErr_Occurred()))
#endif
        goto bad;
    #if PY_MAJOR_VERSION >= 3
    if (local_tb) {
        if (unlikely(PyException_SetTraceback(local_value, local_tb) < 0))
            goto bad;
    }
    #endif
    Py_XINCREF(local_tb);
    Py_XINCREF(local_type);
    Py_XINCREF(local_value);
    *type = local_type;
    *value = local_value;
    *tb = local_tb;
#if CYTHON_COMPILING_IN_CPYTHON
    tmp_type = tstate->exc_type;
    tmp_value = tstate->exc_value;
    tmp_tb = tstate->exc_traceback;
    tstate->exc_type = local_type;
    tstate->exc_value = local_value;
    tstate->exc_traceback = local_tb;
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
#else
    PyErr_SetExcInfo(local_type, local_value, local_tb);
#endif
    return 0;
bad:
    *type = 0;
    *value = 0;
    *tb = 0;
    Py_XDECREF(local_type);
    Py_XDECREF(local_value);
    Py_XDECREF(local_tb);
    return -1;
}

static void __Pyx_WriteUnraisable(const char *name, CYTHON_UNUSED int clineno,
                                  CYTHON_UNUSED int lineno, CYTHON_UNUSED const char *filename,
                                  int full_traceback) {
    PyObject *old_exc, *old_val, *old_tb;
    PyObject *ctx;
    __Pyx_ErrFetch(&old_exc, &old_val, &old_tb);
    if (full_traceback) {
        Py_XINCREF(old_exc);
        Py_XINCREF(old_val);
        Py_XINCREF(old_tb);
        __Pyx_ErrRestore(old_exc, old_val, old_tb);
        PyErr_PrintEx(1);
    }
    #if PY_MAJOR_VERSION < 3
    ctx = PyString_FromString(name);
    #else
    ctx = PyUnicode_FromString(name);
    #endif
    __Pyx_ErrRestore(old_exc, old_val, old_tb);
    if (!ctx) {
        PyErr_WriteUnraisable(Py_None);
    } else {
        PyErr_WriteUnraisable(ctx);
        Py_DECREF(ctx);
    }
}

static void __Pyx_RaiseArgumentTypeInvalid(const char* name, PyObject *obj, PyTypeObject *type) {
    PyErr_Format(PyExc_TypeError,
        "Argument '%.200s' has incorrect type (expected %.200s, got %.200s)",
        name, type->tp_name, Py_TYPE(obj)->tp_name);
}
static CYTHON_INLINE int __Pyx_ArgTypeTest(PyObject *obj, PyTypeObject *type, int none_allowed,
    const char *name, int exact)
{
    if (unlikely(!type)) {
        PyErr_SetString(PyExc_SystemError, "Missing type object");
        return 0;
    }
    if (none_allowed && obj == Py_None) return 1;
    else if (exact) {
        if (likely(Py_TYPE(obj) == type)) return 1;
        #if PY_MAJOR_VERSION == 2
        else if ((type == &PyBaseString_Type) && likely(__Pyx_PyBaseString_CheckExact(obj))) return 1;
        #endif
    }
    else {
        if (likely(PyObject_TypeCheck(obj, type))) return 1;
    }
    __Pyx_RaiseArgumentTypeInvalid(name, obj, type);
    return 0;
}

static CYTHON_INLINE int __Pyx_CheckKeywordStrings(
    PyObject *kwdict,
    const char* function_name,
    int kw_allowed)
{
    PyObject* key = 0;
    Py_ssize_t pos = 0;
#if CYTHON_COMPILING_IN_PYPY
    if (!kw_allowed && PyDict_Next(kwdict, &pos, &key, 0))
        goto invalid_keyword;
    return 1;
#else
    while (PyDict_Next(kwdict, &pos, &key, 0)) {
        #if PY_MAJOR_VERSION < 3
        if (unlikely(!PyString_CheckExact(key)) && unlikely(!PyString_Check(key)))
        #endif
            if (unlikely(!PyUnicode_Check(key)))
                goto invalid_keyword_type;
    }
    if ((!kw_allowed) && unlikely(key))
        goto invalid_keyword;
    return 1;
invalid_keyword_type:
    PyErr_Format(PyExc_TypeError,
        "%.200s() keywords must be strings", function_name);
    return 0;
#endif
invalid_keyword:
    PyErr_Format(PyExc_TypeError,
    #if PY_MAJOR_VERSION < 3
        "%.200s() got an unexpected keyword argument '%.200s'",
        function_name, PyString_AsString(key));
    #else
        "%s() got an unexpected keyword argument '%U'",
        function_name, key);
    #endif
    return 0;
}

static CYTHON_INLINE void __Pyx_ExceptionSwap(PyObject **type, PyObject **value, PyObject **tb) {
    PyObject *tmp_type, *tmp_value, *tmp_tb;
#if CYTHON_COMPILING_IN_CPYTHON
    PyThreadState *tstate = PyThreadState_GET();
    tmp_type = tstate->exc_type;
    tmp_value = tstate->exc_value;
    tmp_tb = tstate->exc_traceback;
    tstate->exc_type = *type;
    tstate->exc_value = *value;
    tstate->exc_traceback = *tb;
#else
    PyErr_GetExcInfo(&tmp_type, &tmp_value, &tmp_tb);
    PyErr_SetExcInfo(*type, *value, *tb);
#endif
    *type = tmp_type;
    *value = tmp_value;
    *tb = tmp_tb;
}

static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type) {
    if (unlikely(!type)) {
        PyErr_SetString(PyExc_SystemError, "Missing type object");
        return 0;
    }
    if (likely(PyObject_TypeCheck(obj, type)))
        return 1;
    PyErr_Format(PyExc_TypeError, "Cannot convert %.200s to %.200s",
                 Py_TYPE(obj)->tp_name, type->tp_name);
    return 0;
}

static double __Pyx__PyObject_AsDouble(PyObject* obj) {
    PyObject* float_value;
#if CYTHON_COMPILING_IN_PYPY
    float_value = PyNumber_Float(obj);
#else
    PyNumberMethods *nb = Py_TYPE(obj)->tp_as_number;
    if (likely(nb) && likely(nb->nb_float)) {
        float_value = nb->nb_float(obj);
        if (likely(float_value) && unlikely(!PyFloat_Check(float_value))) {
            PyErr_Format(PyExc_TypeError,
                "__float__ returned non-float (type %.200s)",
                Py_TYPE(float_value)->tp_name);
            Py_DECREF(float_value);
            goto bad;
        }
    } else if (PyUnicode_CheckExact(obj) || PyBytes_CheckExact(obj)) {
#if PY_MAJOR_VERSION >= 3
        float_value = PyFloat_FromString(obj);
#else
        float_value = PyFloat_FromString(obj, 0);
#endif
    } else {
        PyObject* args = PyTuple_New(1);
        if (unlikely(!args)) goto bad;
        PyTuple_SET_ITEM(args, 0, obj);
        float_value = PyObject_Call((PyObject*)&PyFloat_Type, args, 0);
        PyTuple_SET_ITEM(args, 0, 0);
        Py_DECREF(args);
    }
#endif
    if (likely(float_value)) {
        double value = PyFloat_AS_DOUBLE(float_value);
        Py_DECREF(float_value);
        return value;
    }
bad:
    return (double)-1;
}

static int __Pyx_call_next_tp_traverse(PyObject* obj, visitproc v, void *a, traverseproc current_tp_traverse) {
    PyTypeObject* type = Py_TYPE(obj);
    while (type && type->tp_traverse != current_tp_traverse)
        type = type->tp_base;
    while (type && type->tp_traverse == current_tp_traverse)
        type = type->tp_base;
    if (type && type->tp_traverse)
        return type->tp_traverse(obj, v, a);
    return 0;
}

static void __Pyx_call_next_tp_clear(PyObject* obj, inquiry current_tp_clear) {
    PyTypeObject* type = Py_TYPE(obj);
    while (type && type->tp_clear != current_tp_clear)
        type = type->tp_base;
    while (type && type->tp_clear == current_tp_clear)
        type = type->tp_base;
    if (type && type->tp_clear)
        type->tp_clear(obj);
}

static int __Pyx_SetVtable(PyObject *dict, void *vtable) {
#if PY_VERSION_HEX >= 0x02070000
    PyObject *ob = PyCapsule_New(vtable, 0, 0);
#else
    PyObject *ob = PyCObject_FromVoidPtr(vtable, 0);
#endif
    if (!ob)
        goto bad;
    if (PyDict_SetItem(dict, __pyx_n_s_pyx_vtable, ob) < 0)
        goto bad;
    Py_DECREF(ob);
    return 0;
bad:
    Py_XDECREF(ob);
    return -1;
}

static PyObject *__Pyx_CalculateMetaclass(PyTypeObject *metaclass, PyObject *bases) {
    Py_ssize_t i, nbases = PyTuple_GET_SIZE(bases);
    for (i=0; i < nbases; i++) {
        PyTypeObject *tmptype;
        PyObject *tmp = PyTuple_GET_ITEM(bases, i);
        tmptype = Py_TYPE(tmp);
#if PY_MAJOR_VERSION < 3
        if (tmptype == &PyClass_Type)
            continue;
#endif
        if (!metaclass) {
            metaclass = tmptype;
            continue;
        }
        if (PyType_IsSubtype(metaclass, tmptype))
            continue;
        if (PyType_IsSubtype(tmptype, metaclass)) {
            metaclass = tmptype;
            continue;
        }
        PyErr_SetString(PyExc_TypeError,
                        "metaclass conflict: "
                        "the metaclass of a derived class "
                        "must be a (non-strict) subclass "
                        "of the metaclasses of all its bases");
        return NULL;
    }
    if (!metaclass) {
#if PY_MAJOR_VERSION < 3
        metaclass = &PyClass_Type;
#else
        metaclass = &PyType_Type;
#endif
    }
    Py_INCREF((PyObject*) metaclass);
    return (PyObject*) metaclass;
}

static PyObject *__Pyx_Py3MetaclassPrepare(PyObject *metaclass, PyObject *bases, PyObject *name,
                                           PyObject *qualname, PyObject *mkw, PyObject *modname, PyObject *doc) {
    PyObject *ns;
    if (metaclass) {
        PyObject *prep = __Pyx_PyObject_GetAttrStr(metaclass, __pyx_n_s_prepare);
        if (prep) {
            PyObject *pargs = PyTuple_Pack(2, name, bases);
            if (unlikely(!pargs)) {
                Py_DECREF(prep);
                return NULL;
            }
            ns = PyObject_Call(prep, pargs, mkw);
            Py_DECREF(prep);
            Py_DECREF(pargs);
        } else {
            if (unlikely(!PyErr_ExceptionMatches(PyExc_AttributeError)))
                return NULL;
            PyErr_Clear();
            ns = PyDict_New();
        }
    } else {
        ns = PyDict_New();
    }
    if (unlikely(!ns))
        return NULL;
    if (unlikely(PyObject_SetItem(ns, __pyx_n_s_module, modname) < 0)) goto bad;
    if (unlikely(PyObject_SetItem(ns, __pyx_n_s_qualname, qualname) < 0)) goto bad;
    if (unlikely(doc && PyObject_SetItem(ns, __pyx_n_s_doc, doc) < 0)) goto bad;
    return ns;
bad:
    Py_DECREF(ns);
    return NULL;
}
static PyObject *__Pyx_Py3ClassCreate(PyObject *metaclass, PyObject *name, PyObject *bases,
                                      PyObject *dict, PyObject *mkw,
                                      int calculate_metaclass, int allow_py2_metaclass) {
    PyObject *result, *margs;
    PyObject *owned_metaclass = NULL;
    if (allow_py2_metaclass) {
        owned_metaclass = PyObject_GetItem(dict, __pyx_n_s_metaclass);
        if (owned_metaclass) {
            metaclass = owned_metaclass;
        } else if (likely(PyErr_ExceptionMatches(PyExc_KeyError))) {
            PyErr_Clear();
        } else {
            return NULL;
        }
    }
    if (calculate_metaclass && (!metaclass || PyType_Check(metaclass))) {
        metaclass = __Pyx_CalculateMetaclass((PyTypeObject*) metaclass, bases);
        Py_XDECREF(owned_metaclass);
        if (unlikely(!metaclass))
            return NULL;
        owned_metaclass = metaclass;
    }
    margs = PyTuple_Pack(3, name, bases, dict);
    if (unlikely(!margs)) {
        result = NULL;
    } else {
        result = PyObject_Call(metaclass, margs, mkw);
        Py_DECREF(margs);
    }
    Py_XDECREF(owned_metaclass);
    return result;
}

static PyTypeObject* __Pyx_FetchCommonType(PyTypeObject* type) {
    PyObject* fake_module;
    PyTypeObject* cached_type = NULL;
    fake_module = PyImport_AddModule((char*) "_cython_" CYTHON_ABI);
    if (!fake_module) return NULL;
    Py_INCREF(fake_module);
    cached_type = (PyTypeObject*) PyObject_GetAttrString(fake_module, type->tp_name);
    if (cached_type) {
        if (!PyType_Check((PyObject*)cached_type)) {
            PyErr_Format(PyExc_TypeError,
                "Shared Cython type %.200s is not a type object",
                type->tp_name);
            goto bad;
        }
        if (cached_type->tp_basicsize != type->tp_basicsize) {
            PyErr_Format(PyExc_TypeError,
                "Shared Cython type %.200s has the wrong size, try recompiling",
                type->tp_name);
            goto bad;
        }
    } else {
        if (!PyErr_ExceptionMatches(PyExc_AttributeError)) goto bad;
        PyErr_Clear();
        if (PyType_Ready(type) < 0) goto bad;
        if (PyObject_SetAttrString(fake_module, type->tp_name, (PyObject*) type) < 0)
            goto bad;
        Py_INCREF(type);
        cached_type = type;
    }
done:
    Py_DECREF(fake_module);
    return cached_type;
bad:
    Py_XDECREF(cached_type);
    cached_type = NULL;
    goto done;
}

static PyObject *
__Pyx_CyFunction_get_doc(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *closure)
{
    if (unlikely(op->func_doc == NULL)) {
        if (op->func.m_ml->ml_doc) {
#if PY_MAJOR_VERSION >= 3
            op->func_doc = PyUnicode_FromString(op->func.m_ml->ml_doc);
#else
            op->func_doc = PyString_FromString(op->func.m_ml->ml_doc);
#endif
            if (unlikely(op->func_doc == NULL))
                return NULL;
        } else {
            Py_INCREF(Py_None);
            return Py_None;
        }
    }
    Py_INCREF(op->func_doc);
    return op->func_doc;
}
static int
__Pyx_CyFunction_set_doc(__pyx_CyFunctionObject *op, PyObject *value)
{
    PyObject *tmp = op->func_doc;
    if (value == NULL) {
        value = Py_None;
    }
    Py_INCREF(value);
    op->func_doc = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_name(__pyx_CyFunctionObject *op)
{
    if (unlikely(op->func_name == NULL)) {
#if PY_MAJOR_VERSION >= 3
        op->func_name = PyUnicode_InternFromString(op->func.m_ml->ml_name);
#else
        op->func_name = PyString_InternFromString(op->func.m_ml->ml_name);
#endif
        if (unlikely(op->func_name == NULL))
            return NULL;
    }
    Py_INCREF(op->func_name);
    return op->func_name;
}
static int
__Pyx_CyFunction_set_name(__pyx_CyFunctionObject *op, PyObject *value)
{
    PyObject *tmp;
#if PY_MAJOR_VERSION >= 3
    if (unlikely(value == NULL || !PyUnicode_Check(value))) {
#else
    if (unlikely(value == NULL || !PyString_Check(value))) {
#endif
        PyErr_SetString(PyExc_TypeError,
                        "__name__ must be set to a string object");
        return -1;
    }
    tmp = op->func_name;
    Py_INCREF(value);
    op->func_name = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_qualname(__pyx_CyFunctionObject *op)
{
    Py_INCREF(op->func_qualname);
    return op->func_qualname;
}
static int
__Pyx_CyFunction_set_qualname(__pyx_CyFunctionObject *op, PyObject *value)
{
    PyObject *tmp;
#if PY_MAJOR_VERSION >= 3
    if (unlikely(value == NULL || !PyUnicode_Check(value))) {
#else
    if (unlikely(value == NULL || !PyString_Check(value))) {
#endif
        PyErr_SetString(PyExc_TypeError,
                        "__qualname__ must be set to a string object");
        return -1;
    }
    tmp = op->func_qualname;
    Py_INCREF(value);
    op->func_qualname = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_self(__pyx_CyFunctionObject *m, CYTHON_UNUSED void *closure)
{
    PyObject *self;
    self = m->func_closure;
    if (self == NULL)
        self = Py_None;
    Py_INCREF(self);
    return self;
}
static PyObject *
__Pyx_CyFunction_get_dict(__pyx_CyFunctionObject *op)
{
    if (unlikely(op->func_dict == NULL)) {
        op->func_dict = PyDict_New();
        if (unlikely(op->func_dict == NULL))
            return NULL;
    }
    Py_INCREF(op->func_dict);
    return op->func_dict;
}
static int
__Pyx_CyFunction_set_dict(__pyx_CyFunctionObject *op, PyObject *value)
{
    PyObject *tmp;
    if (unlikely(value == NULL)) {
        PyErr_SetString(PyExc_TypeError,
               "function's dictionary may not be deleted");
        return -1;
    }
    if (unlikely(!PyDict_Check(value))) {
        PyErr_SetString(PyExc_TypeError,
               "setting function's dictionary to a non-dict");
        return -1;
    }
    tmp = op->func_dict;
    Py_INCREF(value);
    op->func_dict = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_globals(__pyx_CyFunctionObject *op)
{
    Py_INCREF(op->func_globals);
    return op->func_globals;
}
static PyObject *
__Pyx_CyFunction_get_closure(CYTHON_UNUSED __pyx_CyFunctionObject *op)
{
    Py_INCREF(Py_None);
    return Py_None;
}
static PyObject *
__Pyx_CyFunction_get_code(__pyx_CyFunctionObject *op)
{
    PyObject* result = (op->func_code) ? op->func_code : Py_None;
    Py_INCREF(result);
    return result;
}
static int
__Pyx_CyFunction_init_defaults(__pyx_CyFunctionObject *op) {
    PyObject *res = op->defaults_getter((PyObject *) op);
    if (unlikely(!res))
        return -1;
    op->defaults_tuple = PyTuple_GET_ITEM(res, 0);
    Py_INCREF(op->defaults_tuple);
    op->defaults_kwdict = PyTuple_GET_ITEM(res, 1);
    Py_INCREF(op->defaults_kwdict);
    Py_DECREF(res);
    return 0;
}
static int
__Pyx_CyFunction_set_defaults(__pyx_CyFunctionObject *op, PyObject* value) {
    PyObject* tmp;
    if (!value) {
        value = Py_None;
    } else if (value != Py_None && !PyTuple_Check(value)) {
        PyErr_SetString(PyExc_TypeError,
                        "__defaults__ must be set to a tuple object");
        return -1;
    }
    Py_INCREF(value);
    tmp = op->defaults_tuple;
    op->defaults_tuple = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_defaults(__pyx_CyFunctionObject *op) {
    PyObject* result = op->defaults_tuple;
    if (unlikely(!result)) {
        if (op->defaults_getter) {
            if (__Pyx_CyFunction_init_defaults(op) < 0) return NULL;
            result = op->defaults_tuple;
        } else {
            result = Py_None;
        }
    }
    Py_INCREF(result);
    return result;
}
static int
__Pyx_CyFunction_set_kwdefaults(__pyx_CyFunctionObject *op, PyObject* value) {
    PyObject* tmp;
    if (!value) {
        value = Py_None;
    } else if (value != Py_None && !PyDict_Check(value)) {
        PyErr_SetString(PyExc_TypeError,
                        "__kwdefaults__ must be set to a dict object");
        return -1;
    }
    Py_INCREF(value);
    tmp = op->defaults_kwdict;
    op->defaults_kwdict = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_kwdefaults(__pyx_CyFunctionObject *op) {
    PyObject* result = op->defaults_kwdict;
    if (unlikely(!result)) {
        if (op->defaults_getter) {
            if (__Pyx_CyFunction_init_defaults(op) < 0) return NULL;
            result = op->defaults_kwdict;
        } else {
            result = Py_None;
        }
    }
    Py_INCREF(result);
    return result;
}
static int
__Pyx_CyFunction_set_annotations(__pyx_CyFunctionObject *op, PyObject* value) {
    PyObject* tmp;
    if (!value || value == Py_None) {
        value = NULL;
    } else if (!PyDict_Check(value)) {
        PyErr_SetString(PyExc_TypeError,
                        "__annotations__ must be set to a dict object");
        return -1;
    }
    Py_XINCREF(value);
    tmp = op->func_annotations;
    op->func_annotations = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_CyFunction_get_annotations(__pyx_CyFunctionObject *op) {
    PyObject* result = op->func_annotations;
    if (unlikely(!result)) {
        result = PyDict_New();
        if (unlikely(!result)) return NULL;
        op->func_annotations = result;
    }
    Py_INCREF(result);
    return result;
}
static PyGetSetDef __pyx_CyFunction_getsets[] = {
    {(char *) "func_doc", (getter)__Pyx_CyFunction_get_doc, (setter)__Pyx_CyFunction_set_doc, 0, 0},
    {(char *) "__doc__",  (getter)__Pyx_CyFunction_get_doc, (setter)__Pyx_CyFunction_set_doc, 0, 0},
    {(char *) "func_name", (getter)__Pyx_CyFunction_get_name, (setter)__Pyx_CyFunction_set_name, 0, 0},
    {(char *) "__name__", (getter)__Pyx_CyFunction_get_name, (setter)__Pyx_CyFunction_set_name, 0, 0},
    {(char *) "__qualname__", (getter)__Pyx_CyFunction_get_qualname, (setter)__Pyx_CyFunction_set_qualname, 0, 0},
    {(char *) "__self__", (getter)__Pyx_CyFunction_get_self, 0, 0, 0},
    {(char *) "func_dict", (getter)__Pyx_CyFunction_get_dict, (setter)__Pyx_CyFunction_set_dict, 0, 0},
    {(char *) "__dict__", (getter)__Pyx_CyFunction_get_dict, (setter)__Pyx_CyFunction_set_dict, 0, 0},
    {(char *) "func_globals", (getter)__Pyx_CyFunction_get_globals, 0, 0, 0},
    {(char *) "__globals__", (getter)__Pyx_CyFunction_get_globals, 0, 0, 0},
    {(char *) "func_closure", (getter)__Pyx_CyFunction_get_closure, 0, 0, 0},
    {(char *) "__closure__", (getter)__Pyx_CyFunction_get_closure, 0, 0, 0},
    {(char *) "func_code", (getter)__Pyx_CyFunction_get_code, 0, 0, 0},
    {(char *) "__code__", (getter)__Pyx_CyFunction_get_code, 0, 0, 0},
    {(char *) "func_defaults", (getter)__Pyx_CyFunction_get_defaults, (setter)__Pyx_CyFunction_set_defaults, 0, 0},
    {(char *) "__defaults__", (getter)__Pyx_CyFunction_get_defaults, (setter)__Pyx_CyFunction_set_defaults, 0, 0},
    {(char *) "__kwdefaults__", (getter)__Pyx_CyFunction_get_kwdefaults, (setter)__Pyx_CyFunction_set_kwdefaults, 0, 0},
    {(char *) "__annotations__", (getter)__Pyx_CyFunction_get_annotations, (setter)__Pyx_CyFunction_set_annotations, 0, 0},
    {0, 0, 0, 0, 0}
};
#ifndef PY_WRITE_RESTRICTED
#define PY_WRITE_RESTRICTED WRITE_RESTRICTED
#endif
static PyMemberDef __pyx_CyFunction_members[] = {
    {(char *) "__module__", T_OBJECT, offsetof(__pyx_CyFunctionObject, func.m_module), PY_WRITE_RESTRICTED, 0},
    {0, 0, 0,  0, 0}
};
static PyObject *
__Pyx_CyFunction_reduce(__pyx_CyFunctionObject *m, CYTHON_UNUSED PyObject *args)
{
#if PY_MAJOR_VERSION >= 3
    return PyUnicode_FromString(m->func.m_ml->ml_name);
#else
    return PyString_FromString(m->func.m_ml->ml_name);
#endif
}
static PyMethodDef __pyx_CyFunction_methods[] = {
    {"__reduce__", (PyCFunction)__Pyx_CyFunction_reduce, METH_VARARGS, 0},
    {0, 0, 0, 0}
};
#if PY_VERSION_HEX < 0x030500A0
#define __Pyx_CyFunction_weakreflist(cyfunc) ((cyfunc)->func_weakreflist)
#else
#define __Pyx_CyFunction_weakreflist(cyfunc) ((cyfunc)->func.m_weakreflist)
#endif
static PyObject *__Pyx_CyFunction_New(PyTypeObject *type, PyMethodDef *ml, int flags, PyObject* qualname,
                                      PyObject *closure, PyObject *module, PyObject* globals, PyObject* code) {
    __pyx_CyFunctionObject *op = PyObject_GC_New(__pyx_CyFunctionObject, type);
    if (op == NULL)
        return NULL;
    op->flags = flags;
    __Pyx_CyFunction_weakreflist(op) = NULL;
    op->func.m_ml = ml;
    op->func.m_self = (PyObject *) op;
    Py_XINCREF(closure);
    op->func_closure = closure;
    Py_XINCREF(module);
    op->func.m_module = module;
    op->func_dict = NULL;
    op->func_name = NULL;
    Py_INCREF(qualname);
    op->func_qualname = qualname;
    op->func_doc = NULL;
    op->func_classobj = NULL;
    op->func_globals = globals;
    Py_INCREF(op->func_globals);
    Py_XINCREF(code);
    op->func_code = code;
    op->defaults_pyobjects = 0;
    op->defaults = NULL;
    op->defaults_tuple = NULL;
    op->defaults_kwdict = NULL;
    op->defaults_getter = NULL;
    op->func_annotations = NULL;
    PyObject_GC_Track(op);
    return (PyObject *) op;
}
static int
__Pyx_CyFunction_clear(__pyx_CyFunctionObject *m)
{
    Py_CLEAR(m->func_closure);
    Py_CLEAR(m->func.m_module);
    Py_CLEAR(m->func_dict);
    Py_CLEAR(m->func_name);
    Py_CLEAR(m->func_qualname);
    Py_CLEAR(m->func_doc);
    Py_CLEAR(m->func_globals);
    Py_CLEAR(m->func_code);
    Py_CLEAR(m->func_classobj);
    Py_CLEAR(m->defaults_tuple);
    Py_CLEAR(m->defaults_kwdict);
    Py_CLEAR(m->func_annotations);
    if (m->defaults) {
        PyObject **pydefaults = __Pyx_CyFunction_Defaults(PyObject *, m);
        int i;
        for (i = 0; i < m->defaults_pyobjects; i++)
            Py_XDECREF(pydefaults[i]);
        PyMem_Free(m->defaults);
        m->defaults = NULL;
    }
    return 0;
}
static void __Pyx_CyFunction_dealloc(__pyx_CyFunctionObject *m)
{
    PyObject_GC_UnTrack(m);
    if (__Pyx_CyFunction_weakreflist(m) != NULL)
        PyObject_ClearWeakRefs((PyObject *) m);
    __Pyx_CyFunction_clear(m);
    PyObject_GC_Del(m);
}
static int __Pyx_CyFunction_traverse(__pyx_CyFunctionObject *m, visitproc visit, void *arg)
{
    Py_VISIT(m->func_closure);
    Py_VISIT(m->func.m_module);
    Py_VISIT(m->func_dict);
    Py_VISIT(m->func_name);
    Py_VISIT(m->func_qualname);
    Py_VISIT(m->func_doc);
    Py_VISIT(m->func_globals);
    Py_VISIT(m->func_code);
    Py_VISIT(m->func_classobj);
    Py_VISIT(m->defaults_tuple);
    Py_VISIT(m->defaults_kwdict);
    if (m->defaults) {
        PyObject **pydefaults = __Pyx_CyFunction_Defaults(PyObject *, m);
        int i;
        for (i = 0; i < m->defaults_pyobjects; i++)
            Py_VISIT(pydefaults[i]);
    }
    return 0;
}
static PyObject *__Pyx_CyFunction_descr_get(PyObject *func, PyObject *obj, PyObject *type)
{
    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
    if (m->flags & __Pyx_CYFUNCTION_STATICMETHOD) {
        Py_INCREF(func);
        return func;
    }
    if (m->flags & __Pyx_CYFUNCTION_CLASSMETHOD) {
        if (type == NULL)
            type = (PyObject *)(Py_TYPE(obj));
        return __Pyx_PyMethod_New(func, type, (PyObject *)(Py_TYPE(type)));
    }
    if (obj == Py_None)
        obj = NULL;
    return __Pyx_PyMethod_New(func, obj, type);
}
static PyObject*
__Pyx_CyFunction_repr(__pyx_CyFunctionObject *op)
{
#if PY_MAJOR_VERSION >= 3
    return PyUnicode_FromFormat("<cyfunction %U at %p>",
                                op->func_qualname, (void *)op);
#else
    return PyString_FromFormat("<cyfunction %s at %p>",
                               PyString_AsString(op->func_qualname), (void *)op);
#endif
}
#if CYTHON_COMPILING_IN_PYPY
static PyObject * __Pyx_CyFunction_Call(PyObject *func, PyObject *arg, PyObject *kw) {
    PyCFunctionObject* f = (PyCFunctionObject*)func;
    PyCFunction meth = PyCFunction_GET_FUNCTION(func);
    PyObject *self = PyCFunction_GET_SELF(func);
    Py_ssize_t size;
    switch (PyCFunction_GET_FLAGS(func) & ~(METH_CLASS | METH_STATIC | METH_COEXIST)) {
    case METH_VARARGS:
        if (likely(kw == NULL) || PyDict_Size(kw) == 0)
            return (*meth)(self, arg);
        break;
    case METH_VARARGS | METH_KEYWORDS:
        return (*(PyCFunctionWithKeywords)meth)(self, arg, kw);
    case METH_NOARGS:
        if (likely(kw == NULL) || PyDict_Size(kw) == 0) {
            size = PyTuple_GET_SIZE(arg);
            if (size == 0)
                return (*meth)(self, NULL);
            PyErr_Format(PyExc_TypeError,
                "%.200s() takes no arguments (%zd given)",
                f->m_ml->ml_name, size);
            return NULL;
        }
        break;
    case METH_O:
        if (likely(kw == NULL) || PyDict_Size(kw) == 0) {
            size = PyTuple_GET_SIZE(arg);
            if (size == 1)
                return (*meth)(self, PyTuple_GET_ITEM(arg, 0));
            PyErr_Format(PyExc_TypeError,
                "%.200s() takes exactly one argument (%zd given)",
                f->m_ml->ml_name, size);
            return NULL;
        }
        break;
    default:
        PyErr_SetString(PyExc_SystemError, "Bad call flags in "
                        "__Pyx_CyFunction_Call. METH_OLDARGS is no "
                        "longer supported!");
        return NULL;
    }
    PyErr_Format(PyExc_TypeError, "%.200s() takes no keyword arguments",
                 f->m_ml->ml_name);
    return NULL;
}
#else
static PyObject * __Pyx_CyFunction_Call(PyObject *func, PyObject *arg, PyObject *kw) {
	return PyCFunction_Call(func, arg, kw);
}
#endif
static PyTypeObject __pyx_CyFunctionType_type = {
    PyVarObject_HEAD_INIT(0, 0)
    "cython_function_or_method",
    sizeof(__pyx_CyFunctionObject),
    0,
    (destructor) __Pyx_CyFunction_dealloc,
    0,
    0,
    0,
#if PY_MAJOR_VERSION < 3
    0,
#else
    0,
#endif
    (reprfunc) __Pyx_CyFunction_repr,
    0,
    0,
    0,
    0,
    __Pyx_CyFunction_Call,
    0,
    0,
    0,
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,
    0,
    (traverseproc) __Pyx_CyFunction_traverse,
    (inquiry) __Pyx_CyFunction_clear,
    0,
#if PY_VERSION_HEX < 0x030500A0
    offsetof(__pyx_CyFunctionObject, func_weakreflist),
#else
    offsetof(PyCFunctionObject, m_weakreflist),
#endif
    0,
    0,
    __pyx_CyFunction_methods,
    __pyx_CyFunction_members,
    __pyx_CyFunction_getsets,
    0,
    0,
    __Pyx_CyFunction_descr_get,
    0,
    offsetof(__pyx_CyFunctionObject, func_dict),
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
#if PY_VERSION_HEX >= 0x030400a1
    0,
#endif
};
static int __Pyx_CyFunction_init(void) {
#if !CYTHON_COMPILING_IN_PYPY
    __pyx_CyFunctionType_type.tp_call = PyCFunction_Call;
#endif
    __pyx_CyFunctionType = __Pyx_FetchCommonType(&__pyx_CyFunctionType_type);
    if (__pyx_CyFunctionType == NULL) {
        return -1;
    }
    return 0;
}
static CYTHON_INLINE void *__Pyx_CyFunction_InitDefaults(PyObject *func, size_t size, int pyobjects) {
    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
    m->defaults = PyMem_Malloc(size);
    if (!m->defaults)
        return PyErr_NoMemory();
    memset(m->defaults, 0, size);
    m->defaults_pyobjects = pyobjects;
    return m->defaults;
}
static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsTuple(PyObject *func, PyObject *tuple) {
    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
    m->defaults_tuple = tuple;
    Py_INCREF(tuple);
}
static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsKwDict(PyObject *func, PyObject *dict) {
    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
    m->defaults_kwdict = dict;
    Py_INCREF(dict);
}
static CYTHON_INLINE void __Pyx_CyFunction_SetAnnotationsDict(PyObject *func, PyObject *dict) {
    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
    m->func_annotations = dict;
    Py_INCREF(dict);
}

static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name) {
    PyObject* value = __Pyx_PyObject_GetAttrStr(module, name);
    if (unlikely(!value) && PyErr_ExceptionMatches(PyExc_AttributeError)) {
        PyErr_Format(PyExc_ImportError,
        #if PY_MAJOR_VERSION < 3
            "cannot import name %.230s", PyString_AS_STRING(name));
        #else
            "cannot import name %S", name);
        #endif
    }
    return value;
}

static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line) {
    int start = 0, mid = 0, end = count - 1;
    if (end >= 0 && code_line > entries[end].code_line) {
        return count;
    }
    while (start < end) {
        mid = (start + end) / 2;
        if (code_line < entries[mid].code_line) {
            end = mid;
        } else if (code_line > entries[mid].code_line) {
             start = mid + 1;
        } else {
            return mid;
        }
    }
    if (code_line <= entries[mid].code_line) {
        return mid;
    } else {
        return mid + 1;
    }
}
static PyCodeObject *__pyx_find_code_object(int code_line) {
    PyCodeObject* code_object;
    int pos;
    if (unlikely(!code_line) || unlikely(!__pyx_code_cache.entries)) {
        return NULL;
    }
    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
    if (unlikely(pos >= __pyx_code_cache.count) || unlikely(__pyx_code_cache.entries[pos].code_line != code_line)) {
        return NULL;
    }
    code_object = __pyx_code_cache.entries[pos].code_object;
    Py_INCREF(code_object);
    return code_object;
}
static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object) {
    int pos, i;
    __Pyx_CodeObjectCacheEntry* entries = __pyx_code_cache.entries;
    if (unlikely(!code_line)) {
        return;
    }
    if (unlikely(!entries)) {
        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Malloc(64*sizeof(__Pyx_CodeObjectCacheEntry));
        if (likely(entries)) {
            __pyx_code_cache.entries = entries;
            __pyx_code_cache.max_count = 64;
            __pyx_code_cache.count = 1;
            entries[0].code_line = code_line;
            entries[0].code_object = code_object;
            Py_INCREF(code_object);
        }
        return;
    }
    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
    if ((pos < __pyx_code_cache.count) && unlikely(__pyx_code_cache.entries[pos].code_line == code_line)) {
        PyCodeObject* tmp = entries[pos].code_object;
        entries[pos].code_object = code_object;
        Py_DECREF(tmp);
        return;
    }
    if (__pyx_code_cache.count == __pyx_code_cache.max_count) {
        int new_max = __pyx_code_cache.max_count + 64;
        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Realloc(
            __pyx_code_cache.entries, (size_t)new_max*sizeof(__Pyx_CodeObjectCacheEntry));
        if (unlikely(!entries)) {
            return;
        }
        __pyx_code_cache.entries = entries;
        __pyx_code_cache.max_count = new_max;
    }
    for (i=__pyx_code_cache.count; i>pos; i--) {
        entries[i] = entries[i-1];
    }
    entries[pos].code_line = code_line;
    entries[pos].code_object = code_object;
    __pyx_code_cache.count++;
    Py_INCREF(code_object);
}

#include "compile.h"
#include "frameobject.h"
#include "traceback.h"
static PyCodeObject* __Pyx_CreateCodeObjectForTraceback(
            const char *funcname, int c_line,
            int py_line, const char *filename) {
    PyCodeObject *py_code = 0;
    PyObject *py_srcfile = 0;
    PyObject *py_funcname = 0;
    #if PY_MAJOR_VERSION < 3
    py_srcfile = PyString_FromString(filename);
    #else
    py_srcfile = PyUnicode_FromString(filename);
    #endif
    if (!py_srcfile) goto bad;
    if (c_line) {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
        #else
        py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
        #endif
    }
    else {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromString(funcname);
        #else
        py_funcname = PyUnicode_FromString(funcname);
        #endif
    }
    if (!py_funcname) goto bad;
    py_code = __Pyx_PyCode_New(
        0,
        0,
        0,
        0,
        0,
        __pyx_empty_bytes, /*PyObject *code,*/
        __pyx_empty_tuple, /*PyObject *consts,*/
        __pyx_empty_tuple, /*PyObject *names,*/
        __pyx_empty_tuple, /*PyObject *varnames,*/
        __pyx_empty_tuple, /*PyObject *freevars,*/
        __pyx_empty_tuple, /*PyObject *cellvars,*/
        py_srcfile,   /*PyObject *filename,*/
        py_funcname,  /*PyObject *name,*/
        py_line,
        __pyx_empty_bytes  /*PyObject *lnotab*/
    );
    Py_DECREF(py_srcfile);
    Py_DECREF(py_funcname);
    return py_code;
bad:
    Py_XDECREF(py_srcfile);
    Py_XDECREF(py_funcname);
    return NULL;
}
static void __Pyx_AddTraceback(const char *funcname, int c_line,
                               int py_line, const char *filename) {
    PyCodeObject *py_code = 0;
    PyFrameObject *py_frame = 0;
    py_code = __pyx_find_code_object(c_line ? c_line : py_line);
    if (!py_code) {
        py_code = __Pyx_CreateCodeObjectForTraceback(
            funcname, c_line, py_line, filename);
        if (!py_code) goto bad;
        __pyx_insert_code_object(c_line ? c_line : py_line, py_code);
    }
    py_frame = PyFrame_New(
        PyThreadState_GET(), /*PyThreadState *tstate,*/
        py_code,             /*PyCodeObject *code,*/
        __pyx_d,      /*PyObject *globals,*/
        0                    /*PyObject *locals*/
    );
    if (!py_frame) goto bad;
    py_frame->f_lineno = py_line;
    PyTraceBack_Here(py_frame);
bad:
    Py_XDECREF(py_code);
    Py_XDECREF(py_frame);
}

static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value) {
    const int neg_one = (int) -1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(int) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(int) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
        } else if (sizeof(int) <= sizeof(unsigned long long)) {
            return PyLong_FromUnsignedLongLong((unsigned long long) value);
        }
    } else {
        if (sizeof(int) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(int) <= sizeof(long long)) {
            return PyLong_FromLongLong((long long) value);
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(int),
                                     little, !is_unsigned);
    }
}

static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level) {
    PyObject *empty_list = 0;
    PyObject *module = 0;
    PyObject *global_dict = 0;
    PyObject *empty_dict = 0;
    PyObject *list;
    #if PY_VERSION_HEX < 0x03030000
    PyObject *py_import;
    py_import = __Pyx_PyObject_GetAttrStr(__pyx_b, __pyx_n_s_import);
    if (!py_import)
        goto bad;
    #endif
    if (from_list)
        list = from_list;
    else {
        empty_list = PyList_New(0);
        if (!empty_list)
            goto bad;
        list = empty_list;
    }
    global_dict = PyModule_GetDict(__pyx_m);
    if (!global_dict)
        goto bad;
    empty_dict = PyDict_New();
    if (!empty_dict)
        goto bad;
    {
        #if PY_MAJOR_VERSION >= 3
        if (level == -1) {
            if (strchr(__Pyx_MODULE_NAME, '.')) {
                #if PY_VERSION_HEX < 0x03030000
                PyObject *py_level = PyInt_FromLong(1);
                if (!py_level)
                    goto bad;
                module = PyObject_CallFunctionObjArgs(py_import,
                    name, global_dict, empty_dict, list, py_level, NULL);
                Py_DECREF(py_level);
                #else
                module = PyImport_ImportModuleLevelObject(
                    name, global_dict, empty_dict, list, 1);
                #endif
                if (!module) {
                    if (!PyErr_ExceptionMatches(PyExc_ImportError))
                        goto bad;
                    PyErr_Clear();
                }
            }
            level = 0;
        }
        #endif
        if (!module) {
            #if PY_VERSION_HEX < 0x03030000
            PyObject *py_level = PyInt_FromLong(level);
            if (!py_level)
                goto bad;
            module = PyObject_CallFunctionObjArgs(py_import,
                name, global_dict, empty_dict, list, py_level, NULL);
            Py_DECREF(py_level);
            #else
            module = PyImport_ImportModuleLevelObject(
                name, global_dict, empty_dict, list, level);
            #endif
        }
    }
bad:
    #if PY_VERSION_HEX < 0x03030000
    Py_XDECREF(py_import);
    #endif
    Py_XDECREF(empty_list);
    Py_XDECREF(empty_dict);
    return module;
}

#define __PYX_VERIFY_RETURN_INT(target_type, func_type, func_value)       \
    {                                                                     \
        func_type value = func_value;                                     \
        if (sizeof(target_type) < sizeof(func_type)) {                    \
            if (unlikely(value != (func_type) (target_type) value)) {     \
                func_type zero = 0;                                       \
                if (is_unsigned && unlikely(value < zero))                \
                    goto raise_neg_overflow;                              \
                else                                                      \
                    goto raise_overflow;                                  \
            }                                                             \
        }                                                                 \
        return (target_type) value;                                       \
    }

#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
 #if CYTHON_USE_PYLONG_INTERNALS
  #include "longintrepr.h"
 #endif
#endif

static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *x) {
    const int neg_one = (int) -1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(int) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(int, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (int) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
 #if CYTHON_USE_PYLONG_INTERNALS
            switch (Py_SIZE(x)) {
                case  0: return 0;
                case  1: __PYX_VERIFY_RETURN_INT(int, digit, ((PyLongObject*)x)->ob_digit[0]);
            }
 #endif
#endif
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
            if (sizeof(int) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT(int, unsigned long, PyLong_AsUnsignedLong(x))
            } else if (sizeof(int) <= sizeof(unsigned long long)) {
                __PYX_VERIFY_RETURN_INT(int, unsigned long long, PyLong_AsUnsignedLongLong(x))
            }
        } else {
#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
 #if CYTHON_USE_PYLONG_INTERNALS
            switch (Py_SIZE(x)) {
                case  0: return 0;
                case  1: __PYX_VERIFY_RETURN_INT(int,  digit, +(((PyLongObject*)x)->ob_digit[0]));
                case -1: __PYX_VERIFY_RETURN_INT(int, sdigit, -(sdigit) ((PyLongObject*)x)->ob_digit[0]);
            }
 #endif
#endif
            if (sizeof(int) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT(int, long, PyLong_AsLong(x))
            } else if (sizeof(int) <= sizeof(long long)) {
                __PYX_VERIFY_RETURN_INT(int, long long, PyLong_AsLongLong(x))
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            int val;
            PyObject *v = __Pyx_PyNumber_Int(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (int) -1;
        }
    } else {
        int val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (int) -1;
        val = __Pyx_PyInt_As_int(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to int");
    return (int) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to int");
    return (int) -1;
}

static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *x) {
    const long neg_one = (long) -1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(long) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(long, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (long) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
 #if CYTHON_USE_PYLONG_INTERNALS
            switch (Py_SIZE(x)) {
                case  0: return 0;
                case  1: __PYX_VERIFY_RETURN_INT(long, digit, ((PyLongObject*)x)->ob_digit[0]);
            }
 #endif
#endif
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
            if (sizeof(long) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT(long, unsigned long, PyLong_AsUnsignedLong(x))
            } else if (sizeof(long) <= sizeof(unsigned long long)) {
                __PYX_VERIFY_RETURN_INT(long, unsigned long long, PyLong_AsUnsignedLongLong(x))
            }
        } else {
#if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
 #if CYTHON_USE_PYLONG_INTERNALS
            switch (Py_SIZE(x)) {
                case  0: return 0;
                case  1: __PYX_VERIFY_RETURN_INT(long,  digit, +(((PyLongObject*)x)->ob_digit[0]));
                case -1: __PYX_VERIFY_RETURN_INT(long, sdigit, -(sdigit) ((PyLongObject*)x)->ob_digit[0]);
            }
 #endif
#endif
            if (sizeof(long) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT(long, long, PyLong_AsLong(x))
            } else if (sizeof(long) <= sizeof(long long)) {
                __PYX_VERIFY_RETURN_INT(long, long long, PyLong_AsLongLong(x))
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            long val;
            PyObject *v = __Pyx_PyNumber_Int(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (long) -1;
        }
    } else {
        long val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (long) -1;
        val = __Pyx_PyInt_As_long(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to long");
    return (long) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to long");
    return (long) -1;
}

static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value) {
    const long neg_one = (long) -1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(long) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(long) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
        } else if (sizeof(long) <= sizeof(unsigned long long)) {
            return PyLong_FromUnsignedLongLong((unsigned long long) value);
        }
    } else {
        if (sizeof(long) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(long) <= sizeof(long long)) {
            return PyLong_FromLongLong((long long) value);
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(long),
                                     little, !is_unsigned);
    }
}

static PyObject* __Pyx_PyObject_CallMethod1(PyObject* obj, PyObject* method_name, PyObject* arg) {
    PyObject *method, *result = NULL;
    method = __Pyx_PyObject_GetAttrStr(obj, method_name);
    if (unlikely(!method)) goto bad;
#if CYTHON_COMPILING_IN_CPYTHON
    if (likely(PyMethod_Check(method))) {
        PyObject *self = PyMethod_GET_SELF(method);
        if (likely(self)) {
            PyObject *args;
            PyObject *function = PyMethod_GET_FUNCTION(method);
            args = PyTuple_New(2);
            if (unlikely(!args)) goto bad;
            Py_INCREF(self);
            PyTuple_SET_ITEM(args, 0, self);
            Py_INCREF(arg);
            PyTuple_SET_ITEM(args, 1, arg);
            Py_INCREF(function);
            Py_DECREF(method); method = NULL;
            result = __Pyx_PyObject_Call(function, args, NULL);
            Py_DECREF(args);
            Py_DECREF(function);
            return result;
        }
    }
#endif
    result = __Pyx_PyObject_CallOneArg(method, arg);
bad:
    Py_XDECREF(method);
    return result;
}

static PyObject *__Pyx_Generator_Next(PyObject *self);
static PyObject *__Pyx_Generator_Send(PyObject *self, PyObject *value);
static PyObject *__Pyx_Generator_Close(PyObject *self);
static PyObject *__Pyx_Generator_Throw(PyObject *gen, PyObject *args);
static PyTypeObject *__pyx_GeneratorType = 0;
#define __Pyx_Generator_CheckExact(obj) (Py_TYPE(obj) == __pyx_GeneratorType)
#define __Pyx_Generator_Undelegate(gen) Py_CLEAR((gen)->yieldfrom)
#if 1 || PY_VERSION_HEX < 0x030300B0
static int __Pyx_PyGen_FetchStopIterationValue(PyObject **pvalue) {
    PyObject *et, *ev, *tb;
    PyObject *value = NULL;
    __Pyx_ErrFetch(&et, &ev, &tb);
    if (!et) {
        Py_XDECREF(tb);
        Py_XDECREF(ev);
        Py_INCREF(Py_None);
        *pvalue = Py_None;
        return 0;
    }
    if (unlikely(et != PyExc_StopIteration) &&
            unlikely(!PyErr_GivenExceptionMatches(et, PyExc_StopIteration))) {
        __Pyx_ErrRestore(et, ev, tb);
        return -1;
    }
    if (likely(et == PyExc_StopIteration)) {
        if (likely(!ev) || !PyObject_IsInstance(ev, PyExc_StopIteration)) {
            if (!ev) {
                Py_INCREF(Py_None);
                ev = Py_None;
            }
            Py_XDECREF(tb);
            Py_DECREF(et);
            *pvalue = ev;
            return 0;
        }
    }
    PyErr_NormalizeException(&et, &ev, &tb);
    if (unlikely(!PyObject_IsInstance(ev, PyExc_StopIteration))) {
        __Pyx_ErrRestore(et, ev, tb);
        return -1;
    }
    Py_XDECREF(tb);
    Py_DECREF(et);
#if PY_VERSION_HEX >= 0x030300A0
    value = ((PyStopIterationObject *)ev)->value;
    Py_INCREF(value);
    Py_DECREF(ev);
#else
    {
        PyObject* args = PyObject_GetAttr(ev, __pyx_n_s_args);
        Py_DECREF(ev);
        if (likely(args)) {
            value = PyObject_GetItem(args, 0);
            Py_DECREF(args);
        }
        if (unlikely(!value)) {
            __Pyx_ErrRestore(NULL, NULL, NULL);
            Py_INCREF(Py_None);
            value = Py_None;
        }
    }
#endif
    *pvalue = value;
    return 0;
}
#endif
static CYTHON_INLINE
void __Pyx_Generator_ExceptionClear(__pyx_GeneratorObject *self) {
    PyObject *exc_type = self->exc_type;
    PyObject *exc_value = self->exc_value;
    PyObject *exc_traceback = self->exc_traceback;
    self->exc_type = NULL;
    self->exc_value = NULL;
    self->exc_traceback = NULL;
    Py_XDECREF(exc_type);
    Py_XDECREF(exc_value);
    Py_XDECREF(exc_traceback);
}
static CYTHON_INLINE
int __Pyx_Generator_CheckRunning(__pyx_GeneratorObject *gen) {
    if (unlikely(gen->is_running)) {
        PyErr_SetString(PyExc_ValueError,
                        "generator already executing");
        return 1;
    }
    return 0;
}
static CYTHON_INLINE
PyObject *__Pyx_Generator_SendEx(__pyx_GeneratorObject *self, PyObject *value) {
    PyObject *retval;
    assert(!self->is_running);
    if (unlikely(self->resume_label == 0)) {
        if (unlikely(value && value != Py_None)) {
            PyErr_SetString(PyExc_TypeError,
                            "can't send non-None value to a "
                            "just-started generator");
            return NULL;
        }
    }
    if (unlikely(self->resume_label == -1)) {
        PyErr_SetNone(PyExc_StopIteration);
        return NULL;
    }
    if (value) {
#if CYTHON_COMPILING_IN_PYPY
#else
        if (self->exc_traceback) {
            PyThreadState *tstate = PyThreadState_GET();
            PyTracebackObject *tb = (PyTracebackObject *) self->exc_traceback;
            PyFrameObject *f = tb->tb_frame;
            Py_XINCREF(tstate->frame);
            assert(f->f_back == NULL);
            f->f_back = tstate->frame;
        }
#endif
        __Pyx_ExceptionSwap(&self->exc_type, &self->exc_value,
                            &self->exc_traceback);
    } else {
        __Pyx_Generator_ExceptionClear(self);
    }
    self->is_running = 1;
    retval = self->body((PyObject *) self, value);
    self->is_running = 0;
    if (retval) {
        __Pyx_ExceptionSwap(&self->exc_type, &self->exc_value,
                            &self->exc_traceback);
#if CYTHON_COMPILING_IN_PYPY
#else
        if (self->exc_traceback) {
            PyTracebackObject *tb = (PyTracebackObject *) self->exc_traceback;
            PyFrameObject *f = tb->tb_frame;
            Py_CLEAR(f->f_back);
        }
#endif
    } else {
        __Pyx_Generator_ExceptionClear(self);
    }
    return retval;
}
static CYTHON_INLINE
PyObject *__Pyx_Generator_FinishDelegation(__pyx_GeneratorObject *gen) {
    PyObject *ret;
    PyObject *val = NULL;
    __Pyx_Generator_Undelegate(gen);
    __Pyx_PyGen_FetchStopIterationValue(&val);
    ret = __Pyx_Generator_SendEx(gen, val);
    Py_XDECREF(val);
    return ret;
}
static PyObject *__Pyx_Generator_Next(PyObject *self) {
    __pyx_GeneratorObject *gen = (__pyx_GeneratorObject*) self;
    PyObject *yf = gen->yieldfrom;
    if (unlikely(__Pyx_Generator_CheckRunning(gen)))
        return NULL;
    if (yf) {
        PyObject *ret;
        gen->is_running = 1;
        ret = Py_TYPE(yf)->tp_iternext(yf);
        gen->is_running = 0;
        if (likely(ret)) {
            return ret;
        }
        return __Pyx_Generator_FinishDelegation(gen);
    }
    return __Pyx_Generator_SendEx(gen, Py_None);
}
static PyObject *__Pyx_Generator_Send(PyObject *self, PyObject *value) {
    __pyx_GeneratorObject *gen = (__pyx_GeneratorObject*) self;
    PyObject *yf = gen->yieldfrom;
    if (unlikely(__Pyx_Generator_CheckRunning(gen)))
        return NULL;
    if (yf) {
        PyObject *ret;
        gen->is_running = 1;
        if (__Pyx_Generator_CheckExact(yf)) {
            ret = __Pyx_Generator_Send(yf, value);
        } else {
            if (value == Py_None)
                ret = PyIter_Next(yf);
            else
                ret = __Pyx_PyObject_CallMethod1(yf, __pyx_n_s_send, value);
        }
        gen->is_running = 0;
        if (likely(ret)) {
            return ret;
        }
        return __Pyx_Generator_FinishDelegation(gen);
    }
    return __Pyx_Generator_SendEx(gen, value);
}
static int __Pyx_Generator_CloseIter(__pyx_GeneratorObject *gen, PyObject *yf) {
    PyObject *retval = NULL;
    int err = 0;
    if (__Pyx_Generator_CheckExact(yf)) {
        retval = __Pyx_Generator_Close(yf);
        if (!retval)
            return -1;
    } else {
        PyObject *meth;
        gen->is_running = 1;
        meth = PyObject_GetAttr(yf, __pyx_n_s_close);
        if (unlikely(!meth)) {
            if (!PyErr_ExceptionMatches(PyExc_AttributeError)) {
                PyErr_WriteUnraisable(yf);
            }
            PyErr_Clear();
        } else {
            retval = PyObject_CallFunction(meth, NULL);
            Py_DECREF(meth);
            if (!retval)
                err = -1;
        }
        gen->is_running = 0;
    }
    Py_XDECREF(retval);
    return err;
}
static PyObject *__Pyx_Generator_Close(PyObject *self) {
    __pyx_GeneratorObject *gen = (__pyx_GeneratorObject *) self;
    PyObject *retval, *raised_exception;
    PyObject *yf = gen->yieldfrom;
    int err = 0;
    if (unlikely(__Pyx_Generator_CheckRunning(gen)))
        return NULL;
    if (yf) {
        Py_INCREF(yf);
        err = __Pyx_Generator_CloseIter(gen, yf);
        __Pyx_Generator_Undelegate(gen);
        Py_DECREF(yf);
    }
    if (err == 0)
        PyErr_SetNone(PyExc_GeneratorExit);
    retval = __Pyx_Generator_SendEx(gen, NULL);
    if (retval) {
        Py_DECREF(retval);
        PyErr_SetString(PyExc_RuntimeError,
                        "generator ignored GeneratorExit");
        return NULL;
    }
    raised_exception = PyErr_Occurred();
    if (!raised_exception
        || raised_exception == PyExc_StopIteration
        || raised_exception == PyExc_GeneratorExit
        || PyErr_GivenExceptionMatches(raised_exception, PyExc_GeneratorExit)
        || PyErr_GivenExceptionMatches(raised_exception, PyExc_StopIteration))
    {
        if (raised_exception) PyErr_Clear();
        Py_INCREF(Py_None);
        return Py_None;
    }
    return NULL;
}
static PyObject *__Pyx_Generator_Throw(PyObject *self, PyObject *args) {
    __pyx_GeneratorObject *gen = (__pyx_GeneratorObject *) self;
    PyObject *typ;
    PyObject *tb = NULL;
    PyObject *val = NULL;
    PyObject *yf = gen->yieldfrom;
    if (!PyArg_UnpackTuple(args, (char *)"throw", 1, 3, &typ, &val, &tb))
        return NULL;
    if (unlikely(__Pyx_Generator_CheckRunning(gen)))
        return NULL;
    if (yf) {
        PyObject *ret;
        Py_INCREF(yf);
        if (PyErr_GivenExceptionMatches(typ, PyExc_GeneratorExit)) {
            int err = __Pyx_Generator_CloseIter(gen, yf);
            Py_DECREF(yf);
            __Pyx_Generator_Undelegate(gen);
            if (err < 0)
                return __Pyx_Generator_SendEx(gen, NULL);
            goto throw_here;
        }
        gen->is_running = 1;
        if (__Pyx_Generator_CheckExact(yf)) {
            ret = __Pyx_Generator_Throw(yf, args);
        } else {
            PyObject *meth = PyObject_GetAttr(yf, __pyx_n_s_throw);
            if (unlikely(!meth)) {
                Py_DECREF(yf);
                if (!PyErr_ExceptionMatches(PyExc_AttributeError)) {
                    gen->is_running = 0;
                    return NULL;
                }
                PyErr_Clear();
                __Pyx_Generator_Undelegate(gen);
                gen->is_running = 0;
                goto throw_here;
            }
            ret = PyObject_CallObject(meth, args);
            Py_DECREF(meth);
        }
        gen->is_running = 0;
        Py_DECREF(yf);
        if (!ret) {
            ret = __Pyx_Generator_FinishDelegation(gen);
        }
        return ret;
    }
throw_here:
    __Pyx_Raise(typ, val, tb, NULL);
    return __Pyx_Generator_SendEx(gen, NULL);
}
static int __Pyx_Generator_traverse(PyObject *self, visitproc visit, void *arg) {
    __pyx_GeneratorObject *gen = (__pyx_GeneratorObject *) self;
    Py_VISIT(gen->closure);
    Py_VISIT(gen->classobj);
    Py_VISIT(gen->yieldfrom);
    Py_VISIT(gen->exc_type);
    Py_VISIT(gen->exc_value);
    Py_VISIT(gen->exc_traceback);
    return 0;
}
static int __Pyx_Generator_clear(PyObject *self) {
    __pyx_GeneratorObject *gen = (__pyx_GeneratorObject *) self;
    Py_CLEAR(gen->closure);
    Py_CLEAR(gen->classobj);
    Py_CLEAR(gen->yieldfrom);
    Py_CLEAR(gen->exc_type);
    Py_CLEAR(gen->exc_value);
    Py_CLEAR(gen->exc_traceback);
    Py_CLEAR(gen->gi_name);
    Py_CLEAR(gen->gi_qualname);
    return 0;
}
static void __Pyx_Generator_dealloc(PyObject *self) {
    __pyx_GeneratorObject *gen = (__pyx_GeneratorObject *) self;
    PyObject_GC_UnTrack(gen);
    if (gen->gi_weakreflist != NULL)
        PyObject_ClearWeakRefs(self);
    if (gen->resume_label > 0) {
        PyObject_GC_Track(self);
#if PY_VERSION_HEX >= 0x030400a1
        if (PyObject_CallFinalizerFromDealloc(self))
#else
        Py_TYPE(gen)->tp_del(self);
        if (self->ob_refcnt > 0)
#endif
        {
            return;
        }
        PyObject_GC_UnTrack(self);
    }
    __Pyx_Generator_clear(self);
    PyObject_GC_Del(gen);
}
static void __Pyx_Generator_del(PyObject *self) {
    PyObject *res;
    PyObject *error_type, *error_value, *error_traceback;
    __pyx_GeneratorObject *gen = (__pyx_GeneratorObject *) self;
    if (gen->resume_label <= 0)
        return ;
#if PY_VERSION_HEX < 0x030400a1
    assert(self->ob_refcnt == 0);
    self->ob_refcnt = 1;
#endif
    __Pyx_ErrFetch(&error_type, &error_value, &error_traceback);
    res = __Pyx_Generator_Close(self);
    if (res == NULL)
        PyErr_WriteUnraisable(self);
    else
        Py_DECREF(res);
    __Pyx_ErrRestore(error_type, error_value, error_traceback);
#if PY_VERSION_HEX < 0x030400a1
    assert(self->ob_refcnt > 0);
    if (--self->ob_refcnt == 0) {
        return;
    }
    {
        Py_ssize_t refcnt = self->ob_refcnt;
        _Py_NewReference(self);
        self->ob_refcnt = refcnt;
    }
#if CYTHON_COMPILING_IN_CPYTHON
    assert(PyType_IS_GC(self->ob_type) &&
           _Py_AS_GC(self)->gc.gc_refs != _PyGC_REFS_UNTRACKED);
    _Py_DEC_REFTOTAL;
#endif
#ifdef COUNT_ALLOCS
    --Py_TYPE(self)->tp_frees;
    --Py_TYPE(self)->tp_allocs;
#endif
#endif
}
static PyObject *
__Pyx_Generator_get_name(__pyx_GeneratorObject *self)
{
    Py_INCREF(self->gi_name);
    return self->gi_name;
}
static int
__Pyx_Generator_set_name(__pyx_GeneratorObject *self, PyObject *value)
{
    PyObject *tmp;
#if PY_MAJOR_VERSION >= 3
    if (unlikely(value == NULL || !PyUnicode_Check(value))) {
#else
    if (unlikely(value == NULL || !PyString_Check(value))) {
#endif
        PyErr_SetString(PyExc_TypeError,
                        "__name__ must be set to a string object");
        return -1;
    }
    tmp = self->gi_name;
    Py_INCREF(value);
    self->gi_name = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyObject *
__Pyx_Generator_get_qualname(__pyx_GeneratorObject *self)
{
    Py_INCREF(self->gi_qualname);
    return self->gi_qualname;
}
static int
__Pyx_Generator_set_qualname(__pyx_GeneratorObject *self, PyObject *value)
{
    PyObject *tmp;
#if PY_MAJOR_VERSION >= 3
    if (unlikely(value == NULL || !PyUnicode_Check(value))) {
#else
    if (unlikely(value == NULL || !PyString_Check(value))) {
#endif
        PyErr_SetString(PyExc_TypeError,
                        "__qualname__ must be set to a string object");
        return -1;
    }
    tmp = self->gi_qualname;
    Py_INCREF(value);
    self->gi_qualname = value;
    Py_XDECREF(tmp);
    return 0;
}
static PyGetSetDef __pyx_Generator_getsets[] = {
    {(char *) "__name__", (getter)__Pyx_Generator_get_name, (setter)__Pyx_Generator_set_name,
     (char*) PyDoc_STR("name of the generator"), 0},
    {(char *) "__qualname__", (getter)__Pyx_Generator_get_qualname, (setter)__Pyx_Generator_set_qualname,
     (char*) PyDoc_STR("qualified name of the generator"), 0},
    {0, 0, 0, 0, 0}
};
static PyMemberDef __pyx_Generator_memberlist[] = {
    {(char *) "gi_running", T_BOOL, offsetof(__pyx_GeneratorObject, is_running), READONLY, NULL},
    {0, 0, 0, 0, 0}
};
static PyMethodDef __pyx_Generator_methods[] = {
    {"send", (PyCFunction) __Pyx_Generator_Send, METH_O, 0},
    {"throw", (PyCFunction) __Pyx_Generator_Throw, METH_VARARGS, 0},
    {"close", (PyCFunction) __Pyx_Generator_Close, METH_NOARGS, 0},
    {0, 0, 0, 0}
};
static PyTypeObject __pyx_GeneratorType_type = {
    PyVarObject_HEAD_INIT(0, 0)
    "generator",
    sizeof(__pyx_GeneratorObject),
    0,
    (destructor) __Pyx_Generator_dealloc,
    0,
    0,
    0,
#if PY_MAJOR_VERSION < 3
    0,
#else
    0,
#endif
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_HAVE_FINALIZE,
    0,
    (traverseproc) __Pyx_Generator_traverse,
    0,
    0,
    offsetof(__pyx_GeneratorObject, gi_weakreflist),
    0,
    (iternextfunc) __Pyx_Generator_Next,
    __pyx_Generator_methods,
    __pyx_Generator_memberlist,
    __pyx_Generator_getsets,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
#if PY_VERSION_HEX >= 0x030400a1
    0,
#else
    __Pyx_Generator_del,
#endif
    0,
#if PY_VERSION_HEX >= 0x030400a1
    __Pyx_Generator_del,
#endif
};
static __pyx_GeneratorObject *__Pyx_Generator_New(__pyx_generator_body_t body,
                                                  PyObject *closure, PyObject *name, PyObject *qualname) {
    __pyx_GeneratorObject *gen =
        PyObject_GC_New(__pyx_GeneratorObject, &__pyx_GeneratorType_type);
    if (gen == NULL)
        return NULL;
    gen->body = body;
    gen->closure = closure;
    Py_XINCREF(closure);
    gen->is_running = 0;
    gen->resume_label = 0;
    gen->classobj = NULL;
    gen->yieldfrom = NULL;
    gen->exc_type = NULL;
    gen->exc_value = NULL;
    gen->exc_traceback = NULL;
    gen->gi_weakreflist = NULL;
    Py_XINCREF(qualname);
    gen->gi_qualname = qualname;
    Py_XINCREF(name);
    gen->gi_name = name;
    PyObject_GC_Track(gen);
    return gen;
}
static int __pyx_Generator_init(void) {
    __pyx_GeneratorType_type.tp_getattro = PyObject_GenericGetAttr;
    __pyx_GeneratorType_type.tp_iter = PyObject_SelfIter;
    __pyx_GeneratorType = __Pyx_FetchCommonType(&__pyx_GeneratorType_type);
    if (__pyx_GeneratorType == NULL) {
        return -1;
    }
    return 0;
}

static int __Pyx_check_binary_version(void) {
    char ctversion[4], rtversion[4];
    PyOS_snprintf(ctversion, 4, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
    PyOS_snprintf(rtversion, 4, "%s", Py_GetVersion());
    if (ctversion[0] != rtversion[0] || ctversion[2] != rtversion[2]) {
        char message[200];
        PyOS_snprintf(message, sizeof(message),
                      "compiletime version %s of module '%.100s' "
                      "does not match runtime version %s",
                      ctversion, __Pyx_MODULE_NAME, rtversion);
        return PyErr_WarnEx(NULL, message, 1);
    }
    return 0;
}

static int __Pyx_ExportFunction(const char *name, void (*f)(void), const char *sig) {
    PyObject *d = 0;
    PyObject *cobj = 0;
    union {
        void (*fp)(void);
        void *p;
    } tmp;
    d = PyObject_GetAttrString(__pyx_m, (char *)"__pyx_capi__");
    if (!d) {
        PyErr_Clear();
        d = PyDict_New();
        if (!d)
            goto bad;
        Py_INCREF(d);
        if (PyModule_AddObject(__pyx_m, (char *)"__pyx_capi__", d) < 0)
            goto bad;
    }
    tmp.fp = f;
#if PY_VERSION_HEX >= 0x02070000
    cobj = PyCapsule_New(tmp.p, sig, 0);
#else
    cobj = PyCObject_FromVoidPtrAndDesc(tmp.p, (void *)sig, 0);
#endif
    if (!cobj)
        goto bad;
    if (PyDict_SetItemString(d, name, cobj) < 0)
        goto bad;
    Py_DECREF(cobj);
    Py_DECREF(d);
    return 0;
bad:
    Py_XDECREF(cobj);
    Py_XDECREF(d);
    return -1;
}

#ifndef __PYX_HAVE_RT_ImportModule
#define __PYX_HAVE_RT_ImportModule
static PyObject *__Pyx_ImportModule(const char *name) {
    PyObject *py_name = 0;
    PyObject *py_module = 0;
    py_name = __Pyx_PyIdentifier_FromString(name);
    if (!py_name)
        goto bad;
    py_module = PyImport_Import(py_name);
    Py_DECREF(py_name);
    return py_module;
bad:
    Py_XDECREF(py_name);
    return 0;
}
#endif

#ifndef __PYX_HAVE_RT_ImportType
#define __PYX_HAVE_RT_ImportType
static PyTypeObject *__Pyx_ImportType(const char *module_name, const char *class_name,
    size_t size, int strict)
{
    PyObject *py_module = 0;
    PyObject *result = 0;
    PyObject *py_name = 0;
    char warning[200];
    Py_ssize_t basicsize;
#ifdef Py_LIMITED_API
    PyObject *py_basicsize;
#endif
    py_module = __Pyx_ImportModule(module_name);
    if (!py_module)
        goto bad;
    py_name = __Pyx_PyIdentifier_FromString(class_name);
    if (!py_name)
        goto bad;
    result = PyObject_GetAttr(py_module, py_name);
    Py_DECREF(py_name);
    py_name = 0;
    Py_DECREF(py_module);
    py_module = 0;
    if (!result)
        goto bad;
    if (!PyType_Check(result)) {
        PyErr_Format(PyExc_TypeError,
            "%.200s.%.200s is not a type object",
            module_name, class_name);
        goto bad;
    }
#ifndef Py_LIMITED_API
    basicsize = ((PyTypeObject *)result)->tp_basicsize;
#else
    py_basicsize = PyObject_GetAttrString(result, "__basicsize__");
    if (!py_basicsize)
        goto bad;
    basicsize = PyLong_AsSsize_t(py_basicsize);
    Py_DECREF(py_basicsize);
    py_basicsize = 0;
    if (basicsize == (Py_ssize_t)-1 && PyErr_Occurred())
        goto bad;
#endif
    if (!strict && (size_t)basicsize > size) {
        PyOS_snprintf(warning, sizeof(warning),
            "%s.%s size changed, may indicate binary incompatibility",
            module_name, class_name);
        if (PyErr_WarnEx(NULL, warning, 0) < 0) goto bad;
    }
    else if ((size_t)basicsize != size) {
        PyErr_Format(PyExc_ValueError,
            "%.200s.%.200s has the wrong size, try recompiling",
            module_name, class_name);
        goto bad;
    }
    return (PyTypeObject *)result;
bad:
    Py_XDECREF(py_module);
    Py_XDECREF(result);
    return NULL;
}
#endif

static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
    while (t->p) {
        #if PY_MAJOR_VERSION < 3
        if (t->is_unicode) {
            *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
        } else if (t->intern) {
            *t->p = PyString_InternFromString(t->s);
        } else {
            *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
        }
        #else
        if (t->is_unicode | t->is_str) {
            if (t->intern) {
                *t->p = PyUnicode_InternFromString(t->s);
            } else if (t->encoding) {
                *t->p = PyUnicode_Decode(t->s, t->n - 1, t->encoding, NULL);
            } else {
                *t->p = PyUnicode_FromStringAndSize(t->s, t->n - 1);
            }
        } else {
            *t->p = PyBytes_FromStringAndSize(t->s, t->n - 1);
        }
        #endif
        if (!*t->p)
            return -1;
        ++t;
    }
    return 0;
}

static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(const char* c_str) {
    return __Pyx_PyUnicode_FromStringAndSize(c_str, (Py_ssize_t)strlen(c_str));
}
static CYTHON_INLINE char* __Pyx_PyObject_AsString(PyObject* o) {
    Py_ssize_t ignore;
    return __Pyx_PyObject_AsStringAndSize(o, &ignore);
}
static CYTHON_INLINE char* __Pyx_PyObject_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
    if (
#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
            __Pyx_sys_getdefaultencoding_not_ascii &&
#endif
            PyUnicode_Check(o)) {
#if PY_VERSION_HEX < 0x03030000
        char* defenc_c;
        PyObject* defenc = _PyUnicode_AsDefaultEncodedString(o, NULL);
        if (!defenc) return NULL;
        defenc_c = PyBytes_AS_STRING(defenc);
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
        {
            char* end = defenc_c + PyBytes_GET_SIZE(defenc);
            char* c;
            for (c = defenc_c; c < end; c++) {
                if ((unsigned char) (*c) >= 128) {
                    PyUnicode_AsASCIIString(o);
                    return NULL;
                }
            }
        }
#endif
        *length = PyBytes_GET_SIZE(defenc);
        return defenc_c;
#else
        if (__Pyx_PyUnicode_READY(o) == -1) return NULL;
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
        if (PyUnicode_IS_ASCII(o)) {
            *length = PyUnicode_GET_LENGTH(o);
            return PyUnicode_AsUTF8(o);
        } else {
            PyUnicode_AsASCIIString(o);
            return NULL;
        }
#else
        return PyUnicode_AsUTF8AndSize(o, length);
#endif
#endif
    } else
#endif
#if !CYTHON_COMPILING_IN_PYPY
    if (PyByteArray_Check(o)) {
        *length = PyByteArray_GET_SIZE(o);
        return PyByteArray_AS_STRING(o);
    } else
#endif
    {
        char* result;
        int r = PyBytes_AsStringAndSize(o, &result, length);
        if (unlikely(r < 0)) {
            return NULL;
        } else {
            return result;
        }
    }
}
static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {
   int is_true = x == Py_True;
   if (is_true | (x == Py_False) | (x == Py_None)) return is_true;
   else return PyObject_IsTrue(x);
}
static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x) {
  PyNumberMethods *m;
  const char *name = NULL;
  PyObject *res = NULL;
#if PY_MAJOR_VERSION < 3
  if (PyInt_Check(x) || PyLong_Check(x))
#else
  if (PyLong_Check(x))
#endif
    return Py_INCREF(x), x;
  m = Py_TYPE(x)->tp_as_number;
#if PY_MAJOR_VERSION < 3
  if (m && m->nb_int) {
    name = "int";
    res = PyNumber_Int(x);
  }
  else if (m && m->nb_long) {
    name = "long";
    res = PyNumber_Long(x);
  }
#else
  if (m && m->nb_int) {
    name = "int";
    res = PyNumber_Long(x);
  }
#endif
  if (res) {
#if PY_MAJOR_VERSION < 3
    if (!PyInt_Check(res) && !PyLong_Check(res)) {
#else
    if (!PyLong_Check(res)) {
#endif
      PyErr_Format(PyExc_TypeError,
                   "__%.4s__ returned non-%.4s (type %.200s)",
                   name, name, Py_TYPE(res)->tp_name);
      Py_DECREF(res);
      return NULL;
    }
  }
  else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
                    "an integer is required");
  }
  return res;
}
static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject* b) {
  Py_ssize_t ival;
  PyObject *x;
#if PY_MAJOR_VERSION < 3
  if (likely(PyInt_CheckExact(b)))
      return PyInt_AS_LONG(b);
#endif
  if (likely(PyLong_CheckExact(b))) {
    #if CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
     #if CYTHON_USE_PYLONG_INTERNALS
       switch (Py_SIZE(b)) {
       case -1: return -(sdigit)((PyLongObject*)b)->ob_digit[0];
       case  0: return 0;
       case  1: return ((PyLongObject*)b)->ob_digit[0];
       }
     #endif
    #endif
    return PyLong_AsSsize_t(b);
  }
  x = PyNumber_Index(b);
  if (!x) return -1;
  ival = PyInt_AsSsize_t(x);
  Py_DECREF(x);
  return ival;
}
static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
    return PyInt_FromSize_t(ival);
}


#endif /* Py_PYTHON_H */
